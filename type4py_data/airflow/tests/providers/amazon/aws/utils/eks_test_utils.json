{"error": null, "response": {"classes": [], "funcs": [{"docstring": {"func": "Assembles the list of tuples which will be used to validate test results.", "long_descr": "The format of the tuple is (attribute name, expected value)", "ret": "Returns a list of tuples containing the keys and values to be validated in testing."}, "fn_lc": [[41, 0], [81, 17]], "fn_var_ln": {"final_tag_set": [[72, 16], [72, 29]], "required_tag": [[67, 8], [67, 20]], "result": [[74, 8], [74, 14]]}, "fn_var_occur": {"final_tag_set": [["final_tag_set", "builtins", "dict", "required_tag"], ["final_tag_set", "value", "final_tag_set"], ["result", "key", "value", "key", "NodegroupAttributes", "TAGS", "NodegroupAttributes", "TAGS", "final_tag_set", "key", "value", "result"]], "required_tag": [["required_tag", "builtins", "dict", "cluster_name"], ["final_tag_set", "builtins", "dict", "required_tag"]], "result": [["result", "builtins", "list", "builtins", "tuple", "deepcopy", "inputs", "REQUIRED", "inputs", "OPTIONAL", "STATUS"], ["result", "ClusterAttributes", "NAME", "cluster_name"], ["result", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "fargate_profile_name"], ["result", "key", "value", "key", "NodegroupAttributes", "TAGS", "NodegroupAttributes", "TAGS", "final_tag_set", "key", "value", "result"], ["result", "NodegroupAttributes", "NODEGROUP_NAME", "nodegroup_name"]]}, "name": "attributes_to_test", "params": {"cluster_name": "builtins.str", "fargate_profile_name": "str | None", "inputs": "InputTypes", "nodegroup_name": "str | None"}, "params_descr": {"cluster_name": "The name of the cluster under test.", "fargate_profile_name": "The name of the Fargate profile under test if applicable.", "inputs": "A class containing lists of tuples to use for verifying the output\nof cluster or nodegroup creation tests.", "nodegroup_name": "The name of the nodegroup under test if applicable."}, "params_occur": {"cluster_name": [["result", "ClusterAttributes", "NAME", "cluster_name"], ["required_tag", "builtins", "dict", "cluster_name"]], "fargate_profile_name": [["result", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "fargate_profile_name"]], "inputs": [["result", "builtins", "list", "builtins", "tuple", "deepcopy", "inputs", "REQUIRED", "inputs", "OPTIONAL", "STATUS"], ["inputs", "ClusterInputs"], ["inputs", "FargateProfileInputs"], ["inputs", "NodegroupInputs"]], "nodegroup_name": [["result", "NodegroupAttributes", "NODEGROUP_NAME", "nodegroup_name"]]}, "params_p": {"args": [], "cluster_name": [["dict", 0.3194582522507045], ["str", 0.2845203375098717], ["Dict[str, Any]", 0.10121175477878032], ["Optional[Type]", 0.10121175477878032]], "fargate_profile_name": [["str", 1.0000000000000002]], "inputs": [["str", 0.3942948325272458], ["List[str]", 0.19859424961762773], ["bool", 0.10425185788620521], ["list", 0.10415728526155422], ["BinaryIO", 0.10142203080485024], ["float", 0.09727974390251659]], "kwargs": [], "nodegroup_name": [["str", 0.7792964948098785], ["Optional[str]", 0.08206623150262109]]}, "q_name": "attributes_to_test", "ret_exprs": ["return result"], "ret_type": "builtins.list[builtins.tuple]", "ret_type_p": [["Tuple[int, Dict[str, Any]]", 0.11838131263524122], ["bool", 0.113757540908094], ["List[object]", 0.09091808805245079], ["List[str]", 0.08854848921703955]], "variables": {"final_tag_set": "", "required_tag": "builtins.dict", "result": ""}, "variables_p": {"final_tag_set": [["dict", 1.0000000000000002]], "required_tag": [["dict", 0.8063510691963655], ["Dict[str, Dict[str, Any]]", 0.09799286838243695], ["Dict[str, str]", 0.09565606242119752]], "result": [["list", 0.623013727893284], ["List[List[object]]", 0.28600037532753503], ["List[Match[str]]", 0.09098589677918086]]}}, {"docstring": {"func": "Generates a number of EKS Clusters with data and adds them to the mocked backend.", "long_descr": null, "ret": "Returns a list of the names of the generated clusters."}, "fn_lc": [[84, 0], [99, 5]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "generate_clusters", "params": {"eks_hook": "airflow.providers.amazon.aws.hooks.eks.EksHook", "minimal": "builtins.bool", "num_clusters": "builtins.int"}, "params_descr": {"eks_hook": "An EksHook object used to call the EKS API.", "minimal": "If True, only the required values are generated; if False all values are generated.", "num_clusters": "Number of clusters to generate."}, "params_occur": {"eks_hook": [["eks_hook", "create_cluster", "name", "str", "count", "_input_builder", "ClusterInputs", "minimal", "ResponseAttributes", "CLUSTER", "ClusterAttributes", "NAME", "count", "range", "num_clusters"]], "minimal": [["eks_hook", "create_cluster", "name", "str", "count", "_input_builder", "ClusterInputs", "minimal", "ResponseAttributes", "CLUSTER", "ClusterAttributes", "NAME", "count", "range", "num_clusters"]], "num_clusters": [["eks_hook", "create_cluster", "name", "str", "count", "_input_builder", "ClusterInputs", "minimal", "ResponseAttributes", "CLUSTER", "ClusterAttributes", "NAME", "count", "range", "num_clusters"]]}, "params_p": {"args": [], "eks_hook": [["int", 0.20949230299291377], ["str", 0.20698210278834067], ["Optional[int]", 0.10196601982106433], ["dict", 0.09698590593116717]], "kwargs": [], "minimal": [["int", 0.20949230299291377], ["str", 0.20698210278834067], ["Optional[int]", 0.10196601982106433], ["dict", 0.09698590593116717]], "num_clusters": [["int", 0.20949230299291377], ["str", 0.20698210278834067], ["Optional[int]", 0.10196601982106433], ["dict", 0.09698590593116717]]}, "q_name": "generate_clusters", "ret_exprs": ["return [ eks_hook.create_cluster(name=f\"cluster{str(count)}\", **_input_builder(ClusterInputs, minimal))[ ResponseAttributes.CLUSTER ][ClusterAttributes.NAME] for count in range(num_clusters)]"], "ret_type": "builtins.list[builtins.str]", "ret_type_p": [["str", 0.1697723478221287], ["bool", 0.09091629979242463], ["List[Callable]", 0.09026074200052095]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Generates a number of EKS Fargate profiles with data and adds them to the mocked backend.", "long_descr": null, "ret": "Returns a list of the names of the generated nodegroups."}, "fn_lc": [[102, 0], [122, 5]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "generate_fargate_profiles", "params": {"cluster_name": "builtins.str", "eks_hook": "airflow.providers.amazon.aws.hooks.eks.EksHook", "minimal": "builtins.bool", "num_profiles": "builtins.int"}, "params_descr": {"cluster_name": "The name of the EKS Cluster to attach the nodegroups to.", "eks_hook": "An EksHook object used to call the EKS API.", "minimal": "If True, only the required values are generated; if False all values are generated.", "num_profiles": "Number of Fargate profiles to generate."}, "params_occur": {"cluster_name": [["eks_hook", "create_fargate_profile", "fargateProfileName", "str", "count", "clusterName", "cluster_name", "_input_builder", "FargateProfileInputs", "minimal", "ResponseAttributes", "FARGATE_PROFILE", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "count", "range", "num_profiles"]], "eks_hook": [["eks_hook", "create_fargate_profile", "fargateProfileName", "str", "count", "clusterName", "cluster_name", "_input_builder", "FargateProfileInputs", "minimal", "ResponseAttributes", "FARGATE_PROFILE", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "count", "range", "num_profiles"]], "minimal": [["eks_hook", "create_fargate_profile", "fargateProfileName", "str", "count", "clusterName", "cluster_name", "_input_builder", "FargateProfileInputs", "minimal", "ResponseAttributes", "FARGATE_PROFILE", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "count", "range", "num_profiles"]], "num_profiles": [["eks_hook", "create_fargate_profile", "fargateProfileName", "str", "count", "clusterName", "cluster_name", "_input_builder", "FargateProfileInputs", "minimal", "ResponseAttributes", "FARGATE_PROFILE", "FargateProfileAttributes", "FARGATE_PROFILE_NAME", "count", "range", "num_profiles"]]}, "params_p": {"args": [], "cluster_name": [["str", 0.7123214927562582], ["Sequence[str]", 0.09663860132536761], ["Optional[str]", 0.09551995295918703], ["bool", 0.09551995295918703]], "eks_hook": [["str", 0.7123214927562582], ["Sequence[str]", 0.09663860132536761], ["Optional[str]", 0.09551995295918703], ["bool", 0.09551995295918703]], "kwargs": [], "minimal": [["str", 0.7123214927562582], ["Sequence[str]", 0.09663860132536761], ["Optional[str]", 0.09551995295918703], ["bool", 0.09551995295918703]], "num_profiles": [["str", 0.7123214927562582], ["Sequence[str]", 0.09663860132536761], ["Optional[str]", 0.09551995295918703], ["bool", 0.09551995295918703]]}, "q_name": "generate_fargate_profiles", "ret_exprs": ["return [ eks_hook.create_fargate_profile( fargateProfileName=f\"profile{str(count)}\", clusterName=cluster_name, **_input_builder(FargateProfileInputs, minimal), )[ResponseAttributes.FARGATE_PROFILE][FargateProfileAttributes.FARGATE_PROFILE_NAME] for count in range(num_profiles)]"], "ret_type": "builtins.list[builtins.str]", "ret_type_p": [["float", 0.4473032950750888], ["utils.Node", 0.1517760781255046], ["str", 0.10248125607255983], ["T", 0.08946065901501776]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Generates a number of EKS Managed Nodegroups with data and adds them to the mocked backend.", "long_descr": null, "ret": "Returns a list of the names of the generated nodegroups."}, "fn_lc": [[125, 0], [145, 5]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "generate_nodegroups", "params": {"cluster_name": "builtins.str", "eks_hook": "airflow.providers.amazon.aws.hooks.eks.EksHook", "minimal": "builtins.bool", "num_nodegroups": "builtins.int"}, "params_descr": {"cluster_name": "The name of the EKS Cluster to attach the nodegroups to.", "eks_hook": "An EksHook object used to call the EKS API.", "minimal": "If True, only the required values are generated; if False all values are generated.", "num_nodegroups": "Number of clusters to generate."}, "params_occur": {"cluster_name": [["eks_hook", "create_nodegroup", "nodegroupName", "str", "count", "clusterName", "cluster_name", "_input_builder", "NodegroupInputs", "minimal", "ResponseAttributes", "NODEGROUP", "NodegroupAttributes", "NODEGROUP_NAME", "count", "range", "num_nodegroups"]], "eks_hook": [["eks_hook", "create_nodegroup", "nodegroupName", "str", "count", "clusterName", "cluster_name", "_input_builder", "NodegroupInputs", "minimal", "ResponseAttributes", "NODEGROUP", "NodegroupAttributes", "NODEGROUP_NAME", "count", "range", "num_nodegroups"]], "minimal": [["eks_hook", "create_nodegroup", "nodegroupName", "str", "count", "clusterName", "cluster_name", "_input_builder", "NodegroupInputs", "minimal", "ResponseAttributes", "NODEGROUP", "NodegroupAttributes", "NODEGROUP_NAME", "count", "range", "num_nodegroups"]], "num_nodegroups": [["eks_hook", "create_nodegroup", "nodegroupName", "str", "count", "clusterName", "cluster_name", "_input_builder", "NodegroupInputs", "minimal", "ResponseAttributes", "NODEGROUP", "NodegroupAttributes", "NODEGROUP_NAME", "count", "range", "num_nodegroups"]]}, "params_p": {"args": [], "cluster_name": [["str", 0.6925352461932742], ["Optional[str]", 0.1076645329335502], ["bool", 0.10294223032813865], ["Optional[List[str]]", 0.09685799054503696]], "eks_hook": [["str", 0.6925352461932742], ["Optional[str]", 0.1076645329335502], ["bool", 0.10294223032813865], ["Optional[List[str]]", 0.09685799054503696]], "kwargs": [], "minimal": [["str", 0.6925352461932742], ["Optional[str]", 0.1076645329335502], ["bool", 0.10294223032813865], ["Optional[List[str]]", 0.09685799054503696]], "num_nodegroups": [["str", 0.6925352461932742], ["Optional[str]", 0.1076645329335502], ["bool", 0.10294223032813865], ["Optional[List[str]]", 0.09685799054503696]]}, "q_name": "generate_nodegroups", "ret_exprs": ["return [ eks_hook.create_nodegroup( nodegroupName=f\"nodegroup{str(count)}\", clusterName=cluster_name, **_input_builder(NodegroupInputs, minimal), )[ResponseAttributes.NODEGROUP][NodegroupAttributes.NODEGROUP_NAME] for count in range(num_nodegroups)]"], "ret_type": "builtins.list[builtins.str]", "ret_type_p": [["str", 0.18773513191238977], ["List[str]", 0.0969657417212559], ["int", 0.09394222925667921]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Returns True if the provided region and partition are a valid pair.", "long_descr": null, "ret": "Returns True if the provided region and partition are a valid pair."}, "fn_lc": [[148, 0], [166, 29]], "fn_var_ln": {"valid_matches": [[156, 4], [156, 17]]}, "fn_var_occur": {"valid_matches": [["valid_matches", "builtins", "list", "builtins", "tuple", "builtins", "str", "builtins", "str"]]}, "name": "region_matches_partition", "params": {"partition": "builtins.str", "region": "builtins.str"}, "params_descr": {"partition": "AWS partition code to test.", "region": "AWS region code to test."}, "params_occur": {"partition": [["partition", "expected_partition"]], "region": [["region", "startswith", "prefix"]]}, "params_p": {"args": [], "kwargs": [], "partition": [["str", 0.18342949857579285], ["Dict[str, Any]", 0.18342949857579285], ["Sequence[str]", 0.13420632102075605], ["int", 0.08625596727726365]], "region": [["str", 1.0000000000000004]]}, "q_name": "region_matches_partition", "ret_exprs": ["return partition == expected_partition", "return partition == \"aws\""], "ret_type": "builtins.bool", "ret_type_p": [["str", 0.8467247510692053]], "variables": {"valid_matches": "builtins.list[builtins.tuple[builtins.str, builtins.str]]"}, "variables_p": {"valid_matches": [["Type[Pattern[str]]", 0.27812257463937173], ["Tuple[str, str]", 0.19957427023234736], ["bool", 0.1165736795391882], ["str", 0.11074725200530887], ["Set[str]", 0.09904176872366786], ["Dict[str, str]", 0.09477602002546512]]}}, {"docstring": {"func": "Assembles the inputs which will be used to generate test object into a dictionary.", "long_descr": null, "ret": "Returns a dict containing the keys and values to be validated in testing."}, "fn_lc": [[169, 0], [181, 23]], "fn_var_ln": {"values": [[178, 4], [178, 10]]}, "fn_var_occur": {"values": [["values", "builtins", "list", "builtins", "tuple", "deepcopy", "options", "REQUIRED"], ["values", "extend", "deepcopy", "options", "OPTIONAL"], ["dict", "values"]]}, "name": "_input_builder", "params": {"minimal": "builtins.bool", "options": "InputTypes"}, "params_descr": {"minimal": "If True, only the required values are generated; if False all values are generated.", "options": "A class containing lists of tuples to use for to create\nthe cluster or nodegroup used in testing."}, "params_occur": {"minimal": [], "options": [["values", "builtins", "list", "builtins", "tuple", "deepcopy", "options", "REQUIRED"], ["values", "extend", "deepcopy", "options", "OPTIONAL"]]}, "params_p": {"args": [], "kwargs": [], "minimal": [["str", 0.23291787013656004], ["T", 0.15768635607012757], ["bool", 0.10486081875992714], ["List[dict]", 0.0739409637982703]], "options": [["list", 0.32786763766052945], ["bool", 0.08747838865851743], ["Optional[str]", 0.08235494398144587]]}, "q_name": "_input_builder", "ret_exprs": ["return dict(values)"], "ret_type": "builtins.dict", "ret_type_p": [["str", 0.28510613261135087], ["dict", 0.2012965684626232], ["int", 0.10355161798291775], ["Dict[str, Any]", 0.09139824608104136], ["Dict[str, str]", 0.08921694379613433]], "variables": {"values": "builtins.list[builtins.tuple]"}, "variables_p": {"values": [["list", 0.6889553666577732], ["List[T]", 0.1257791179850389], ["Dict[str, Union[Any, Any, Any, Any]]", 0.09340545968182025], ["List[Tuple[float, str]]", 0.0918600556753676]]}}, {"docstring": {"func": "Converts a string template into a regex template for pattern matching.", "long_descr": null, "ret": "Returns a regex pattern"}, "fn_lc": [[184, 0], [191, 67]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "string_to_regex", "params": {"value": "builtins.str"}, "params_descr": {"value": "The template string to convert."}, "params_occur": {"value": [["re", "compile", "re", "sub", "value"]]}, "params_p": {"args": [], "kwargs": [], "value": [["str", 0.44021753366047356], ["type", 0.18572711593581132]]}, "q_name": "string_to_regex", "ret_exprs": ["return re.compile(re.sub(r\"[{](.*?)[}]\", r\"(?P<1>.+)\", value))"], "ret_type": "typing.Pattern[builtins.str]", "ret_type_p": [["type", 0.20410200853310279], ["Optional[Tuple[Any, Any]]", 0.1987683371352998], ["str", 0.11866236917564056], ["Dict[str, Any]", 0.1116591781050233], ["Optional[str]", 0.10967210176204024]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "API Input and Output keys are formatted differently.  The EKS Hooks map", "long_descr": "as closely as possible to the API calls, which use camelCase variable\nnames, but the Operators match python conventions and use snake_case.\nThis method converts the keys of a dict which are in snake_case (input\nformat) to camelCase (output format) while leaving the dict values unchanged.", "ret": null}, "fn_lc": [[194, 0], [234, 104]], "fn_var_ln": {"conversion_map": [[228, 8], [228, 22]]}, "fn_var_occur": {"conversion_map": [["conversion_map", "k", "k", "conversion_map", "k", "v", "k", "v", "deepcopy", "original", "items"]]}, "name": "convert_keys", "params": {"original": "builtins.dict"}, "params_descr": {"original": "Dict which needs the keys converted."}, "params_occur": {"original": [["original", "keys"], ["original", "keys"], ["conversion_map", "k", "k", "conversion_map", "k", "v", "k", "v", "deepcopy", "original", "items"]]}, "params_p": {"args": [], "kwargs": [], "original": [["dict", 0.30927955467414553], ["Dict[str, Any]", 0.10888680628080905]]}, "q_name": "convert_keys", "ret_exprs": ["return {conversion_map[k] if k in conversion_map else k: v for (k, v) in deepcopy(original).items()}"], "ret_type": "builtins.dict", "ret_type_p": [["tuple", 0.1010518489163705], ["int", 0.1010518489163705], ["raiden.utils.Nonce", 0.09625314211448781], ["List[Dict[str, str]]", 0.09567003872709076]], "variables": {"conversion_map": ""}, "variables_p": {"conversion_map": [["utils.tree.Node[Variable[utils.tree.T]]", 0.12071215485054455], ["dict", 0.0893867543833293]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[237, 0], [238, 61]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "iso_date", "params": {"input_datetime": "datetime.datetime"}, "params_descr": {"input_datetime": ""}, "params_occur": {"input_datetime": [["input_datetime", "strftime"]]}, "params_p": {"args": [], "input_datetime": [["int", 0.2720507166156584], ["str", 0.2558013637365204], ["float", 0.23027323071391748]], "kwargs": []}, "q_name": "iso_date", "ret_exprs": ["return input_datetime.strftime(\"%Y-%m-%dT%H:%M:%S\") + \"Z\""], "ret_type": "builtins.str", "ret_type_p": [["datetime.datetime", 0.38878963041297754], ["int", 0.09724001409112829]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[241, 0], [242, 73]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "generate_dict", "params": {"count": "", "prefix": ""}, "params_descr": {"count": "", "prefix": ""}, "params_occur": {"count": [["prefix", "_count", "str", "_count", "_count", "range", "count"]], "prefix": [["prefix", "_count", "str", "_count", "_count", "range", "count"]]}, "params_p": {"args": [], "count": [["int", 0.7388688181139416], ["Union[str, int]", 0.08616003513374818]], "kwargs": [], "prefix": [["int", 0.7388688181139416], ["Union[str, int]", 0.08616003513374818]]}, "q_name": "generate_dict", "ret_exprs": ["return {f\"{prefix}_{_count}\": str(_count) for _count in range(count)}"], "ret_type": "builtins.dict", "ret_type_p": [["str", 0.6794389091078091], ["Optional[\"LocalizedString\"]", 0.12567074031644107], ["int", 0.09860642783511032], ["Optional[str]", 0.09628392274063961]], "variables": {}, "variables_p": {}}], "imports": ["__future__", "annotations", "datetime", "re", "copy", "deepcopy", "typing", "Pattern", "Type", "Union", "airflow", "providers", "amazon", "aws", "hooks", "eks", "EksHook", "utils", "eks_test_constants", "STATUS", "ClusterAttributes", "ClusterInputs", "FargateProfileAttributes", "FargateProfileInputs", "NodegroupAttributes", "NodegroupInputs", "ResponseAttributes"], "mod_var_ln": {"InputTypes": [[38, 0], [38, 10]]}, "mod_var_occur": {"InputTypes": []}, "no_types_annot": {"D": 35, "I": 0, "U": 6}, "session_id": "TP5pERXkm-huozK2r8a3gkqYAbBB0vbwbY-FO0PTK_8", "set": null, "tc": [false, null], "type_annot_cove": 0.85, "typed_seq": "", "untyped_seq": "", "variables": {"InputTypes": ""}, "variables_p": {"InputTypes": [["str", 0.19999999999999998], ["int", 0.19999999999999998], ["Tuple[Literal, Literal, Literal, Literal, Literal, Literal, Literal]", 0.09999999999999999], ["Dict[str, str]", 0.09999999999999999], ["Tuple[Type[int], Type[float]]", 0.09999999999999999]]}}}