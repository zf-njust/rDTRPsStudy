{"error": null, "response": {"classes": [{"cls_lc": [[30, 0], [43, 36]], "cls_var_ln": {"end": [[38, 4], [38, 7]], "start": [[37, 4], [37, 9]]}, "cls_var_occur": {"end": [], "start": []}, "funcs": [{"docstring": {"func": "Represent an \"interval\" containing only an exact time.", "long_descr": null, "ret": null}, "fn_lc": [[41, 4], [43, 36]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "exact", "params": {"at": "pendulum.DateTime", "cls": ""}, "params_descr": {"at": "", "cls": ""}, "params_occur": {"at": [["cls", "start", "at", "end", "at"]], "cls": [["cls", "start", "at", "end", "at"]]}, "params_p": {"args": [], "at": [["int", 0.18415639340305578], ["bool", 0.08773141050005037]], "cls": [["int", 0.18415639340305578], ["bool", 0.08773141050005037]], "kwargs": [], "self": []}, "q_name": "DataInterval.exact", "ret_exprs": ["return cls(start=at, end=at)"], "ret_type": "DataInterval", "ret_type_p": [["float", 0.18413727541507932], ["Tuple[Tuple[int, Any]]", 0.10439326089637602], ["bool", 0.1006195406157243], ["types.signals.SignalHandlerT", 0.1006195406157243]], "variables": {}, "variables_p": {}}], "name": "DataInterval", "q_name": "DataInterval", "variables": {"end": "pendulum.DateTime", "start": "pendulum.DateTime"}, "variables_p": {"end": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "start": [["bool", 0.20000000000000004], ["str", 0.20000000000000004], ["int", 0.20000000000000004], ["List[Tuple[Any, Any]]", 0.10000000000000002]]}}, {"cls_lc": [[46, 0], [64, 26]], "cls_var_ln": {"catchup": [[64, 4], [64, 11]], "earliest": [[62, 4], [62, 12]], "latest": [[63, 4], [63, 10]]}, "cls_var_occur": {"catchup": [], "earliest": [], "latest": []}, "funcs": [], "name": "TimeRestriction", "q_name": "TimeRestriction", "variables": {"catchup": "builtins.bool", "earliest": "DateTime | None", "latest": "DateTime | None"}, "variables_p": {"catchup": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "earliest": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "latest": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"cls_lc": [[67, 0], [105, 39]], "cls_var_ln": {"data_interval": [[80, 4], [80, 17]], "run_after": [[74, 4], [74, 13]]}, "cls_var_occur": {"data_interval": [], "run_after": []}, "funcs": [{"docstring": {"func": "Represent a run on an exact time.", "long_descr": null, "ret": null}, "fn_lc": [[84, 4], [86, 70]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "exact", "params": {"at": "pendulum.DateTime", "cls": ""}, "params_descr": {"at": "", "cls": ""}, "params_occur": {"at": [["cls", "run_after", "at", "data_interval", "DataInterval", "exact", "at"]], "cls": [["cls", "run_after", "at", "data_interval", "DataInterval", "exact", "at"]]}, "params_p": {"args": [], "at": [["bytes", 0.20915744081871662], ["str", 0.19345461027239774], ["Callable[[bytes], bytes]", 0.10457872040935831], ["dict", 0.10077830356022299], ["int", 0.09677929751886903]], "cls": [["bytes", 0.20915744081871662], ["str", 0.19345461027239774], ["Callable[[bytes], bytes]", 0.10457872040935831], ["dict", 0.10077830356022299], ["int", 0.09677929751886903]], "kwargs": [], "self": []}, "q_name": "DagRunInfo.exact", "ret_exprs": ["return cls(run_after=at, data_interval=DataInterval.exact(at))"], "ret_type": "DagRunInfo", "ret_type_p": [["Dict[str, str]", 0.1849615022551763], ["tuple", 0.11345114733679301], ["Optional[str]", 0.10498685887634987], ["float", 0.10091159894567617], ["bool", 0.09258478626196305]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Represent a run on a continuous schedule.", "long_descr": "In such a schedule, each data interval starts right after the previous\none ends, and each run is scheduled right after the interval ends. This\napplies to all schedules prior to AIP-39 except ``@once`` and ``None``.", "ret": null}, "fn_lc": [[89, 4], [96, 73]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "interval", "params": {"cls": "", "end": "pendulum.DateTime", "start": "pendulum.DateTime"}, "params_descr": {"cls": "", "end": "", "start": ""}, "params_occur": {"cls": [["cls", "run_after", "end", "data_interval", "DataInterval", "start", "end"]], "end": [["cls", "run_after", "end", "data_interval", "DataInterval", "start", "end"]], "start": [["cls", "run_after", "end", "data_interval", "DataInterval", "start", "end"]]}, "params_p": {"args": [], "cls": [["int", 0.5170866651659545], ["str", 0.19816826317097297], ["bool", 0.18671692903318404]], "end": [["int", 0.5170866651659545], ["str", 0.19816826317097297], ["bool", 0.18671692903318404]], "kwargs": [], "self": [], "start": [["int", 0.5170866651659545], ["str", 0.19816826317097297], ["bool", 0.18671692903318404]]}, "q_name": "DagRunInfo.interval", "ret_exprs": ["return cls(run_after=end, data_interval=DataInterval(start, end))"], "ret_type": "DagRunInfo", "ret_type_p": [["Dict[str, str]", 0.1849615022551763], ["tuple", 0.11345114733679301], ["Optional[str]", 0.10498685887634987], ["float", 0.10091159894567617], ["bool", 0.09258478626196305]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Infer the logical date to represent a DagRun.", "long_descr": "This replaces ``execution_date`` in Airflow 2.1 and prior. The idea is\nessentially the same, just a different name.", "ret": null}, "fn_lc": [[99, 4], [105, 39]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "logical_date", "params": {"self": "DagRunInfo"}, "params_descr": {"self": ""}, "params_occur": {"self": [["self", "data_interval", "start"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "DagRunInfo.logical_date", "ret_exprs": ["return self.data_interval.start"], "ret_type": "pendulum.DateTime", "ret_type_p": [["bool", 0.20022949910427057], ["dict", 0.1386425787849023], ["str", 0.09628719269343461], ["int", 0.09430814455946854], ["float", 0.09132095848608392]], "variables": {}, "variables_p": {}}], "name": "DagRunInfo", "q_name": "DagRunInfo", "variables": {"data_interval": "DataInterval", "run_after": "pendulum.DateTime"}, "variables_p": {"data_interval": [["str", 0.4000000000000001], ["bool", 0.10000000000000002], ["list", 0.10000000000000002], ["dict", 0.10000000000000002]], "run_after": [["int", 0.7], ["bool", 0.1], ["str", 0.1]]}}, {"cls_lc": [[109, 0], [239, 53]], "cls_var_ln": {"_can_be_scheduled": [[126, 4], [126, 21]], "active_runs_limit": [[152, 4], [152, 21]], "description": [[112, 4], [112, 15]], "periodic": [[119, 4], [119, 12]], "run_ordering": [[146, 4], [146, 16]]}, "cls_var_occur": {"_can_be_scheduled": [], "active_runs_limit": [], "description": [], "periodic": [], "run_ordering": []}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[129, 4], [137, 37]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "can_be_scheduled", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["hasattr", "self"], ["self", "can_run"], ["self", "_can_be_scheduled"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "Timetable.can_be_scheduled", "ret_exprs": ["return self.can_run", "return self._can_be_scheduled"], "ret_type": "", "ret_type_p": [["bool", 0.1151893046369257], ["Tuple[str]", 0.10405222096091292], ["int", 0.09262814513247873]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Deserialize a timetable from data.", "long_descr": "This is called when a serialized DAG is deserialized. ``data`` will be\nwhatever was returned by ``serialize`` during DAG serialization. The\ndefault implementation constructs the timetable without any arguments.", "ret": null}, "fn_lc": [[161, 4], [168, 20]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "deserialize", "params": {"cls": "", "data": "builtins.dict[builtins.str, typing.Any]"}, "params_descr": {"cls": "", "data": ""}, "params_occur": {"cls": [], "data": []}, "params_p": {"args": [], "cls": [], "data": [], "kwargs": [], "self": []}, "q_name": "Timetable.deserialize", "ret_exprs": ["return cls()"], "ret_type": "Timetable", "ret_type_p": [["Dict[str, Any]", 0.1863234525232297], ["str", 0.10051896894600423], ["Callable[[str], T]", 0.09616632192770294]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Serialize the timetable for JSON encoding.", "long_descr": "This is called during DAG serialization to store timetable information\nin the database. This should return a JSON-serializable dict that will\nbe fed into ``deserialize`` when the DAG is deserialized. The default\nimplementation returns an empty dict.", "ret": null}, "fn_lc": [[170, 4], [178, 17]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "serialize", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": []}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "Timetable.serialize", "ret_exprs": ["return {}"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [["int", 0.30000000000000004], ["Callable", 0.2], ["str", 0.1]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Validate the timetable is correctly specified.", "long_descr": "Override this method to provide run-time validation raised when a DAG\nis put into a dagbag. The default implementation does nothing.", "ret": null}, "fn_lc": [[180, 4], [188, 14]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "validate", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": []}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "Timetable.validate", "ret_exprs": ["return"], "ret_type": "None", "ret_type_p": [["Union[tuple, list]", 0.12326783261663934], ["List[int]", 0.09124591253820835], ["Dict[str, Any]", 0.08769568774684897], ["str", 0.08682447752895113]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "A short summary for the timetable.", "long_descr": "This is used to display the timetable in the web UI. A cron expression\ntimetable, for example, can use this to display the expression. The\ndefault implementation returns the timetable's type name.", "ret": null}, "fn_lc": [[191, 4], [198, 34]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "summary", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["type", "self", "__name__"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "Timetable.summary", "ret_exprs": ["return type(self).__name__"], "ret_type": "builtins.str", "ret_type_p": [["str", 0.8975591465434062]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "When a DAG run is manually triggered, infer a data interval for it.", "long_descr": "This is used for e.g. manually-triggered runs, where ``run_after`` would\nbe when the user triggers the run. The default implementation raises\n``NotImplementedError``.", "ret": null}, "fn_lc": [[200, 4], [207, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "infer_manual_data_interval", "params": {"run_after": "pendulum.DateTime", "self": ""}, "params_descr": {"run_after": "", "self": ""}, "params_occur": {"run_after": [], "self": []}, "params_p": {"args": [], "kwargs": [], "run_after": [["str", 0.19072308535076882], ["dict", 0.09327852700734977]], "self": []}, "q_name": "Timetable.infer_manual_data_interval", "ret_exprs": [], "ret_type": "DataInterval", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Provide information to schedule the next DagRun.", "long_descr": "The default implementation raises ``NotImplementedError``.", "ret": "Information on when the next DagRun can be scheduled. None\nmeans a DagRun will not happen. This does not mean no more runs\nwill be scheduled even again for this DAG; the timetable can return\na DagRunInfo object when asked at another time."}, "fn_lc": [[209, 4], [229, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "next_dagrun_info", "params": {"last_automated_data_interval": "DataInterval | None", "restriction": "TimeRestriction", "self": ""}, "params_descr": {"last_automated_data_interval": "The data interval of the associated\nDAG's last scheduled or backfilled run (manual runs not considered).", "restriction": "Restriction to apply when scheduling the DAG run.\nSee documentation of :class:`TimeRestriction` for details.", "self": ""}, "params_occur": {"last_automated_data_interval": [], "restriction": [], "self": []}, "params_p": {"args": [], "kwargs": [], "last_automated_data_interval": [["str", 0.35153164335350645], ["Dict[str, Any]", 0.34122851578256963], ["Sequence[str]", 0.11717721445116881], ["List[str]", 0.09523779150718316]], "restriction": [["str", 0.35153164335350645], ["Dict[str, Any]", 0.34122851578256963], ["Sequence[str]", 0.11717721445116881], ["List[str]", 0.09523779150718316]], "self": []}, "q_name": "Timetable.next_dagrun_info", "ret_exprs": [], "ret_type": "DagRunInfo | None", "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[231, 4], [239, 53]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "generate_run_id", "params": {"data_interval": "DataInterval | None", "extra": "", "logical_date": "pendulum.DateTime", "run_type": "airflow.utils.types.DagRunType", "self": ""}, "params_descr": {"data_interval": "", "extra": "", "logical_date": "", "run_type": "", "self": ""}, "params_occur": {"data_interval": [], "extra": [], "logical_date": [["run_type", "generate_run_id", "logical_date"]], "run_type": [["run_type", "generate_run_id", "logical_date"]], "self": []}, "params_p": {"args": [], "data_interval": [["bytes", 0.2408847720544409], ["int", 0.2408847720544409], ["Type[object]", 0.10586449880632348], ["MutableSequence[str]", 0.0891916934130785], ["Literal", 0.08297171407820376], ["Iterable[str]", 0.07926410751007801], ["dict", 0.07926410751007801]], "extra": [["bytes", 0.2408847720544409], ["int", 0.2408847720544409], ["Type[object]", 0.10586449880632348], ["MutableSequence[str]", 0.0891916934130785], ["Literal", 0.08297171407820376], ["Iterable[str]", 0.07926410751007801], ["dict", 0.07926410751007801]], "kwargs": [], "logical_date": [["str", 0.3226970361434054], ["int", 0.09389855281939612], ["raiden.utils.Address", 0.09279868328509225]], "run_type": [["str", 0.3226970361434054], ["int", 0.09389855281939612], ["raiden.utils.Address", 0.09279868328509225]], "self": []}, "q_name": "Timetable.generate_run_id", "ret_exprs": ["return run_type.generate_run_id(logical_date)"], "ret_type": "builtins.str", "ret_type_p": [["bool", 0.38347796451291116], ["Dict[str, Any]", 0.1687680486075974], ["str", 0.16170506448920918], ["cmk.utils.type_defs.UserId", 0.08732724820258152]], "variables": {}, "variables_p": {}}], "name": "Timetable", "q_name": "Timetable", "variables": {"_can_be_scheduled": "builtins.bool", "active_runs_limit": "int | None", "description": "builtins.str", "periodic": "builtins.bool", "run_ordering": "typing.Sequence[builtins.str]"}, "variables_p": {"_can_be_scheduled": [["str", 0.39999999999999997], ["bool", 0.3], ["cmk.gui.plugins.openapi.livestatus_helpers.types.Column", 0.19999999999999998], ["dict", 0.09999999999999999]], "active_runs_limit": [["str", 0.4], ["bool", 0.2], ["int", 0.1], ["set", 0.1]], "description": [["str", 0.6999999999999998], ["Optional[\"LocalizedString\"]", 0.09999999999999998], ["\"LocalizedString\"", 0.09999999999999998], ["Optional[str]", 0.09999999999999998]], "periodic": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "run_ordering": [["int", 0.7], ["bool", 0.1], ["str", 0.1]]}}], "funcs": [], "imports": ["__future__", "annotations", "typing", "TYPE_CHECKING", "Any", "NamedTuple", "Sequence", "warnings", "warn", "pendulum", "DateTime", "airflow", "typing_compat", "Protocol", "runtime_checkable", "airflow", "utils", "types", "DagRunType"], "mod_var_ln": {}, "mod_var_occur": {}, "no_types_annot": {"D": 34, "I": 0, "U": 6}, "session_id": "3KUIGvgNZQ2iVtoZBVmgqy9hlitEISN01smYZjqiL-U", "set": null, "tc": [false, null], "type_annot_cove": 0.85, "typed_seq": "", "untyped_seq": "", "variables": {}, "variables_p": {}}}