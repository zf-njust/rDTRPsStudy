{"error": null, "response": {"classes": [{"cls_lc": [[33, 0], [109, 56]], "cls_var_ln": {}, "cls_var_occur": {}, "funcs": [{"docstring": {"func": "Bound the earliest time a run can be scheduled.", "long_descr": "This is called when ``catchup=False``. See docstring of subclasses for\nexact skipping behaviour of a schedule.", "ret": null}, "fn_lc": [[41, 4], [47, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_skip_to_latest", "params": {"earliest": "DateTime | None", "self": ""}, "params_descr": {"earliest": "", "self": ""}, "params_occur": {"earliest": [], "self": []}, "params_p": {"args": [], "earliest": [["int", 0.2], ["float", 0.1], ["str", 0.1], ["List[int]", 0.1], ["List[List[str]]", 0.1]], "kwargs": [], "self": []}, "q_name": "_DataIntervalTimetable._skip_to_latest", "ret_exprs": [], "ret_type": "pendulum.DateTime", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Align given time to the next scheduled time.", "long_descr": "For fixed schedules (e.g. every midnight); this finds the next time that\naligns to the declared time, if the given time does not align. If the\nschedule is not fixed (e.g. every hour), the given time is returned.", "ret": null}, "fn_lc": [[49, 4], [56, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_align_to_next", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["int", 0.2], ["float", 0.1], ["str", 0.1], ["List[int]", 0.1], ["List[List[str]]", 0.1]], "kwargs": [], "self": []}, "q_name": "_DataIntervalTimetable._align_to_next", "ret_exprs": [], "ret_type": "pendulum.DateTime", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Align given time to the previous scheduled time.", "long_descr": "For fixed schedules (e.g. every midnight); this finds the prev time that\naligns to the declared time, if the given time does not align. If the\nschedule is not fixed (e.g. every hour), the given time is returned.\n\nIt is not enough to use ``_get_prev(_align_to_next())``, since when a\nDAG's schedule changes, this alternative would make the first scheduling\nafter the schedule change remain the same.", "ret": null}, "fn_lc": [[58, 4], [69, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_align_to_prev", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["int", 0.2], ["float", 0.1], ["str", 0.1], ["List[int]", 0.1], ["List[List[str]]", 0.1]], "kwargs": [], "self": []}, "q_name": "_DataIntervalTimetable._align_to_prev", "ret_exprs": [], "ret_type": "pendulum.DateTime", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Get the first schedule after the current time.", "long_descr": null, "ret": null}, "fn_lc": [[71, 4], [73, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_get_next", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["bool", 0.39999999999999997], ["str", 0.39999999999999997], ["T", 0.09999999999999999], ["dict", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "_DataIntervalTimetable._get_next", "ret_exprs": [], "ret_type": "pendulum.DateTime", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Get the last schedule before the current time.", "long_descr": null, "ret": null}, "fn_lc": [[75, 4], [77, 35]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_get_prev", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["bool", 0.39999999999999997], ["str", 0.39999999999999997], ["T", 0.09999999999999999], ["dict", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "_DataIntervalTimetable._get_prev", "ret_exprs": [], "ret_type": "pendulum.DateTime", "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[79, 4], [109, 56]], "fn_var_ln": {"align_last_data_interval_end": [[98, 12], [98, 40]], "earliest": [[89, 12], [89, 20]], "end": [[108, 8], [108, 11]], "start": [[105, 16], [105, 21]]}, "fn_var_occur": {"align_last_data_interval_end": [["align_last_data_interval_end", "self", "_align_to_prev", "last_automated_data_interval", "end"], ["start", "max", "align_last_data_interval_end", "earliest"], ["start", "align_last_data_interval_end"]], "earliest": [["earliest", "restriction", "earliest"], ["earliest", "self", "_skip_to_latest", "earliest"], ["earliest", "None"], ["earliest", "self", "_align_to_next", "earliest"], ["earliest", "None"], ["start", "earliest"], ["earliest", "None"], ["start", "max", "align_last_data_interval_end", "earliest"]], "end": [["align_last_data_interval_end", "self", "_align_to_prev", "last_automated_data_interval", "end"], ["end", "self", "_get_next", "start"], ["DagRunInfo", "interval", "start", "start", "end", "end"]], "start": [["start", "earliest"], ["start", "max", "align_last_data_interval_end", "earliest"], ["start", "align_last_data_interval_end"], ["restriction", "latest", "None", "start", "restriction", "latest"], ["end", "self", "_get_next", "start"], ["DagRunInfo", "interval", "start", "start", "end", "end"]]}, "name": "next_dagrun_info", "params": {"last_automated_data_interval": "DataInterval | None", "restriction": "airflow.timetables.base.TimeRestriction", "self": ""}, "params_descr": {"last_automated_data_interval": "", "restriction": "", "self": ""}, "params_occur": {"last_automated_data_interval": [["last_automated_data_interval", "None"], ["align_last_data_interval_end", "self", "_align_to_prev", "last_automated_data_interval", "end"]], "restriction": [["earliest", "restriction", "earliest"], ["restriction", "catchup"], ["restriction", "latest", "None", "start", "restriction", "latest"]], "self": [["earliest", "self", "_skip_to_latest", "earliest"], ["earliest", "self", "_align_to_next", "earliest"], ["align_last_data_interval_end", "self", "_align_to_prev", "last_automated_data_interval", "end"], ["end", "self", "_get_next", "start"]]}, "params_p": {"args": [], "kwargs": [], "last_automated_data_interval": [["bool", 0.4510146328649381]], "restriction": [["Callable[[], None]", 0.16188450097490312], ["dict", 0.11897723397905391], ["bytes", 0.11404351797167196], ["int", 0.09440871686334261], ["Sequence[str]", 0.09109178164660567], ["IO", 0.07848999181728471]], "self": []}, "q_name": "_DataIntervalTimetable.next_dagrun_info", "ret_exprs": ["return None", "return None", "return DagRunInfo.interval(start=start, end=end)"], "ret_type": "DagRunInfo | None", "ret_type_p": [["Optional[int]", 0.19297879291625564], ["str", 0.10928265723467079], ["List[str]", 0.10164497363980325], ["Callable", 0.09398648072319124]], "variables": {"align_last_data_interval_end": "", "earliest": "", "end": "", "start": ""}, "variables_p": {"align_last_data_interval_end": [["List[List[Any]]", 0.31324606043485026], ["str", 0.14631848686404814], ["Type[List[Any]]", 0.09410690717409725], ["Pattern[str]", 0.08458477602003421], ["List[int]", 0.08424950488065658], ["Dict[int, int]", 0.077131131191149], ["int", 0.07524184570018386]], "earliest": [["list", 0.10794790948261866]], "end": [["dict", 0.0937758172068288], ["Dict[str, str]", 0.09225651009646811], ["Dict[str, Union[Any, Any]]", 0.08956146323572389]], "start": [["int", 0.30279553423262984], ["Tuple[str, str, str, str, str, str, str]", 0.1052797585556622], ["slice", 0.09074495900286067], ["List[int]", 0.0867033236885671]]}}], "name": "_DataIntervalTimetable", "q_name": "_DataIntervalTimetable", "variables": {}, "variables_p": {}}, {"cls_lc": [[112, 0], [164, 63]], "cls_var_ln": {}, "cls_var_occur": {}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[126, 4], [129, 73]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "deserialize", "params": {"cls": "", "data": "builtins.dict[builtins.str, typing.Any]"}, "params_descr": {"cls": "", "data": ""}, "params_occur": {"cls": [["cls", "data", "decode_timezone", "data"]], "data": [["cls", "data", "decode_timezone", "data"]]}, "params_p": {"args": [], "cls": [["dict", 0.10429302565897262], ["str", 0.09651839308463774]], "data": [["dict", 0.10429302565897262], ["str", 0.09651839308463774]], "kwargs": [], "self": []}, "q_name": "CronDataIntervalTimetable.deserialize", "ret_exprs": ["return cls(data[\"expression\"], decode_timezone(data[\"timezone\"]))"], "ret_type": "airflow.timetables.base.Timetable", "ret_type_p": [["Mapping", 0.11457083966928457], ["Tuple[str, str]", 0.11442761676889261], ["Dict[str, int]", 0.10271497561563304], ["list", 0.09917678996508632], ["int", 0.09917678996508632], ["Dict[str, str]", 0.09627446101856546], ["set", 0.09522683446585228], ["bool", 0.0936914864603304], ["str", 0.09104871961093859]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[131, 4], [134, 92]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "serialize", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["self", "_expression", "encode_timezone", "self", "_timezone"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "CronDataIntervalTimetable.serialize", "ret_exprs": ["return {\"expression\": self._expression, \"timezone\": encode_timezone(self._timezone)}"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Bound the earliest time a run can be scheduled.", "long_descr": "The logic is that we move start_date up until one period before, so the\ncurrent time is AFTER the period end, and the job can be created...\n\nThis is slightly different from the delta version at terminal values.\nIf the next schedule should start *right now*, we want the data interval\nthat start now, not the one that ends now.", "ret": null}, "fn_lc": [[136, 4], [157, 60]], "fn_var_ln": {"current_time": [[146, 8], [146, 20]], "last_start": [[147, 8], [147, 18]], "new_start": [[152, 12], [152, 21]], "next_start": [[148, 8], [148, 18]]}, "fn_var_occur": {"current_time": [["current_time", "DateTime", "utcnow"], ["last_start", "self", "_get_prev", "current_time"], ["next_start", "current_time"], ["next_start", "current_time"]], "last_start": [["last_start", "self", "_get_prev", "current_time"], ["next_start", "self", "_get_next", "last_start"], ["new_start", "last_start"], ["new_start", "self", "_get_prev", "last_start"]], "new_start": [["new_start", "last_start"], ["new_start", "self", "_get_prev", "last_start"], ["max", "new_start", "self", "_align_to_next", "earliest"]], "next_start": [["next_start", "self", "_get_next", "last_start"], ["next_start", "current_time"], ["next_start", "current_time"]]}, "name": "_skip_to_latest", "params": {"earliest": "DateTime | None", "self": ""}, "params_descr": {"earliest": "", "self": ""}, "params_occur": {"earliest": [["earliest", "None"], ["max", "new_start", "self", "_align_to_next", "earliest"]], "self": [["last_start", "self", "_get_prev", "current_time"], ["next_start", "self", "_get_next", "last_start"], ["new_start", "self", "_get_prev", "last_start"], ["max", "new_start", "self", "_align_to_next", "earliest"]]}, "params_p": {"args": [], "earliest": [["int", 0.1895345076900688], ["Optional[int]", 0.09837188457696264], ["str", 0.09296934580857014], ["Optional[\"Outcome\"]", 0.08541540684094244]], "kwargs": [], "self": []}, "q_name": "CronDataIntervalTimetable._skip_to_latest", "ret_exprs": ["return new_start", "return max(new_start, self._align_to_next(earliest))"], "ret_type": "pendulum.DateTime", "ret_type_p": [["bool", 0.18439019614063973], ["Generator", 0.10661523388873294], ["dict", 0.09697393928491614]], "variables": {"current_time": "", "last_start": "", "new_start": "", "next_start": ""}, "variables_p": {"current_time": [["pringles.utils.vtime.VirtualTime", 0.3221746752137698], ["int", 0.21801579230654494], ["float", 0.20872617760740608], ["datetime.datetime", 0.08983824219938803], ["Dict[str, int]", 0.08394231857226396]], "last_start": [["int", 1.0000000000000002]], "new_start": [["int", 0.9070232612728669], ["List[int]", 0.092976738727133]], "next_start": [["int", 0.4871519327239574], ["str", 0.19997758400245008], ["Type[DefaultDict[int, Any]]", 0.11583095948670752], ["List[int]", 0.10507321791045583]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[159, 4], [164, 63]], "fn_var_ln": {"end": [[163, 8], [163, 11]]}, "fn_var_occur": {"end": [["end", "self", "_align_to_prev", "run_after"], ["DataInterval", "start", "self", "_get_prev", "end", "end", "end"]]}, "name": "infer_manual_data_interval", "params": {"run_after": "pendulum.DateTime", "self": ""}, "params_descr": {"run_after": "", "self": ""}, "params_occur": {"run_after": [["end", "self", "_align_to_prev", "run_after"]], "self": [["end", "self", "_align_to_prev", "run_after"], ["DataInterval", "start", "self", "_get_prev", "end", "end", "end"]]}, "params_p": {"args": [], "kwargs": [], "run_after": [["str", 0.10164255824285896], ["\"LineageBuilder\"", 0.09908222557974984], ["\"Counter\"", 0.09511395940125258], ["Dict[str, Any]", 0.08938118009340872], ["Tuple[List, List, List]", 0.08749928508966902]], "self": []}, "q_name": "CronDataIntervalTimetable.infer_manual_data_interval", "ret_exprs": ["return DataInterval(start=self._get_prev(end), end=end)"], "ret_type": "airflow.timetables.base.DataInterval", "ret_type_p": [["bool", 0.29309935318788627], ["Optional[str]", 0.1897679877333599], ["str", 0.1036734455002902], ["list", 0.09801848871998628], ["dict", 0.09350564497138193]], "variables": {"end": ""}, "variables_p": {"end": [["property", 0.12805682193292978], ["List[List[Any]]", 0.0971103938395109], ["qutebrowser.utils.log.ColoredFormatter", 0.09669350403617424], ["str", 0.0954183613979156], ["Optional[str]", 0.09276328355053208], ["slice", 0.08901764531597856]]}}], "name": "CronDataIntervalTimetable", "q_name": "CronDataIntervalTimetable", "variables": {}, "variables_p": {}}, {"cls_lc": [[167, 0], [241, 75]], "cls_var_ln": {}, "cls_var_occur": {}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[175, 4], [176, 27]], "fn_var_ln": {"_delta": [[176, 8], [176, 19]]}, "fn_var_occur": {"_delta": [["self", "_delta", "delta"]]}, "name": "__init__", "params": {"delta": "Delta", "self": ""}, "params_descr": {"delta": "", "self": ""}, "params_occur": {"delta": [["self", "_delta", "delta"]], "self": [["self", "_delta", "delta"]]}, "params_p": {"args": [], "delta": [["int", 0.3], ["bool", 0.09999999999999999], ["float", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable.__init__", "ret_exprs": [], "ret_type": "None", "variables": {"_delta": ""}, "variables_p": {"_delta": [["str", 0.30000000000000004], ["Dict[str, Any]", 0.1], ["dict", 0.1], ["int", 0.1]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[179, 4], [185, 53]], "fn_var_ln": {"delta": [[182, 8], [182, 13]]}, "fn_var_occur": {"delta": [["delta", "data"], ["isinstance", "delta", "dict"], ["cls", "decode_relativedelta", "delta"], ["cls", "datetime", "timedelta", "seconds", "delta"]]}, "name": "deserialize", "params": {"cls": "", "data": "builtins.dict[builtins.str, typing.Any]"}, "params_descr": {"cls": "", "data": ""}, "params_occur": {"cls": [["cls", "decode_relativedelta", "delta"], ["cls", "datetime", "timedelta", "seconds", "delta"]], "data": [["delta", "data"]]}, "params_p": {"args": [], "cls": [["int", 0.2907759292341282], ["dict", 0.15268068483036876], ["datetime.datetime", 0.1484831724435451], ["datetime.date", 0.09686817100833489], ["str", 0.0852192319124075]], "data": [["Dict[str, Any]", 0.9999999996563212], ["str", 5.1073464026042134e-11], ["Type", 2.2514165416499535e-11]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable.deserialize", "ret_exprs": ["return cls(decode_relativedelta(delta))", "return cls(datetime.timedelta(seconds=delta))"], "ret_type": "airflow.timetables.base.Timetable", "ret_type_p": [["str", 0.20653059969584317], ["int", 0.20217292073590198], ["bool", 0.19974647583477423], ["Optional[int]", 0.10810258184568243], ["Optional[bool]", 0.09987323791738711], ["Iterable", 0.09178709198520553], ["List[str]", 0.09178709198520553]], "variables": {"delta": ""}, "variables_p": {"delta": [["str", 0.4838241556529693], ["datetime.timedelta", 0.14012796642943634], ["Dict[str, Union[int, str]]", 0.09797855837451012], ["datetime.datetime.datetime", 0.09044019047392245], ["float", 0.0903159683384895]]}}, {"docstring": {"func": "The offset should match.", "long_descr": "This is only for testing purposes and should not be relied on otherwise.", "ret": null}, "fn_lc": [[187, 4], [194, 42]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "__eq__", "params": {"other": "typing.Any", "self": ""}, "params_descr": {"other": "", "self": ""}, "params_occur": {"other": [["isinstance", "other", "DeltaDataIntervalTimetable"], ["self", "_delta", "other", "_delta"]], "self": [["self", "_delta", "other", "_delta"]]}, "params_p": {"args": [], "kwargs": [], "other": [["bool", 0.2119602997021819], ["str", 0.2039743542777322], ["datetime.date", 0.19647700395109519], ["int", 0.0894296139363663]], "self": []}, "q_name": "DeltaDataIntervalTimetable.__eq__", "ret_exprs": ["return NotImplemented", "return self._delta == other._delta"], "ret_type": "builtins.bool", "ret_type_p": [["str", 0.21315503251362958], ["List[int]", 0.10532233121612757], ["int", 0.10532233121612757], ["utils.Node", 0.09888679874772877], ["trezor.utils.Writer", 0.08010329473690227]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[197, 4], [198, 31]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "summary", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["str", "self", "_delta"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable.summary", "ret_exprs": ["return str(self._delta)"], "ret_type": "builtins.str", "ret_type_p": [["str", 0.8458824507089776]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[200, 4], [208, 31]], "fn_var_ln": {"delta": [[207, 12], [207, 17]]}, "fn_var_occur": {"delta": [["delta", "typing", "Any"], ["delta", "self", "_delta", "total_seconds"], ["delta", "encode_relativedelta", "self", "_delta"]]}, "name": "serialize", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["isinstance", "self", "_delta", "datetime", "timedelta"], ["delta", "self", "_delta", "total_seconds"], ["delta", "encode_relativedelta", "self", "_delta"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable.serialize", "ret_exprs": ["return {\"delta\": delta}"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [["int", 0.30000000000000004], ["Callable", 0.2], ["str", 0.1]], "variables": {"delta": ""}, "variables_p": {"delta": [["list", 0.782307049973543], ["float", 0.13122853362665862], ["Dict[str, str]", 0.08646441639979842]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[210, 4], [213, 101]], "fn_var_ln": {"now": [[211, 8], [211, 11]]}, "fn_var_occur": {"now": [["now", "datetime", "datetime", "now"], ["now", "self", "_delta", "now"]]}, "name": "validate", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["now", "self", "_delta", "now"], ["AirflowTimetableInvalid", "self", "_delta"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable.validate", "ret_exprs": [], "ret_type": "None", "variables": {"now": ""}, "variables_p": {"now": [["datetime.datetime", 0.8134961877499767], ["datetime.date", 0.1865038122500235]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[215, 4], [216, 52]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_get_next", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [["convert_to_utc", "current", "self", "_delta"]], "self": [["convert_to_utc", "current", "self", "_delta"]]}, "params_p": {"args": [], "current": [["str", 0.19999999999999998], ["bool", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable._get_next", "ret_exprs": ["return convert_to_utc(current + self._delta)"], "ret_type": "pendulum.DateTime", "ret_type_p": [["cmk.utils.type_defs.UserId", 0.108271439119523], ["bytes", 0.097538316897585], ["int", 0.09697564269041802], ["float", 0.09617144913723412]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[218, 4], [219, 52]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_get_prev", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [["convert_to_utc", "current", "self", "_delta"]], "self": [["convert_to_utc", "current", "self", "_delta"]]}, "params_p": {"args": [], "current": [["str", 0.19999999999999998], ["bool", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable._get_prev", "ret_exprs": ["return convert_to_utc(current - self._delta)"], "ret_type": "pendulum.DateTime", "ret_type_p": [["cmk.utils.type_defs.UserId", 0.108271439119523], ["bytes", 0.097538316897585], ["int", 0.09697564269041802], ["float", 0.09617144913723412]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[221, 4], [222, 22]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_align_to_next", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["int", 0.2], ["float", 0.1], ["str", 0.1], ["List[int]", 0.1], ["List[List[str]]", 0.1]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable._align_to_next", "ret_exprs": ["return current"], "ret_type": "pendulum.DateTime", "ret_type_p": [["bytes", 0.2], ["int", 0.1], ["IO", 0.1], ["List[str]", 0.1], ["cmk.utils.type_defs.HostAddress", 0.1], ["str", 0.1]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[224, 4], [225, 22]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "_align_to_prev", "params": {"current": "pendulum.DateTime", "self": ""}, "params_descr": {"current": "", "self": ""}, "params_occur": {"current": [], "self": []}, "params_p": {"args": [], "current": [["int", 0.2], ["float", 0.1], ["str", 0.1], ["List[int]", 0.1], ["List[List[str]]", 0.1]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable._align_to_prev", "ret_exprs": ["return current"], "ret_type": "pendulum.DateTime", "ret_type_p": [["bytes", 0.2], ["int", 0.1], ["IO", 0.1], ["List[str]", 0.1], ["cmk.utils.type_defs.HostAddress", 0.1], ["str", 0.1]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Bound the earliest time a run can be scheduled.", "long_descr": "The logic is that we move start_date up until one period before, so the\ncurrent time is AFTER the period end, and the job can be created...\n\nThis is slightly different from the cron version at terminal values.", "ret": null}, "fn_lc": [[227, 4], [238, 39]], "fn_var_ln": {"new_start": [[235, 8], [235, 17]]}, "fn_var_occur": {"new_start": [["new_start", "self", "_get_prev", "DateTime", "utcnow"], ["max", "new_start", "earliest"]]}, "name": "_skip_to_latest", "params": {"earliest": "DateTime | None", "self": ""}, "params_descr": {"earliest": "", "self": ""}, "params_occur": {"earliest": [["earliest", "None"], ["max", "new_start", "earliest"]], "self": [["new_start", "self", "_get_prev", "DateTime", "utcnow"]]}, "params_p": {"args": [], "earliest": [["int", 0.1895345076900688], ["Optional[int]", 0.09837188457696264], ["str", 0.09296934580857014], ["Optional[\"Outcome\"]", 0.08541540684094244]], "kwargs": [], "self": []}, "q_name": "DeltaDataIntervalTimetable._skip_to_latest", "ret_exprs": ["return new_start", "return max(new_start, earliest)"], "ret_type": "pendulum.DateTime", "ret_type_p": [["str", 0.20491193552511627], ["int", 0.10230205740590463], ["set", 0.09826871663187017], ["cmk.utils.type_defs.ServiceName", 0.08913242584786073], ["cmk.utils.type_defs.HostName", 0.08913242584786073]], "variables": {"new_start": ""}, "variables_p": {"new_start": [["int", 0.8029896294322081], ["Optional[int]", 0.10751601333250045], ["float", 0.0894943572352915]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[240, 4], [241, 75]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "infer_manual_data_interval", "params": {"run_after": "pendulum.DateTime", "self": ""}, "params_descr": {"run_after": "", "self": ""}, "params_occur": {"run_after": [["DataInterval", "start", "self", "_get_prev", "run_after", "end", "run_after"]], "self": [["DataInterval", "start", "self", "_get_prev", "run_after", "end", "run_after"]]}, "params_p": {"args": [], "kwargs": [], "run_after": [["dict", 0.2646760458830623], ["str", 0.08221692542238802], ["bool", 0.07355541849164059]], "self": []}, "q_name": "DeltaDataIntervalTimetable.infer_manual_data_interval", "ret_exprs": ["return DataInterval(start=self._get_prev(run_after), end=run_after)"], "ret_type": "airflow.timetables.base.DataInterval", "ret_type_p": [["bool", 0.1228504043356516], ["bytes", 0.11073912784374514], ["dict", 0.09286685503893705]], "variables": {}, "variables_p": {}}], "name": "DeltaDataIntervalTimetable", "q_name": "DeltaDataIntervalTimetable", "variables": {}, "variables_p": {}}], "funcs": [], "imports": ["__future__", "annotations", "datetime", "typing", "Any", "Union", "dateutil", "relativedelta", "relativedelta", "pendulum", "DateTime", "airflow", "exceptions", "AirflowTimetableInvalid", "airflow", "timetables", "_cron", "CronMixin", "airflow", "timetables", "base", "DagRunInfo", "DataInterval", "TimeRestriction", "Timetable", "airflow", "utils", "timezone", "convert_to_utc", "airflow", "serialization", "serialized_objects", "decode_timezone", "airflow", "serialization", "serialized_objects", "encode_timezone", "airflow", "serialization", "serialized_objects", "decode_relativedelta", "airflow", "serialization", "serialized_objects", "encode_relativedelta"], "mod_var_ln": {"Delta": [[30, 0], [30, 5]]}, "mod_var_occur": {"Delta": []}, "no_types_annot": {"D": 41, "I": 0, "U": 17}, "session_id": "9rzNSjee3BzscMvQZ9XNvRe64q6LmKFh852ddh7huUo", "set": null, "tc": [false, null], "type_annot_cove": 0.71, "typed_seq": "", "untyped_seq": "", "variables": {"Delta": ""}, "variables_p": {"Delta": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}}