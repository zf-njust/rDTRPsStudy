{"error": null, "response": {"classes": [{"cls_lc": [[51, 0], [108, 49]], "cls_var_ln": {"cache_ok": [[67, 4], [67, 12]], "impl": [[65, 4], [65, 8]]}, "cls_var_occur": {"cache_ok": [], "impl": []}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[69, 4], [85, 19]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "process_bind_param", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [], "value": [["value", "None"], ["isinstance", "value", "datetime", "datetime"], ["TypeError", "repr", "value"], ["value", "tzinfo", "None"], ["make_naive", "value", "timezone", "utc"], ["value", "astimezone", "utc"]]}, "params_p": {"args": [], "dialect": [["ics.types.ContextDict", 0.2], ["ics.types.ExtraParams", 0.2], ["ics.types.DatetimeLike", 0.1], ["int", 0.1], ["Tuple[str, int]", 0.1], ["complex", 0.1], ["list", 0.1]], "kwargs": [], "self": [], "value": [["datetime.datetime", 0.19231940472565934], ["int", 0.18093116750357213], ["str", 0.12189917049032777], ["Optional[pendulum.DateTime]", 0.11806816315119104], ["datetime.time.delta", 0.11358638958345948], ["Optional[datetime.datetime]", 0.09741868052497854], ["list", 0.09046558375178607], ["datetime.date", 0.08531144026902561]]}, "q_name": "UtcDateTime.process_bind_param", "ret_exprs": ["return make_naive(value, timezone=utc)", "return value.astimezone(utc)", "return None"], "ret_type": "", "ret_type_p": [["float", 0.32116407886949855], ["Optional[int]", 0.19944314363323998], ["str", 0.11010338497904922], ["Generator", 0.09055072649714047], ["int", 0.08804089473776733]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Processes DateTimes from the DB making sure it is always", "long_descr": "returning UTC. Not using timezone.convert_to_utc as that\nconverts to configured TIMEZONE while the DB might be\nrunning with some other setting. We assume UTC datetimes\nin the database.", "ret": null}, "fn_lc": [[87, 4], [101, 20]], "fn_var_ln": {"value": [[99, 16], [99, 21]]}, "fn_var_occur": {"value": [["value", "None"], ["value", "tzinfo", "None"], ["value", "value", "replace", "tzinfo", "utc"], ["value", "value", "astimezone", "utc"]]}, "name": "process_result_value", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [], "value": [["value", "None"], ["value", "tzinfo", "None"], ["value", "value", "replace", "tzinfo", "utc"], ["value", "value", "astimezone", "utc"]]}, "params_p": {"args": [], "dialect": [["str", 0.749999999601367], ["sqlalchemy.engine.interfaces.Dialect", 0.24999999976082019], ["Optional[Tuple[Any, Any]]", 1.5945321055561182e-10], ["Callable", 1.5945321055561182e-10], ["dict", 1.5945321055561182e-10], ["Iterable[Any]", 1.5945321055561182e-10]], "kwargs": [], "self": [], "value": [["Optional[str]", 0.34743110040957126], ["str", 0.19004783632769567], ["bytes", 0.15638302583971175], ["T", 0.14274130654316022], ["Callable", 0.06873279059185673]]}, "q_name": "UtcDateTime.process_result_value", "ret_exprs": ["return value"], "ret_type": "", "ret_type_p": [["str", 0.5126942283985652], ["int", 0.19107465573730031], ["list", 0.10668872873734409], ["Dict[str, Any]", 0.09085957008051619]], "variables": {"value": ""}, "variables_p": {"value": [["list", 0.23246244459795906], ["Type[Exception]", 0.10935650980144804], ["List[str]", 0.0979895451010087], ["Union[None, float, int, str]", 0.08918522288624563]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[103, 4], [108, 49]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "load_dialect_impl", "params": {"dialect": "", "self": ""}, "params_descr": {"dialect": "", "self": ""}, "params_occur": {"dialect": [["dialect", "name"], ["dialect", "name"], ["super", "load_dialect_impl", "dialect"]], "self": []}, "params_p": {"args": [], "dialect": [["str", 0.3473146702337514], ["IO", 0.1314319157467327], ["Dict[str, List[str]]", 0.08840174271962178], ["sqlalchemy.Column", 0.08801726403154081], ["bool", 0.08459605603079007], ["int", 0.08429107696072471]], "kwargs": [], "self": []}, "q_name": "UtcDateTime.load_dialect_impl", "ret_exprs": ["return mssql.DATETIME2(precision=6)", "return mysql.TIMESTAMP(fsp=6)", "return super().load_dialect_impl(dialect)"], "ret_type": "", "ret_type_p": [["str", 0.5782525191901526], ["datetime.datetime", 0.2839472186443132]], "variables": {}, "variables_p": {}}], "name": "UtcDateTime", "q_name": "UtcDateTime", "variables": {"cache_ok": "", "impl": ""}, "variables_p": {"cache_ok": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "impl": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"cls_lc": [[111, 0], [155, 51]], "cls_var_ln": {"cache_ok": [[119, 4], [119, 12]], "impl": [[117, 4], [117, 8]]}, "cls_var_occur": {"cache_ok": [], "impl": []}, "funcs": [{"docstring": {"func": "Checks if the database supports JSON (i.e. is NOT MSSQL).", "long_descr": null, "ret": null}, "fn_lc": [[121, 4], [123, 79]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "db_supports_json", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": []}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "ExtendedJSON.db_supports_json", "ret_exprs": ["return not conf.get(\"database\", \"sql_alchemy_conn\").startswith(\"mssql\")"], "ret_type": "", "ret_type_p": [["dict", 0.13477480832632038], ["abilian.core.models.subjects.User", 0.09449786094035165]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[125, 4], [128, 51]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "load_dialect_impl", "params": {"dialect": "", "self": ""}, "params_descr": {"dialect": "", "self": ""}, "params_occur": {"dialect": [["dialect", "type_descriptor", "JSON"], ["dialect", "type_descriptor", "UnicodeText"]], "self": [["self", "db_supports_json"]]}, "params_p": {"args": [], "dialect": [["str", 0.2059673922539626], ["bool", 0.19260764658733814], ["int", 0.09092906498470733]], "kwargs": [], "self": []}, "q_name": "ExtendedJSON.load_dialect_impl", "ret_exprs": ["return dialect.type_descriptor(JSON)", "return dialect.type_descriptor(UnicodeText)"], "ret_type": "sqlalchemy.types.TypeEngine", "ret_type_p": [["bool", 0.6182616110444263], ["Type[BaseException]", 0.18585650344181498], ["db.models.Name", 0.1074418352475449], ["Optional[Type[BaseException]]", 0.08844005026621378]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[130, 4], [143, 20]], "fn_var_ln": {"value": [[141, 12], [141, 17]]}, "fn_var_occur": {"value": [["value", "None"], ["value", "BaseSerialization", "serialize", "value"], ["value", "json", "dumps", "value"]]}, "name": "process_bind_param", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [["self", "db_supports_json"]], "value": [["value", "None"], ["value", "BaseSerialization", "serialize", "value"], ["value", "json", "dumps", "value"]]}, "params_p": {"args": [], "dialect": [["ics.types.ContextDict", 0.2], ["ics.types.ExtraParams", 0.2], ["ics.types.DatetimeLike", 0.1], ["int", 0.1], ["Tuple[str, int]", 0.1], ["complex", 0.1], ["list", 0.1]], "kwargs": [], "self": [], "value": [["Union[T, Sequence[T]]", 0.29049513671023425], ["Optional[dict]", 0.15549315722011714], ["Optional[List]", 0.10068964279119012], ["Optional[datetime.timedelta]", 0.09440002995668158], ["Optional[Dict[str, Any]]", 0.08976899290887215], ["Optional[str]", 0.08759760061191477], ["Optional[object]", 0.08452924665349486]]}, "q_name": "ExtendedJSON.process_bind_param", "ret_exprs": ["return None", "return value"], "ret_type": "", "ret_type_p": [["Optional[str]", 0.48061423911524004], ["bool", 0.22983493282887243], ["Optional[float]", 0.09884796722722393], ["str", 0.09507620493381937]], "variables": {"value": ""}, "variables_p": {"value": [["str", 0.30452526741357877], ["List[str]", 0.12486778752254679]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[145, 4], [155, 51]], "fn_var_ln": {"value": [[153, 12], [153, 17]]}, "fn_var_occur": {"value": [["value", "None"], ["value", "json", "loads", "value"], ["BaseSerialization", "deserialize", "value"]]}, "name": "process_result_value", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [["self", "db_supports_json"]], "value": [["value", "None"], ["value", "json", "loads", "value"], ["BaseSerialization", "deserialize", "value"]]}, "params_p": {"args": [], "dialect": [["str", 0.749999999601367], ["sqlalchemy.engine.interfaces.Dialect", 0.24999999976082019], ["Optional[Tuple[Any, Any]]", 1.5945321055561182e-10], ["Callable", 1.5945321055561182e-10], ["dict", 1.5945321055561182e-10], ["Iterable[Any]", 1.5945321055561182e-10]], "kwargs": [], "self": [], "value": [["Optional[str]", 0.5545311849135831], ["Optional[dict]", 0.07063436509598127], ["bytes", 0.060163151446487026], ["dict", 0.05767002838642103], ["float", 0.05753568481511468]]}, "q_name": "ExtendedJSON.process_result_value", "ret_exprs": ["return None", "return BaseSerialization.deserialize(value)"], "ret_type": "", "ret_type_p": [["bool", 0.20043987692053167], ["Optional[int]", 0.10280117217302731], ["Optional[\"Period\"]", 0.10280117217302731], ["List[str]", 0.09818775554418613], ["Optional[float]", 0.09781183983638901], ["Optional[zerver.models.Stream]", 0.09419028134565871]], "variables": {"value": ""}, "variables_p": {"value": [["str", 0.28370073568515763], ["List[str]", 0.1924354626518294], ["Tuple[Literal, Literal]", 0.17346328600835415], ["Dict[str, Any]", 0.08601251322799588]]}}], "name": "ExtendedJSON", "q_name": "ExtendedJSON", "variables": {"cache_ok": "", "impl": ""}, "variables_p": {"cache_ok": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "impl": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"cls_lc": [[245, 0], [312, 28]], "cls_var_ln": {"cache_ok": [[253, 4], [253, 12]]}, "cls_var_occur": {"cache_ok": []}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[261, 8], [265, 42]], "fn_var_ln": {"val_copy": [[262, 12], [262, 20]]}, "fn_var_occur": {"val_copy": [["val_copy", "copy", "copy", "value"], ["isinstance", "val_copy", "dict", "val_copy"], ["val_copy", "BaseSerialization", "serialize", "val_copy"], ["super_process", "val_copy"]]}, "name": "process", "params": {"value": ""}, "params_descr": {"value": ""}, "params_occur": {"value": [["val_copy", "copy", "copy", "value"]]}, "params_p": {"args": [], "kwargs": [], "self": [], "value": [["str", 0.37841867202357343], ["raiden.utils.Nonce", 0.11338729168452082], ["ics.types.ContextDict", 0.11209605998210527], ["ics.types.ExtraParams", 0.11209605998210527], ["int", 0.09661171824772347], ["float", 0.09661171824772347]]}, "q_name": "ExecutorConfigType.bind_processor.<locals>.process", "ret_exprs": ["return super_process(val_copy)"], "ret_type": "", "ret_type_p": [["int", 0.30000000000000004], ["Callable", 0.2], ["models.Question", 0.1], ["str", 0.1]], "variables": {"val_copy": ""}, "variables_p": {"val_copy": [["Dict[Any, list]", 0.20193918773675903], ["List[Dict[str, Any]]", 0.12799687384358716], ["bytes", 0.10591779827828818], ["str", 0.10115779906098046], ["dict", 0.09519541280759908], ["int", 0.09426169439177852], ["bool", 0.09011085968952007], ["List[Tuple[Any, Any]]", 0.08915867979970893]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[255, 4], [267, 22]], "fn_var_ln": {"super_process": [[259, 8], [259, 21]]}, "fn_var_occur": {"super_process": []}, "name": "bind_processor", "params": {"dialect": "", "self": ""}, "params_descr": {"dialect": "", "self": ""}, "params_occur": {"dialect": [], "self": []}, "params_p": {"args": [], "dialect": [["int", 0.19999999999999998], ["str", 0.19999999999999998], ["Iterable['Context']", 0.09999999999999999], ["dict", 0.09999999999999999], ["bool", 0.09999999999999999]], "kwargs": [], "self": []}, "q_name": "ExecutorConfigType.bind_processor", "ret_exprs": ["return process"], "ret_type": "", "ret_type_p": [["int", 0.30000000000000004], ["Callable", 0.2], ["models.Question", 0.1], ["str", 0.1]], "variables": {"super_process": ""}, "variables_p": {"super_process": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[274, 8], [290, 24]], "fn_var_ln": {"new_pod": [[287, 20], [287, 27]], "pod_override": [[278, 16], [278, 28]], "value": [[275, 12], [275, 17]]}, "fn_var_occur": {"new_pod": [["new_pod", "ensure_pod_is_valid_after_unpickling", "pod_override"], ["value", "new_pod"]], "pod_override": [["pod_override", "value"], ["isinstance", "pod_override", "dict", "pod_override", "get", "Encoding", "TYPE"], ["value", "BaseSerialization", "deserialize", "pod_override"], ["new_pod", "ensure_pod_is_valid_after_unpickling", "pod_override"]], "value": [["value", "super_process", "value"], ["isinstance", "value", "dict", "value"], ["pod_override", "value"], ["value", "BaseSerialization", "deserialize", "pod_override"], ["value", "new_pod"]]}, "name": "process", "params": {"value": ""}, "params_descr": {"value": ""}, "params_occur": {"value": [["value", "super_process", "value"], ["isinstance", "value", "dict", "value"], ["pod_override", "value"], ["value", "BaseSerialization", "deserialize", "pod_override"], ["value", "new_pod"]]}, "params_p": {"args": [], "kwargs": [], "self": [], "value": [["Optional[str]", 0.21322648443320202], ["ByteString", 0.17746133495183536], ["types.streams.T", 0.11833692253935961], ["Iterable", 0.08708947254943965], ["bool", 0.08679279534071506], ["T", 0.08497350137577842]]}, "q_name": "ExecutorConfigType.result_processor.<locals>.process", "ret_exprs": ["return value"], "ret_type": "", "ret_type_p": [["str", 0.6063823456902878], ["int", 0.17638598532592126], ["Dict[str, Any]", 0.11379897048526452]], "variables": {"new_pod": "", "pod_override": "", "value": ""}, "variables_p": {"new_pod": [["dict", 0.09207087813778818], ["Dict[str, str]", 0.09205551806154899]], "pod_override": [["str", 0.4051252374684818], ["dict", 0.21943348305232407], ["Tuple[str, str]", 0.15580543721818463], ["Dict[str, Dict[int, str]]", 0.10987825842297938], ["List[Tuple[Any, Any]]", 0.10975758383803004]], "value": [["Union[List[Any], str]", 0.11784211017898251], ["list", 0.10480967285966789], ["Optional[List]", 0.1000289714392569], ["str", 0.09789177971664716]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[269, 4], [292, 22]], "fn_var_ln": {"super_process": [[272, 8], [272, 21]]}, "fn_var_occur": {"super_process": []}, "name": "result_processor", "params": {"coltype": "", "dialect": "", "self": ""}, "params_descr": {"coltype": "", "dialect": "", "self": ""}, "params_occur": {"coltype": [], "dialect": [], "self": []}, "params_p": {"args": [], "coltype": [["str", 2.830400935897555e-10], ["Sequence[str]", 2.3215973150679294e-10], ["Iterator[Tuple[str, Any, Any]]", 2.1337099420404579e-10]], "dialect": [["str", 2.830400935897555e-10], ["Sequence[str]", 2.3215973150679294e-10], ["Iterator[Tuple[str, Any, Any]]", 2.1337099420404579e-10]], "kwargs": [], "self": []}, "q_name": "ExecutorConfigType.result_processor", "ret_exprs": ["return process"], "ret_type": "", "ret_type_p": [["str", 4.802071651188567e-10], ["float", 1.3477178700986637e-10]], "variables": {"super_process": ""}, "variables_p": {"super_process": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"docstring": {"func": "The TaskInstance.executor_config attribute is a pickled object that may contain", "long_descr": "kubernetes objects.  If the installed library version has changed since the\nobject was originally pickled, due to the underlying ``__eq__`` method on these\nobjects (which converts them to JSON), we may encounter attribute errors. In this\ncase we should replace the stored object.\n\nFrom https://github.com/apache/airflow/pull/24356 we use our serializer to store\nk8s objects, but there could still be raw pickled k8s objects in the database,\nstored from earlier version, so we still compare them defensively here.", "ret": null}, "fn_lc": [[294, 4], [312, 28]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "compare_values", "params": {"self": "", "x": "", "y": ""}, "params_descr": {"self": "", "x": "", "y": ""}, "params_occur": {"self": [["self", "comparator"], ["self", "comparator", "x", "y"]], "x": [["self", "comparator", "x", "y"], ["x", "y"]], "y": [["self", "comparator", "x", "y"], ["x", "y"]]}, "params_p": {"args": [], "kwargs": [], "self": [], "x": [["float", 0.39162096599262153], ["int", 0.28649874989258783], ["List[float]", 0.13569855080942644]], "y": [["float", 0.39162096599262153], ["int", 0.28649874989258783], ["List[float]", 0.13569855080942644]]}, "q_name": "ExecutorConfigType.compare_values", "ret_exprs": ["return self.comparator(x, y)", "return x == y", "return False"], "ret_type": "", "ret_type_p": [["int", 0.4541224576197229], ["Optional[int]", 0.22400663049463485], ["List[int]", 0.1683404823998076], ["utils.Node", 0.0811374983593578]], "variables": {}, "variables_p": {}}], "name": "ExecutorConfigType", "q_name": "ExecutorConfigType", "variables": {"cache_ok": ""}, "variables_p": {"cache_ok": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"cls_lc": [[315, 0], [356, 19]], "cls_var_ln": {"attr_keys": [[322, 4], [322, 13]], "cache_ok": [[320, 4], [320, 12]], "impl": [[318, 4], [318, 8]]}, "cls_var_occur": {"attr_keys": [], "cache_ok": [], "impl": []}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[343, 4], [347, 32]], "fn_var_ln": {"attrs": [[345, 12], [345, 17]]}, "fn_var_occur": {"attrs": [["attrs", "key", "getattr", "value", "key", "key", "self", "attr_keys", "type", "value"], ["json", "dumps", "type", "value", "__name__", "attrs"]]}, "name": "process_bind_param", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [["isinstance", "value", "tuple", "self", "attr_keys"], ["attrs", "key", "getattr", "value", "key", "key", "self", "attr_keys", "type", "value"]], "value": [["isinstance", "value", "tuple", "self", "attr_keys"], ["attrs", "key", "getattr", "value", "key", "key", "self", "attr_keys", "type", "value"], ["json", "dumps", "type", "value", "__name__", "attrs"], ["json", "dumps", "value"]]}, "params_p": {"args": [], "dialect": [["ics.types.ContextDict", 0.2], ["ics.types.ExtraParams", 0.2], ["ics.types.DatetimeLike", 0.1], ["int", 0.1], ["Tuple[str, int]", 0.1], ["complex", 0.1], ["list", 0.1]], "kwargs": [], "self": [], "value": [["dict", 0.13228262532308194], ["Dict[str, Any]", 0.11143783647128325], ["Dict[str, str]", 0.09766875000011548], ["str", 0.09575577946924867], ["Tuple[str, str]", 0.09399695449551537]]}, "q_name": "Interval.process_bind_param", "ret_exprs": ["return json.dumps({\"type\": type(value).__name__, \"attrs\": attrs})", "return json.dumps(value)"], "ret_type": "", "ret_type_p": [["mypy.types.CallableType", 0.2908588945655679], ["mypy.types.Instance", 0.1062914625994278], ["Sequence[Any]", 0.09016960508713111]], "variables": {"attrs": ""}, "variables_p": {"attrs": [["str", 0.28347512774462086], ["dict", 0.18209292202827776], ["Type[Mapping[str, Any]]", 0.14247161744804593], ["Dict[Tuple[str, str], str]", 0.09091381757616822]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[349, 4], [356, 19]], "fn_var_ln": {"data": [[352, 8], [352, 12]], "type_map": [[354, 12], [354, 20]]}, "fn_var_occur": {"data": [["data", "json", "loads", "value"], ["isinstance", "data", "dict"], ["type_map", "data", "data"]], "type_map": [["type_map", "key", "__name__", "key", "key", "self", "attr_keys"], ["type_map", "data", "data"]]}, "name": "process_result_value", "params": {"dialect": "", "self": "", "value": ""}, "params_descr": {"dialect": "", "self": "", "value": ""}, "params_occur": {"dialect": [], "self": [["type_map", "key", "__name__", "key", "key", "self", "attr_keys"]], "value": [["data", "json", "loads", "value"]]}, "params_p": {"args": [], "dialect": [["str", 0.749999999601367], ["sqlalchemy.engine.interfaces.Dialect", 0.24999999976082019], ["Optional[Tuple[Any, Any]]", 1.5945321055561182e-10], ["Callable", 1.5945321055561182e-10], ["dict", 1.5945321055561182e-10], ["Iterable[Any]", 1.5945321055561182e-10]], "kwargs": [], "self": [], "value": [["str", 0.5050954590978016], ["List[str]", 0.3983402626356771], ["List[Dict[str, Any]]", 0.09656427826652134]]}, "q_name": "Interval.process_result_value", "ret_exprs": ["return value", "return type_map[data[\"type\"]](**data[\"attrs\"])", "return data"], "ret_type": "", "ret_type_p": [["bool", 0.2423599828196406], ["Set[str]", 0.1643301394425576], ["int", 0.12792751767383284], ["Union[type, Tuple[type, ...]]", 0.08716676878410928], ["Mapping[str, str]", 0.08120628248608928]], "variables": {"data": "", "type_map": ""}, "variables_p": {"data": [["dict", 0.2935307596346547], ["Dict[str, Union[int, str]]", 0.10404776896637173], ["Set[str]", 0.08660991354082219], ["List[int]", 0.08400958230647984], ["Dict[str, Union[float, str]]", 0.08116468372207646]], "type_map": [["Dict[str, str]", 0.7331402789449142], ["dict", 0.17952065158565556], ["set", 0.08733906946943046]]}}], "name": "Interval", "q_name": "Interval", "variables": {"attr_keys": "", "cache_ok": "", "impl": ""}, "variables_p": {"attr_keys": [["str", 0.9999999836227274], ["Set[str]", 7.474435999033805e-09], ["property", 4.451418310152615e-09]], "cache_ok": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]], "impl": [["str", 0.4], ["List[str]", 0.1], ["int", 0.1], ["raiden.utils.WithdrawAmount", 0.1], ["Dict[str, List[Any]]", 0.1], ["Tuple[str, str, str, str, str, str, str, str]", 0.1]]}}, {"cls_lc": [[447, 0], [475, 29]], "cls_var_ln": {"expected_commit": [[450, 4], [450, 19]]}, "cls_var_occur": {"expected_commit": []}, "funcs": [{"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[452, 4], [453, 30]], "fn_var_ln": {"session": [[453, 8], [453, 20]]}, "fn_var_occur": {"session": [["self", "session", "session"]]}, "name": "__init__", "params": {"self": "", "session": "sqlalchemy.orm.Session"}, "params_descr": {"self": "", "session": ""}, "params_occur": {"self": [["self", "session", "session"]], "session": [["self", "session", "session"]]}, "params_p": {"args": [], "kwargs": [], "self": [], "session": [["str", 0.26124610150525795], ["List[str]", 0.12298397701054066], ["Sequence[str]", 0.12298397701054066], ["bool", 0.09290459128105384], ["nox.sessions.Session", 0.08099011939186382], ["sqlalchemy.orm.Session", 0.07943767826502196]]}, "q_name": "CommitProhibitorGuard.__init__", "ret_exprs": [], "ret_type": "", "variables": {"session": ""}, "variables_p": {"session": [["Optional[str]", 0.20771837579185262], ["sqlalchemy.orm.session.Session", 0.11235204429842463]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[455, 4], [459, 75]], "fn_var_ln": {"expected_commit": [[457, 12], [457, 32]]}, "fn_var_occur": {"expected_commit": [["self", "expected_commit"], ["self", "expected_commit", "False"]]}, "name": "_validate_commit", "params": {"_": "", "self": ""}, "params_descr": {"_": "", "self": ""}, "params_occur": {"_": [], "self": [["self", "expected_commit"], ["self", "expected_commit", "False"]]}, "params_p": {"_": [["int", 0.19999999999999998], ["str", 0.19999999999999998], ["Iterable['Context']", 0.09999999999999999], ["dict", 0.09999999999999999], ["bool", 0.09999999999999999]], "args": [], "kwargs": [], "self": []}, "q_name": "CommitProhibitorGuard._validate_commit", "ret_exprs": ["return"], "ret_type": "", "ret_type_p": [["Union[tuple, list]", 0.12326783261663934], ["List[int]", 0.09124591253820835], ["Dict[str, Any]", 0.08769568774684897], ["str", 0.08682447752895113]], "variables": {"expected_commit": ""}, "variables_p": {"expected_commit": [["int", 0.2864022208492021], ["str", 0.2261079939373586], ["List[List[Any]]", 0.1846340600397335], ["Tuple[int]", 0.11289545640514889], ["Dict[str, int]", 0.09577657018669877], ["Dict[str, Optional[int]]", 0.09418369858185813]]}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[461, 4], [463, 19]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "__enter__", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["event", "listen", "self", "session", "self", "_validate_commit"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "CommitProhibitorGuard.__enter__", "ret_exprs": ["return self"], "ret_type": "", "ret_type_p": [["int", 0.30000000000000004], ["Callable", 0.2], ["models.Question", 0.1], ["str", 0.1]], "variables": {}, "variables_p": {}}, {"docstring": {"func": null, "long_descr": null, "ret": null}, "fn_lc": [[465, 4], [466, 74]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "__exit__", "params": {"exc_info": "", "self": ""}, "params_descr": {"exc_info": "", "self": ""}, "params_occur": {"exc_info": [], "self": [["event", "remove", "self", "session", "self", "_validate_commit"]]}, "params_p": {"args": [], "exc_info": [["Dict[str, Any]", 0.1]], "kwargs": [], "self": []}, "q_name": "CommitProhibitorGuard.__exit__", "ret_exprs": [], "ret_type": "", "variables": {}, "variables_p": {}}, {"docstring": {"func": "Commit the session.", "long_descr": "This is the required way to commit when the guard is in scope", "ret": null}, "fn_lc": [[468, 4], [475, 29]], "fn_var_ln": {"expected_commit": [[474, 8], [474, 28]]}, "fn_var_occur": {"expected_commit": [["self", "expected_commit", "True"]]}, "name": "commit", "params": {"self": ""}, "params_descr": {"self": ""}, "params_occur": {"self": [["self", "expected_commit", "True"], ["self", "session", "commit"]]}, "params_p": {"args": [], "kwargs": [], "self": []}, "q_name": "CommitProhibitorGuard.commit", "ret_exprs": [], "ret_type": "", "variables": {"expected_commit": ""}, "variables_p": {"expected_commit": [["bytes", 0.21172991942611563], ["int", 0.2017472703024214], ["Set[str]", 0.09390022722309019], ["str", 0.09287677809551999], ["Union[Dict[str, Any], List[Any]]", 0.0911037468769551]]}}], "name": "CommitProhibitorGuard", "q_name": "CommitProhibitorGuard", "variables": {"expected_commit": ""}, "variables_p": {"expected_commit": [["str", 0.5], ["List[bool]", 0.1], ["Dict[int, List[str]]", 0.1], ["Dict[str, Union[int, str]]", 0.1], ["List[Dict[str, Any]]", 0.1]]}}], "funcs": [{"docstring": {"func": "Convert pod to dict.... but *safely*.", "long_descr": "When pod objects created with one k8s version are unpickled in a python\nenv with a more recent k8s version (in which the object attrs may have\nchanged) the unpickled obj may throw an error because the attr\nexpected on new obj may not be there on the unpickled obj.\n\nThis function still converts the pod to a dict; the only difference is\nit populates missing attrs with None. You may compare with\nhttps://github.com/kubernetes-client/python/blob/5a96bbcbe21a552cc1f9cda13e0522fafb0dbac8/kubernetes/client/api_client.py#L202\n\nIf obj is None, return None.\nIf obj is str, int, long, float, bool, return directly.\nIf obj is datetime.datetime, datetime.date\n    convert to string in iso8601 format.\nIf obj is list, sanitize each element in the list.\nIf obj is dict, return the dict.\nIf obj is OpenAPI model, return the properties dict.", "ret": "The serialized form of data."}, "fn_lc": [[158, 0], [205, 82]], "fn_var_ln": {"obj_dict": [[198, 8], [198, 16]]}, "fn_var_occur": {"obj_dict": [["obj_dict", "obj"], ["obj_dict", "obj", "attribute_map", "attr", "getattr", "obj", "attr", "attr", "_", "obj", "openapi_types", "items", "getattr", "obj", "attr", "None", "None"], ["key", "sanitize_for_serialization", "val", "key", "val", "obj_dict", "items"]]}, "name": "sanitize_for_serialization", "params": {"obj": "kubernetes.client.models.v1_pod.V1Pod"}, "params_descr": {"obj": "The data to serialize."}, "params_occur": {"obj": [["obj", "None"], ["isinstance", "obj", "float", "bool", "bytes", "str", "int"], ["isinstance", "obj", "list"], ["sanitize_for_serialization", "sub_obj", "sub_obj", "obj"], ["isinstance", "obj", "tuple"], ["tuple", "sanitize_for_serialization", "sub_obj", "sub_obj", "obj"], ["isinstance", "obj", "datetime", "datetime", "datetime", "date"], ["obj", "isoformat"], ["isinstance", "obj", "dict"], ["obj_dict", "obj"], ["obj_dict", "obj", "attribute_map", "attr", "getattr", "obj", "attr", "attr", "_", "obj", "openapi_types", "items", "getattr", "obj", "attr", "None", "None"]]}, "params_p": {"args": [], "kwargs": [], "obj": [["int", 0.35257368165309955], ["Optional[int]", 0.22448899025742564], ["float", 0.1968156466301608]]}, "q_name": "sanitize_for_serialization", "ret_exprs": ["return None", "return obj", "return [sanitize_for_serialization(sub_obj) for sub_obj in obj]", "return tuple(sanitize_for_serialization(sub_obj) for sub_obj in obj)", "return obj.isoformat()", "return {key: sanitize_for_serialization(val) for key, val in obj_dict.items()}"], "ret_type": "", "ret_type_p": [["Optional[str]", 0.19111237096688574], ["int", 0.0953726047981973]], "variables": {"obj_dict": ""}, "variables_p": {"obj_dict": [["dict", 0.4877568142870927], ["Dict[int, Any]", 0.20665757590559877], ["Dict[cmk.utils.type_defs.UserId, Dict[str, Any]]", 0.10607641295101423], ["Dict[str, Union[Any, str]]", 0.10506103300603252], ["Type[Dict[str, Any]]", 0.0944481638502617]]}}, {"docstring": {"func": "Convert pod to json and back so that pod is safe.", "long_descr": "The pod_override in executor_config is a V1Pod object.\nSuch objects created with one k8s version, when unpickled in\nan env with upgraded k8s version, may blow up when\n`to_dict` is called, because openapi client code gen calls\ngetattr on all attrs in openapi_types for each object, and when\nnew attrs are added to that list, getattr will fail.\n\nHere we re-serialize it to ensure it is not going to blow up.", "ret": null}, "fn_lc": [[208, 0], [242, 19]], "fn_var_ln": {"pod_dict": [[239, 8], [239, 16]]}, "fn_var_occur": {"pod_dict": [["pod_dict", "sanitize_for_serialization", "pod"], ["PodGenerator", "deserialize_model_dict", "pod_dict"]]}, "name": "ensure_pod_is_valid_after_unpickling", "params": {"pod": "kubernetes.client.models.v1_pod.V1Pod"}, "params_descr": {"pod": ""}, "params_occur": {"pod": [["pod", "to_dict"], ["isinstance", "pod", "V1Pod"], ["pod_dict", "sanitize_for_serialization", "pod"]]}, "params_p": {"args": [], "kwargs": [], "pod": [["dict", 0.49466768220494745], ["Dict[str, Any]", 0.2406728327400614], ["str", 0.08951077348574488], ["Dict[str, Dict[str, str]]", 0.08521761201473903]]}, "q_name": "ensure_pod_is_valid_after_unpickling", "ret_exprs": ["return pod", "return None", "return None", "return PodGenerator.deserialize_model_dict(pod_dict)", "return None"], "ret_type": "V1Pod | None", "ret_type_p": [["Optional[int]", 0.29489871020770714], ["Optional[str]", 0.27162355905655966], ["Optional[float]", 0.0952029083573296]], "variables": {"pod_dict": ""}, "variables_p": {"pod_dict": [["Dict[Any, str]", 0.32688250508220573], ["dict", 0.19351430394958685], ["Dict[str, tuple]", 0.1863618967216275], ["Dict[str, str]", 0.10721813926043704], ["Dict[Union[int, str], int]", 0.09318094836081375], ["Dict[str, int]", 0.09284220662532902]]}}, {"docstring": {"func": "Return kargs for passing to `with_for_update()` suitable for the current DB engine version.", "long_descr": "We do this as we document the fact that on DB engines that don't support this construct, we do not\nsupport/recommend running HA scheduler. If a user ignores this and tries anyway everything will still\nwork, just slightly slower in some circumstances.\n\nSpecifically don't emit SKIP LOCKED for MySQL < 8, or MariaDB, neither of which support this construct\n\nSee https://jira.mariadb.org/browse/MDEV-13115", "ret": null}, "fn_lc": [[359, 0], [376, 17]], "fn_var_ln": {"dialect": [[371, 4], [371, 11]]}, "fn_var_occur": {"dialect": [["dialect", "session", "bind", "dialect"], ["dialect", "name", "dialect", "supports_for_update_of"]]}, "name": "skip_locked", "params": {"session": "sqlalchemy.orm.Session"}, "params_descr": {"session": ""}, "params_occur": {"session": [["dialect", "session", "bind", "dialect"]]}, "params_p": {"args": [], "kwargs": [], "session": [["nox.sessions.Session", 0.4698140021689357], ["deeplearning.ml4pl.models.log_database.Database", 0.08988852180396494]]}, "q_name": "skip_locked", "ret_exprs": ["return {\"skip_locked\": True}", "return {}"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [["bool", 0.44046398421182986], ["Optional[int]", 0.1255520294935758], ["int", 0.123178118204177], ["str", 0.10130080979790215], ["Optional[bool]", 0.08632694008833819]], "variables": {"dialect": ""}, "variables_p": {"dialect": [["str", 0.29799473927837244], ["Dict[str, OrderedDict[str, Any]]", 0.11698333599524426], ["Dict[str, Any]", 0.10525339318928761], ["float", 0.0906571454308234], ["Dict[str, str]", 0.08795020867575146], ["dict", 0.0857620849805587]]}}, {"docstring": {"func": "Return kwargs for passing to `with_for_update()` suitable for the current DB engine version.", "long_descr": "We do this as we document the fact that on DB engines that don't support this construct, we do not\nsupport/recommend running HA scheduler. If a user ignores this and tries anyway everything will still\nwork, just slightly slower in some circumstances.\n\nSpecifically don't emit NOWAIT for MySQL < 8, or MariaDB, neither of which support this construct\n\nSee https://jira.mariadb.org/browse/MDEV-13115", "ret": null}, "fn_lc": [[379, 0], [396, 17]], "fn_var_ln": {"dialect": [[391, 4], [391, 11]]}, "fn_var_occur": {"dialect": [["dialect", "session", "bind", "dialect"], ["dialect", "name", "dialect", "supports_for_update_of"]]}, "name": "nowait", "params": {"session": "sqlalchemy.orm.Session"}, "params_descr": {"session": ""}, "params_occur": {"session": [["dialect", "session", "bind", "dialect"]]}, "params_p": {"args": [], "kwargs": [], "session": [["nox.sessions.Session", 0.4698140021689357], ["deeplearning.ml4pl.models.log_database.Database", 0.08988852180396494]]}, "q_name": "nowait", "ret_exprs": ["return {\"nowait\": True}", "return {}"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [["bool", 0.9999999999999999]], "variables": {"dialect": ""}, "variables_p": {"dialect": [["str", 0.29799473927837244], ["Dict[str, OrderedDict[str, Any]]", 0.11698333599524426], ["Dict[str, Any]", 0.10525339318928761], ["float", 0.0906571454308234], ["Dict[str, str]", 0.08795020867575146], ["dict", 0.0857620849805587]]}}, {"docstring": {"func": "Specify *NULLS FIRST* to the column ordering.", "long_descr": "This is only done to Postgres, currently the only backend that supports it.\nOther databases do not need it since NULL values are considered lower than\nany other values, and appear first when the order is ASC (ascending).", "ret": null}, "fn_lc": [[399, 0], [409, 18]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "nulls_first", "params": {"col": "", "session": "sqlalchemy.orm.Session"}, "params_descr": {"col": "", "session": ""}, "params_occur": {"col": [["nullsfirst", "col"]], "session": [["session", "bind", "dialect", "name"]]}, "params_p": {"args": [], "col": [["str", 0.2788099167564252], ["dict", 0.20073508545570729], ["Union[bool, int, str]", 0.12544327859683582], ["Optional[str]", 0.11252127143455401], ["float", 0.09010197175001318], ["int", 0.06925294131038633]], "kwargs": [], "session": [["str", 0.5058754114341999], ["sqlalchemy.engine.reflection.Inspector", 0.18622976623139184], ["Optional[str]", 0.09311488311569592]]}, "q_name": "nulls_first", "ret_exprs": ["return nullsfirst(col)", "return col"], "ret_type": "builtins.dict[builtins.str, typing.Any]", "ret_type_p": [["str", 0.2883956046155739], ["int", 0.21611069144575973], ["bool", 0.19201917094345372], ["dict", 0.09013209484522419]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Apply with_for_update to an SQLAlchemy query, if row level locking is in use.", "long_descr": null, "ret": "updated query"}, "fn_lc": [[415, 0], [430, 20]], "fn_var_ln": {"dialect": [[424, 4], [424, 11]]}, "fn_var_occur": {"dialect": [["dialect", "session", "bind", "dialect"], ["USE_ROW_LEVEL_LOCKING", "dialect", "name", "dialect", "supports_for_update_of"]]}, "name": "with_row_locks", "params": {"kwargs": "", "query": "sqlalchemy.orm.Query", "session": "sqlalchemy.orm.Session"}, "params_descr": {"kwargs": "Extra kwargs to pass to with_for_update (of, nowait, skip_locked, etc)", "query": "An SQLAlchemy Query object", "session": "ORM Session"}, "params_occur": {"kwargs": [["query", "with_for_update", "kwargs"]], "query": [["query", "with_for_update", "kwargs"]], "session": [["dialect", "session", "bind", "dialect"]]}, "params_p": {"args": [], "kwargs": [], "query": [["Dict[str, object]", 0.10346955495904099], ["Tuple[str, str]", 0.08867736736394005], ["dict", 0.08543504699266032], ["str", 0.08342394322428812]], "session": [["nox.sessions.Session", 0.5455236670003167], ["deeplearning.ml4pl.models.log_database.Database", 0.14184096071915864], ["bool", 0.06606414646005872]]}, "q_name": "with_row_locks", "ret_exprs": ["return query.with_for_update(**kwargs)", "return query"], "ret_type": "sqlalchemy.orm.Query", "ret_type_p": [["bool", 1.0]], "variables": {"dialect": ""}, "variables_p": {"dialect": [["adapters.enums.CompAny", 0.16010183372426076], ["adapters.enums.City", 0.14633352858768153], ["str", 0.10200979686459324], ["viewer.models.Gallery", 0.08980398690778817], ["int", 0.08425973240857508]]}}, {"docstring": {"func": "Lock database rows during the context manager block.", "long_descr": "This is a convenient method for ``with_row_locks`` when we don't need the\nlocked rows.", "ret": null}, "fn_lc": [[434, 0], [444, 19]], "fn_var_ln": {"locked_rows": [[442, 4], [442, 15]]}, "fn_var_occur": {"locked_rows": [["locked_rows", "with_row_locks", "query", "session", "all"]]}, "name": "lock_rows", "params": {"query": "sqlalchemy.orm.Query", "session": "sqlalchemy.orm.Session"}, "params_descr": {"query": "", "session": ""}, "params_occur": {"query": [["locked_rows", "with_row_locks", "query", "session", "all"]], "session": [["locked_rows", "with_row_locks", "query", "session", "all"]]}, "params_p": {"args": [], "kwargs": [], "query": [["models.Match", 0.11316779741360491], ["Iterable[Hashable]", 0.10663746909885695]], "session": [["models.Match", 0.11316779741360491], ["Iterable[Hashable]", 0.10663746909885695]]}, "q_name": "lock_rows", "ret_exprs": [], "ret_type": "typing.Generator[None, None, None]", "variables": {"locked_rows": ""}, "variables_p": {"locked_rows": [["List[str]", 0.12526449941802761], ["set", 0.11098143385883996], ["int", 0.10223736839520811], ["list", 0.09772519593178167], ["Dict[Type[Any], Union[Any, Any]]", 0.09510259498718435], ["List[float]", 0.09263013083468911], ["List[int]", 0.09175768394710815]]}}, {"docstring": {"func": "Return a context manager that will disallow any commit that isn't done via the context manager.", "long_descr": "The aim of this is to ensure that transaction lifetime is strictly controlled which is especially\nimportant in the core scheduler loop. Any commit on the session that is _not_ via this context manager\nwill result in RuntimeError\n\nExample usage:\n\n.. code:: python\n\n    with prohibit_commit(session) as guard:\n        # ... do something with session\n        guard.commit()\n\n        # This would throw an error\n        # session.commit()", "ret": null}, "fn_lc": [[478, 0], [497, 41]], "fn_var_ln": {}, "fn_var_occur": {}, "name": "prohibit_commit", "params": {"session": ""}, "params_descr": {"session": ""}, "params_occur": {"session": [["CommitProhibitorGuard", "session"]]}, "params_p": {"args": [], "kwargs": [], "session": [["sqlalchemy.orm.Session", 0.6666666663643446], ["str", 1.1315687569769297e-10], ["requests.Session", 8.68719891725074e-11], ["sqlalchemy.orm.scoped_session", 7.109784404412422e-11], ["bool", 6.206478274424426e-11], ["Tuple[float, float]", 4.229011541150005e-11]]}, "q_name": "prohibit_commit", "ret_exprs": ["return CommitProhibitorGuard(session)"], "ret_type": "", "ret_type_p": [["str", 0.34309869017432226], ["MutableMapping[str, Any]", 0.09195603640314762], ["Callable[[T], None]", 0.086770542495869]], "variables": {}, "variables_p": {}}, {"docstring": {"func": "Check if the Error is about not being able to acquire lock.", "long_descr": null, "ret": null}, "fn_lc": [[500, 0], [515, 16]], "fn_var_ln": {"db_err_code": [[508, 4], [508, 15]]}, "fn_var_occur": {"db_err_code": [["db_err_code", "getattr", "error", "orig", "None", "error", "orig", "args"]]}, "name": "is_lock_not_available_error", "params": {"error": "sqlalchemy.exc.OperationalError"}, "params_descr": {"error": ""}, "params_occur": {"error": [["db_err_code", "getattr", "error", "orig", "None", "error", "orig", "args"]]}, "params_p": {"args": [], "error": [["dict", 0.2063453226602372], ["Union[object, type]", 0.11029457279553177], ["sqlalchemy.exdeclarative.DeclarativeMeta", 0.09161918503793007]], "kwargs": []}, "q_name": "is_lock_not_available_error", "ret_exprs": ["return True", "return False"], "ret_type": "", "ret_type_p": [["bool", 0.9999999999999999]], "variables": {"db_err_code": ""}, "variables_p": {"db_err_code": [["dict", 0.29670413802828377], ["Dict[str, Union[int, str]]", 0.12051404620945051], ["List[str]", 0.09183161997292454], ["str", 0.0905383735504255], ["datetime.timedelta", 0.08635958120134385]]}}, {"docstring": {"func": "Generates a tuple-in-collection operator to use in ``.filter()``.", "long_descr": "For most SQL backends, this generates a simple ``([col, ...]) IN [condition]``\nclause. This however does not work with MSSQL, where we need to expand to\n``(c1 = v1a AND c2 = v2a ...) OR (c1 = v1b AND c2 = v2b ...) ...`` manually.", "ret": null}, "fn_lc": [[518, 0], [535, 24]], "fn_var_ln": {"clauses": [[532, 4], [532, 11]]}, "fn_var_occur": {"clauses": [["clauses", "and_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"], ["or_", "clauses"]]}, "name": "tuple_in_condition", "params": {"collection": "typing.Iterable[typing.Any]", "columns": "builtins.tuple[sqlalchemy.sql.ColumnElement, ...]"}, "params_descr": {"collection": "", "columns": ""}, "params_occur": {"collection": [["tuple_", "columns", "in_", "collection"], ["clauses", "and_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"]], "columns": [["tuple_", "columns", "in_", "collection"], ["clauses", "and_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"]]}, "params_p": {"args": [], "collection": [["bool", 0.18396809140635967], ["Iterable[\"Entity\"]", 0.18396809140635967], ["Callable", 0.09234096012976818], ["list", 0.08006383910723114], ["Dict[str, int]", 0.0739430191276033], ["str", 0.07200211579999534]], "columns": [["bool", 0.18396809140635967], ["Iterable[\"Entity\"]", 0.18396809140635967], ["Callable", 0.09234096012976818], ["list", 0.08006383910723114], ["Dict[str, int]", 0.0739430191276033], ["str", 0.07200211579999534]], "kwargs": []}, "q_name": "tuple_in_condition", "ret_exprs": ["return tuple_(*columns).in_(collection)", "return false()", "return or_(*clauses)"], "ret_type": "sqlalchemy.sql.expression.ColumnOperators", "ret_type_p": [["bool", 1.0]], "variables": {"clauses": ""}, "variables_p": {"clauses": [["List[List[int]]", 0.12052506250074534], ["frozenset[str]", 0.11018973458066968], ["List[Tuple[int, str]]", 0.09107449101088622], ["List[tuple]", 0.08230580151136624]]}}, {"docstring": {"func": "Generates a tuple-not-in-collection operator to use in ``.filter()``.", "long_descr": "This is similar to ``tuple_in_condition`` except generating ``NOT IN``.", "ret": null}, "fn_lc": [[538, 0], [553, 25]], "fn_var_ln": {"clauses": [[550, 4], [550, 11]]}, "fn_var_occur": {"clauses": [["clauses", "or_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"], ["and_", "clauses"]]}, "name": "tuple_not_in_condition", "params": {"collection": "typing.Iterable[typing.Any]", "columns": "builtins.tuple[sqlalchemy.sql.ColumnElement, ...]"}, "params_descr": {"collection": "", "columns": ""}, "params_occur": {"collection": [["tuple_", "columns", "not_in", "collection"], ["clauses", "or_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"]], "columns": [["tuple_", "columns", "not_in", "collection"], ["clauses", "or_", "c", "v", "c", "v", "zip", "columns", "values", "values", "collection"]]}, "params_p": {"args": [], "collection": [["bool", 0.20313274647554222], ["Iterable[\"Entity\"]", 0.20313274647554222], ["int", 0.14720857564721157], ["str", 0.07985934642501692]], "columns": [["bool", 0.20313274647554222], ["Iterable[\"Entity\"]", 0.20313274647554222], ["int", 0.14720857564721157], ["str", 0.07985934642501692]], "kwargs": []}, "q_name": "tuple_not_in_condition", "ret_exprs": ["return tuple_(*columns).not_in(collection)", "return true()", "return and_(*clauses)"], "ret_type": "sqlalchemy.sql.expression.ColumnOperators", "ret_type_p": [["bool", 0.8102409304918009], ["dict", 0.18975906950819896]], "variables": {"clauses": ""}, "variables_p": {"clauses": [["List[List[int]]", 0.12052506250074534], ["frozenset[str]", 0.11018973458066968], ["List[Tuple[int, str]]", 0.09107449101088622], ["List[tuple]", 0.08230580151136624]]}}], "imports": ["__future__", "annotations", "contextlib", "copy", "datetime", "json", "logging", "typing", "TYPE_CHECKING", "Any", "Generator", "Iterable", "pendulum", "dateutil", "relativedelta", "sqlalchemy", "TIMESTAMP", "PickleType", "and_", "event", "false", "nullsfirst", "or_", "true", "tuple_", "sqlalchemy", "dialects", "mssql", "mysql", "sqlalchemy", "exc", "OperationalError", "sqlalchemy", "sql", "ColumnElement", "sqlalchemy", "sql", "expression", "ColumnOperators", "sqlalchemy", "types", "JSON", "Text", "TypeDecorator", "TypeEngine", "UnicodeText", "airflow", "settings", "airflow", "configuration", "conf", "airflow", "serialization", "enums", "Encoding", "kubernetes", "client", "models", "v1_pod", "V1Pod", "sqlalchemy", "orm", "Query", "Session", "airflow", "utils", "timezone", "make_naive", "airflow", "serialization", "serialized_objects", "BaseSerialization", "airflow", "serialization", "serialized_objects", "BaseSerialization", "kubernetes", "client", "models", "v1_pod", "V1Pod", "airflow", "kubernetes", "pod_generator", "PodGenerator", "airflow", "serialization", "serialized_objects", "BaseSerialization", "airflow", "serialization", "serialized_objects", "BaseSerialization"], "mod_var_ln": {"USE_ROW_LEVEL_LOCKING": [[412, 0], [412, 21]], "log": [[44, 0], [44, 3]], "using_mysql": [[48, 0], [48, 11]], "utc": [[46, 0], [46, 3]]}, "mod_var_occur": {"USE_ROW_LEVEL_LOCKING": [["USE_ROW_LEVEL_LOCKING", "dialect", "name", "dialect", "supports_for_update_of"]], "log": [], "using_mysql": [["using_mysql"]], "utc": [["make_naive", "value", "timezone", "utc"], ["value", "astimezone", "utc"], ["value", "value", "replace", "tzinfo", "utc"], ["value", "value", "astimezone", "utc"]]}, "no_types_annot": {"D": 24, "I": 0, "U": 77}, "session_id": "67X14ziZFGKWFM8jI2JExLd6YsRbEBfdB5JgNim7Xjg", "set": null, "tc": [false, null], "type_annot_cove": 0.24, "typed_seq": "", "untyped_seq": "", "variables": {"USE_ROW_LEVEL_LOCKING": "builtins.bool", "log": "", "using_mysql": "", "utc": ""}, "variables_p": {"USE_ROW_LEVEL_LOCKING": [["int", 0.5085865983496656], ["Dict[str, str]", 0.11206394393351177], ["str", 0.10748775757378358], ["bytes", 0.09119301775784296], ["dict", 0.0905083304254817], ["List[str]", 0.09016035195971445]], "log": [["str", 0.30000000000000004], ["logging.Logger", 0.2], ["bool", 0.1], ["Dict[str, Union[Any, Any, Any]]", 0.1], ["Dict[str, Union[Any, Any, Any, Any]]", 0.1], ["Dict[str, Union[dict, Any, Any, Any, Any]]", 0.1]], "using_mysql": [["bool", 0.49999999999999994], ["str", 0.3], ["int", 0.09999999999999999], ["Optional[str]", 0.09999999999999999]], "utc": [["Dict[str, int]", 0.2954227318993096], ["Exception", 0.17376014893117886], ["Callable", 0.10431926514153726], ["List[float]", 0.08159654194279657], ["List[str]", 0.08036189700757802], ["Dict[str, Union[float, str]]", 0.07347894082247508]]}}}