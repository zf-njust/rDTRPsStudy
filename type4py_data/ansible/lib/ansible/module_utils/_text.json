{"error": null, "response": {"classes": [], "funcs": [{"docstring": {"func": "Make sure that a string is a byte string", "long_descr": null, "ret": "Typically this returns a byte string.  If a nonstring object is\npassed in this may be a different type depending on the strategy\n    specified by nonstring.  This will never return a text string.\n\n.. note:: If passed a byte string, this function does not check that the\n    string is valid in the specified encoding.  If it's important that the\n    byte string is in the specified encoding do::\n\n        encoded_string = to_bytes(to_text(input_string, 'latin-1'), 'utf-8')"}, "fn_lc": [[47, 0], [132, 44]], "fn_var_ln": {"errors": [[106, 12], [106, 18]], "value": [[118, 16], [118, 21]]}, "fn_var_occur": {"errors": [["errors", "None"], ["obj", "encode", "encoding", "errors"], ["to_bytes", "value", "encoding", "errors"]], "value": [["value", "str", "obj"], ["value", "repr", "obj"], ["to_bytes", "value", "encoding", "errors"]]}, "name": "to_bytes", "params": {"encoding": "", "errors": "", "nonstring": "", "obj": ""}, "params_descr": {"encoding": "", "errors": "", "nonstring": "", "obj": "An object to make sure is a byte string.  In most cases this\nwill be either a text string or a byte string.  However, with\n``nonstring='simplerepr'``, this can be used as a traceback-free\nversion of ``str(obj)``."}, "params_occur": {"encoding": [["obj", "encode", "encoding", "errors"], ["to_bytes", "value", "encoding", "errors"]], "errors": [["errors", "None"], ["obj", "encode", "encoding", "errors"], ["to_bytes", "value", "encoding", "errors"]], "nonstring": [["TypeError", "nonstring"]], "obj": [["isinstance", "obj", "binary_type"], ["isinstance", "obj", "text_type"], ["obj", "encode", "encoding", "errors"], ["value", "str", "obj"], ["value", "repr", "obj"]]}, "params_p": {"args": [], "encoding": [["str", 0.5830358687473554], ["bool", 0.19182658634269323], ["IO", 0.1263429608830288], ["int", 0.09879458402692272]], "errors": [["Optional[str]", 0.3034296758307741], ["bool", 0.19143675344688602], ["Optional[Any]", 0.09571837672344301], ["str", 0.09571837672344301]], "kwargs": [], "nonstring": [["str", 0.7944626885669098], ["bool", 0.06989298784469024]], "obj": [["str", 0.27392420761640357], ["int", 0.23108904704232103], ["bool", 0.08638218073553373]]}, "q_name": "to_bytes", "ret_exprs": ["return obj", "return obj.encode(encoding, errors)", "return to_bytes('')", "return obj", "return to_bytes('')", "return to_bytes(value, encoding, errors)"], "ret_type": "", "ret_type_p": [["bool", 0.18819104427517358]], "variables": {"errors": "", "value": ""}, "variables_p": {"errors": [["str", 0.5898895109591396], ["Optional[str]", 0.09296009375215362], ["list", 0.09046909615232705]], "value": [["str", 1.0]]}}, {"docstring": {"func": "Make sure that a string is a text string", "long_descr": null, "ret": "Typically this returns a text string.  If a nonstring object is\npassed in this may be a different type depending on the strategy\nspecified by nonstring.  This will never return a byte string."}, "fn_lc": [[135, 0], [199, 43]], "fn_var_ln": {"errors": [[174, 12], [174, 18]], "value": [[186, 16], [186, 21]]}, "fn_var_occur": {"errors": [["errors", "None"], ["obj", "decode", "encoding", "errors"], ["to_text", "value", "encoding", "errors"]], "value": [["value", "str", "obj"], ["value", "repr", "obj"], ["to_text", "value", "encoding", "errors"]]}, "name": "to_text", "params": {"encoding": "", "errors": "", "nonstring": "", "obj": ""}, "params_descr": {"encoding": "", "errors": "", "nonstring": "", "obj": "An object to make sure is a text string.  In most cases this\nwill be either a text string or a byte string.  However, with\n``nonstring='simplerepr'``, this can be used as a traceback-free\nversion of ``str(obj)``."}, "params_occur": {"encoding": [["obj", "decode", "encoding", "errors"], ["to_text", "value", "encoding", "errors"]], "errors": [["errors", "None"], ["obj", "decode", "encoding", "errors"], ["to_text", "value", "encoding", "errors"]], "nonstring": [["TypeError", "nonstring"]], "obj": [["isinstance", "obj", "text_type"], ["isinstance", "obj", "binary_type"], ["obj", "decode", "encoding", "errors"], ["value", "str", "obj"], ["value", "repr", "obj"]]}, "params_p": {"args": [], "encoding": [["str", 0.5105374801491822], ["int", 0.19555587205304883], ["Union[str, int]", 0.09069042418393526], ["bool", 0.08454211375928576]], "errors": [["str", 0.4132171518877675], ["Optional[str]", 0.23114357421095627], ["Optional[Union[int, str]]", 0.08880325124817559], ["bool", 0.08509295537701725]], "kwargs": [], "nonstring": [["str", 0.3864228967276928]], "obj": [["bool", 0.19339909223570576], ["str", 0.19010784088389293]]}, "q_name": "to_text", "ret_exprs": ["return obj", "return obj.decode(encoding, errors)", "return u''", "return obj", "return u''", "return to_text(value, encoding, errors)"], "ret_type": "", "ret_type_p": [], "variables": {"errors": "", "value": ""}, "variables_p": {"errors": [["str", 0.7054427342279332], ["list", 0.09318683029373262]], "value": [["str", 0.7290725180379818], ["List[str]", 0.09273351526558651]]}}], "imports": ["codecs", "ansible", "module_utils", "six", "PY3", "text_type", "binary_type"], "mod_var_ln": {"HAS_SURROGATEESCAPE": [[44, 4], [44, 23]], "to_native": [[220, 4], [220, 13]]}, "mod_var_occur": {"HAS_SURROGATEESCAPE": [["HAS_SURROGATEESCAPE"], ["HAS_SURROGATEESCAPE"], ["HAS_SURROGATEESCAPE"], ["HAS_SURROGATEESCAPE"]], "to_native": []}, "no_types_annot": {"D": 0, "I": 0, "U": 14}, "session_id": "pIS5lN5L_LITmfvZw_EIxvqoI4gcI__F470je2-ikSc", "set": null, "tc": [false, null], "type_annot_cove": 0.0, "typed_seq": "", "untyped_seq": "", "variables": {"HAS_SURROGATEESCAPE": "", "to_native": ""}, "variables_p": {"HAS_SURROGATEESCAPE": [["int", 0.2], ["dict", 0.1], ["List[int]", 0.1], ["List[List[int]]", 0.1], ["str", 0.1]], "to_native": [["classmethod", 0.2], ["staticmethod", 0.1], ["Set[str]", 0.1], ["str", 0.1]]}}}