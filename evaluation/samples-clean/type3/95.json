{
  "code": "def flatten(layout):\n        Item = namedtuple(\"Item\", [\"layout\", \"r0\", \"c0\", \"r1\", \"c1\"])\n        Grid = namedtuple(\"Grid\", [\"nrows\", \"ncols\", \"items\"])\n\n        def gcd(a, b):\n            a, b = abs(a), abs(b)\n            while b != 0:\n                a, b = b, a % b\n            return a\n\n        def lcm(a, *rest):\n            for b in rest:\n                a = (a*b) // gcd(a, b)\n            return a\n\n        nonempty = lambda child: child.nrows != 0 and child.ncols != 0\n\n        def _flatten(layout):\n            if isinstance(layout, row):\n                children = list(filter(nonempty, map(_flatten, layout.children)))\n                if not children:\n                    return Grid(0, 0, [])\n\n                nrows = lcm(*[ child.nrows for child in children ])\n                ncols = sum([ child.ncols for child in children ])\n\n                items = []\n                offset = 0\n                for child in children:\n                    factor = nrows//child.nrows\n\n                    for (layout, r0, c0, r1, c1) in child.items:\n                        items.append((layout, factor*r0, c0 + offset, factor*r1, c1 + offset))\n\n                    offset += child.ncols\n\n                return Grid(nrows, ncols, items)\n            elif isinstance(layout, col):\n                children = list(filter(nonempty, map(_flatten, layout.children)))\n                if not children:\n                    return Grid(0, 0, [])\n\n                nrows = sum([ child.nrows for child in children ])\n                ncols = lcm(*[ child.ncols for child in children ])\n\n                items = []\n                offset = 0\n                for child in children:\n                    factor = ncols//child.ncols\n\n                    for (layout, r0, c0, r1, c1) in child.items:\n                        items.append((layout, r0 + offset, factor*c0, r1 + offset, factor*c1))\n\n                    offset += child.nrows\n\n                return Grid(nrows, ncols, items)\n            else:\n                return Grid(1, 1, [Item(layout, 0, 0, 1, 1)])\n\n        grid = _flatten(layout)\n\n        children = []\n        for (layout, r0, c0, r1, c1) in grid.items:\n            if layout is not None:\n                children.append((layout, r0, c0, r1 - r0, c1 - c0))\n\n        return GridBox(children=children)",
  "smell": [
    {
      "smell_id": 3,
      "line_no": 60,
      "description": "The variable referenced in the statement has inconsistent types."
    }
  ]
}