{
  "code": "    def post_validate(self, templar):\n        '''\n        we can't tell that everything is of the right type until we have\n        all the variables.  Run basic types (from isa) as well as\n        any _post_validate_<foo> functions.\n        '''\n\n        # save the omit value for later checking\n        omit_value = templar._available_variables.get('omit')\n\n        for (name, attribute) in iteritems(self._valid_attrs):\n\n            if getattr(self, name) is None:\n                if not attribute.required:\n                    continue\n                else:\n                    raise AnsibleParserError(\"the field '%s' is required but was not set\" % name)\n            elif not attribute.always_post_validate and self.__class__.__name__ not in ('Task', 'Handler', 'PlayContext'):\n                # Intermediate objects like Play() won't have their fields validated by\n                # default, as their values are often inherited by other objects and validated\n                # later, so we don't want them to fail out early\n                continue\n\n            try:\n                # Run the post-validator if present. These methods are responsible for\n                # using the given templar to template the values, if required.\n                method = getattr(self, '_post_validate_%s' % name, None)\n                if method:\n                    value = method(attribute, getattr(self, name), templar)\n                elif attribute.isa == 'class':\n                    value = getattr(self, name)\n                else:\n                    # if the attribute contains a variable, template it now\n                    value = templar.template(getattr(self, name))\n\n                # if this evaluated to the omit value, set the value back to\n                # the default specified in the FieldAttribute and move on\n                if omit_value is not None and value == omit_value:\n                    setattr(self, name, attribute.default)\n                    continue\n\n                # and make sure the attribute is of the type it should be\n                if value is not None:\n                    if attribute.isa == 'string':\n                        value = to_text(value)\n                    elif attribute.isa == 'int':\n                        value = int(value)\n                    elif attribute.isa == 'float':\n                        value = float(value)\n                    elif attribute.isa == 'bool':\n                        value = boolean(value)\n                    elif attribute.isa == 'percent':\n                        # special value, which may be an integer or float\n                        # with an optional '%' at the end\n                        if isinstance(value, string_types) and '%' in value:\n                            value = value.replace('%', '')\n                        value = float(value)\n                    elif attribute.isa in ('list', 'barelist'):\n                        if value is None:\n                            value = []\n                        elif not isinstance(value, list):\n                            if isinstance(value, string_types) and attribute.isa == 'barelist':\n                                display.deprecated(\n                                    \"Using comma separated values for a list has been deprecated. \"\n                                    \"You should instead use the correct YAML syntax for lists. \"\n                                )\n                                value = value.split(',')\n                            else:\n                                value = [ value ]\n                        if attribute.listof is not None:\n                            for item in value:\n                                if not isinstance(item, attribute.listof):\n                                    raise AnsibleParserError(\"the field '%s' should be a list of %s,\"\n                                            \" but the item '%s' is a %s\" % (name, attribute.listof, item, type(item)), obj=self.get_ds())\n                                elif attribute.required and attribute.listof == string_types:\n                                    if item is None or item.strip() == \"\":\n                                        raise AnsibleParserError(\"the field '%s' is required, and cannot have empty values\" % (name,), obj=self.get_ds())\n                    elif attribute.isa == 'set':\n                        if value is None:\n                            value = set()\n                        elif not isinstance(value, (list, set)):\n                            if isinstance(value, string_types):\n                                value = value.split(',')\n                            else:\n                                # Making a list like this handles strings of\n                                # text and bytes properly\n                                value = [ value ]\n                        if not isinstance(value, set):\n                            value = set(value)\n                    elif attribute.isa == 'dict':\n                        if value is None:\n                            value = dict()\n                        elif not isinstance(value, dict):\n                            raise TypeError(\"%s is not a dictionary\" % value)\n                    elif attribute.isa == 'class':\n                        if not isinstance(value, attribute.class_type):\n                            raise TypeError(\"%s is not a valid %s (got a %s instead)\" % (name, attribute.class_type, type(value)))\n                        value.post_validate(templar=templar)\n\n                # and assign the massaged value back to the attribute field\n                setattr(self, name, value)\n\n            except (TypeError, ValueError) as e:\n                raise AnsibleParserError(\"the field '%s' has an invalid value (%s), and could not be converted to an %s.\"\n                        \" Error was: %s\" % (name, value, attribute.isa, e), obj=self.get_ds())\n            except (AnsibleUndefinedVariable, UndefinedError) as e:\n                if templar._fail_on_undefined_errors and name != 'name':\n                    raise AnsibleParserError(\"the field '%s' has an invalid value, which appears to include a variable that is undefined.\"\n                            \" The error was: %s\" % (name,e), obj=self.get_ds())\n\n        self._finalized = True",
  "smell": [
    {
      "smell_id": 3,
      "line_no": 101,
      "description": "The variable referenced in the statement has inconsistent types."
    }
  ]
}