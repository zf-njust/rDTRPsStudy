{
  "code": "def parse_single_constraint(constraint):  # type: (str) -> VersionConstraint\n    m = re.match(r\"(?i)^v?[xX*](\\.[xX*])*$\", constraint)\n    if m:\n        return VersionRange()\n\n    # Tilde range\n    m = TILDE_CONSTRAINT.match(constraint)\n    if m:\n        version = Version.parse(m.group(1))\n\n        high = version.stable.next_minor\n        if len(m.group(1).split(\".\")) == 1:\n            high = version.stable.next_major\n\n        return VersionRange(\n            version, high, include_min=True, always_include_max_prerelease=True\n        )\n\n    # PEP 440 Tilde range (~=)\n    m = TILDE_PEP440_CONSTRAINT.match(constraint)\n    if m:\n        precision = 1\n        if m.group(3):\n            precision += 1\n\n            if m.group(4):\n                precision += 1\n\n        version = Version.parse(m.group(1))\n\n        if precision == 2:\n            low = version\n            high = version.stable.next_major\n        else:\n            low = Version(version.major, version.minor, 0)\n            high = version.stable.next_minor\n\n        return VersionRange(\n            low, high, include_min=True, always_include_max_prerelease=True\n        )\n\n    # Caret range\n    m = CARET_CONSTRAINT.match(constraint)\n    if m:\n        version = Version.parse(m.group(1))\n\n        return VersionRange(\n            version,\n            version.next_breaking,\n            include_min=True,\n            always_include_max_prerelease=True,\n        )\n\n    # X Range\n    m = X_CONSTRAINT.match(constraint)\n    if m:\n        op = m.group(1)\n        major = int(m.group(2))\n        minor = m.group(3)\n\n        if minor is not None:\n            version = Version(major, int(minor), 0)\n\n            result = VersionRange(\n                version,\n                version.next_minor,\n                include_min=True,\n                always_include_max_prerelease=True,\n            )\n        else:\n            if major == 0:\n                result = VersionRange(max=Version(1, 0, 0))\n            else:\n                version = Version(major, 0, 0)\n\n                result = VersionRange(\n                    version,\n                    version.next_major,\n                    include_min=True,\n                    always_include_max_prerelease=True,\n                )\n\n        if op == \"!=\":\n            result = VersionRange().difference(result)\n\n        return result\n\n    # Basic comparator\n    m = BASIC_CONSTRAINT.match(constraint)\n    if m:\n        op = m.group(1)\n        version = m.group(2)\n\n        if version == \"dev\":\n            version = \"0.0-dev\"\n\n        try:\n            version = Version.parse(version)\n        except ValueError:\n            raise ValueError(\n                \"Could not parse version constraint: {}\".format(constraint)\n            )\n\n        if op == \"<\":\n            return VersionRange(max=version)\n        elif op == \"<=\":\n            return VersionRange(max=version, include_max=True)\n        elif op == \">\":\n            return VersionRange(min=version)\n        elif op == \">=\":\n            return VersionRange(min=version, include_min=True)\n        elif op == \"!=\":\n            return VersionUnion(VersionRange(max=version), VersionRange(min=version))\n        else:\n            return version\n\n    raise ValueError(\"Could not parse version constraint: {}\".format(constraint))",
  "smell": [
    {
      "smell_id": 3,
      "line_no": 84,
      "description": "The variable referenced in the statement has inconsistent types."
    }
  ]
}