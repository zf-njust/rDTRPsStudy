{
  "code": "def grid(children=[], sizing_mode=None, nrows=None, ncols=None):\n    \"\"\"\n    Conveniently create a grid of layoutable objects.\n\n    Grids are created by using ``GridBox`` model. This gives the most control over\n    the layout of a grid, but is also tedious and may result in unreadable code in\n    practical applications. ``grid()`` function remedies this by reducing the level\n    of control, but in turn providing a more convenient API.\n\n    Supported patterns:\n\n    1. Nested lists of layoutable objects. Assumes the top-level list represents\n       a column and alternates between rows and columns in subsequent nesting\n       levels. One can use ``None`` for padding purpose.\n\n       >>> grid([p1, [[p2, p3], p4]])\n       GridBox(children=[\n           (p1, 0, 0, 1, 2),\n           (p2, 1, 0, 1, 1),\n           (p3, 2, 0, 1, 1),\n           (p4, 1, 1, 2, 1),\n       ])\n\n    2. Nested ``Row`` and ``Column`` instances. Similar to the first pattern, just\n       instead of using nested lists, it uses nested ``Row`` and ``Column`` models.\n       This can be much more readable that the former. Note, however, that only\n       models that don't have ``sizing_mode`` set are used.\n\n       >>> grid(column(p1, row(column(p2, p3), p4)))\n       GridBox(children=[\n           (p1, 0, 0, 1, 2),\n           (p2, 1, 0, 1, 1),\n           (p3, 2, 0, 1, 1),\n           (p4, 1, 1, 2, 1),\n       ])\n\n    3. Flat list of layoutable objects. This requires ``nrows`` and/or ``ncols`` to\n       be set. The input list will be rearranged into a 2D array accordingly. One\n       can use ``None`` for padding purpose.\n\n       >>> grid([p1, p2, p3, p4], ncols=2)\n       GridBox(children=[\n           (p1, 0, 0, 1, 1),\n           (p2, 0, 1, 1, 1),\n           (p3, 1, 0, 1, 1),\n           (p4, 1, 1, 1, 1),\n       ])\n\n    \"\"\"\n    row = namedtuple(\"row\", [\"children\"])\n    col = namedtuple(\"col\", [\"children\"])\n\n    def flatten(layout):\n        Item = namedtuple(\"Item\", [\"layout\", \"r0\", \"c0\", \"r1\", \"c1\"])\n        Grid = namedtuple(\"Grid\", [\"nrows\", \"ncols\", \"items\"])\n\n        def gcd(a, b):\n            a, b = abs(a), abs(b)\n            while b != 0:\n                a, b = b, a % b\n            return a\n\n        def lcm(a, *rest):\n            for b in rest:\n                a = (a*b) // gcd(a, b)\n            return a\n\n        nonempty = lambda child: child.nrows != 0 and child.ncols != 0\n\n        def _flatten(layout):\n            if isinstance(layout, row):\n                children = list(filter(nonempty, map(_flatten, layout.children)))\n                if not children:\n                    return Grid(0, 0, [])\n\n                nrows = lcm(*[ child.nrows for child in children ])\n                ncols = sum([ child.ncols for child in children ])\n\n                items = []\n                offset = 0\n                for child in children:\n                    factor = nrows//child.nrows\n\n                    for (layout, r0, c0, r1, c1) in child.items:\n                        items.append((layout, factor*r0, c0 + offset, factor*r1, c1 + offset))\n\n                    offset += child.ncols\n\n                return Grid(nrows, ncols, items)\n            elif isinstance(layout, col):\n                children = list(filter(nonempty, map(_flatten, layout.children)))\n                if not children:\n                    return Grid(0, 0, [])\n\n                nrows = sum([ child.nrows for child in children ])\n                ncols = lcm(*[ child.ncols for child in children ])\n\n                items = []\n                offset = 0\n                for child in children:\n                    factor = ncols//child.ncols\n\n                    for (layout, r0, c0, r1, c1) in child.items:\n                        items.append((layout, r0 + offset, factor*c0, r1 + offset, factor*c1))\n\n                    offset += child.nrows\n\n                return Grid(nrows, ncols, items)\n            else:\n                return Grid(1, 1, [Item(layout, 0, 0, 1, 1)])\n\n        grid = _flatten(layout)\n\n        children = []\n        for (layout, r0, c0, r1, c1) in grid.items:\n            if layout is not None:\n                children.append((layout, r0, c0, r1 - r0, c1 - c0))\n\n        return GridBox(children=children)\n\n    if isinstance(children, list):\n        if nrows is not None or ncols is not None:\n            N = len(children)\n            if ncols is None:\n                ncols = math.ceil(N/nrows)\n            layout = col([ row(children[i:i+ncols]) for i in range(0, N, ncols) ])\n        else:\n            def traverse(children, level=0):\n                if isinstance(children, list):\n                    container = col if level % 2 == 0 else row\n                    return container([ traverse(child, level+1) for child in children ])\n                else:\n                    return children\n\n            layout = traverse(children)\n    elif isinstance(children, LayoutDOM):\n        def is_usable(child):\n            return _has_auto_sizing(child) and child.spacing == 0\n\n        def traverse(item, top_level=False):\n            if isinstance(item, Box) and (top_level or is_usable(item)):\n                container = col if isinstance(item, Column) else row\n                return container(list(map(traverse, item.children)))\n            else:\n                return item\n\n        layout = traverse(children, top_level=True)\n    elif isinstance(children, string_types):\n        raise NotImplementedError\n    else:\n        raise ValueError(\"expected a list, string or model\")\n\n    grid = flatten(layout)\n\n    if sizing_mode is not None:\n        grid.sizing_mode = sizing_mode\n\n        for child in grid.children:\n            layout = child[0]\n            if _has_auto_sizing(layout):\n                layout.sizing_mode = sizing_mode\n\n    return grid",
  "smell": [
    {
      "smell_id": 3,
      "line_no": 112,
      "description": "The variable referenced in the statement has inconsistent types."
    }
  ]
}