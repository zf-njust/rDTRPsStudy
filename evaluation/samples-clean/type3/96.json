{
  "code": "def invoke(self, args):\n        '''\n\n        '''\n\n        # protect this import inside a function so that \"bokeh info\" can work\n        # even if Tornado is not installed\n        from bokeh.server.server import Server\n\n        argvs = { f : args.args for f in args.files}\n        applications = build_single_handler_applications(args.files, argvs)\n\n        log_level = getattr(logging, args.log_level.upper())\n        basicConfig(level=log_level, format=args.log_format, filename=args.log_file)\n\n        if len(applications) == 0:\n            # create an empty application by default\n            applications['/'] = Application()\n\n        # rename args to be compatible with Server\n        if args.keep_alive is not None:\n            args.keep_alive_milliseconds = args.keep_alive\n\n        if args.check_unused_sessions is not None:\n            args.check_unused_sessions_milliseconds = args.check_unused_sessions\n\n        if args.unused_session_lifetime is not None:\n            args.unused_session_lifetime_milliseconds = args.unused_session_lifetime\n\n        if args.stats_log_frequency is not None:\n            args.stats_log_frequency_milliseconds = args.stats_log_frequency\n\n        if args.mem_log_frequency is not None:\n            args.mem_log_frequency_milliseconds = args.mem_log_frequency\n\n        server_kwargs = { key: getattr(args, key) for key in ['port',\n                                                              'address',\n                                                              'allow_websocket_origin',\n                                                              'num_procs',\n                                                              'prefix',\n                                                              'index',\n                                                              'keep_alive_milliseconds',\n                                                              'check_unused_sessions_milliseconds',\n                                                              'unused_session_lifetime_milliseconds',\n                                                              'stats_log_frequency_milliseconds',\n                                                              'mem_log_frequency_milliseconds',\n                                                              'use_xheaders',\n                                                              'websocket_max_message_size',\n                                                            ]\n                          if getattr(args, key, None) is not None }\n\n        server_kwargs['sign_sessions'] = settings.sign_sessions()\n        server_kwargs['secret_key'] = settings.secret_key_bytes()\n        server_kwargs['generate_session_ids'] = True\n        if args.session_ids is None:\n            # no --session-ids means use the env vars\n            pass\n        elif args.session_ids == 'unsigned':\n            server_kwargs['sign_sessions'] = False\n        elif args.session_ids == 'signed':\n            server_kwargs['sign_sessions'] = True\n        elif args.session_ids == 'external-signed':\n            server_kwargs['sign_sessions'] = True\n            server_kwargs['generate_session_ids'] = False\n        else:\n            raise RuntimeError(\"argparse should have filtered out --session-ids mode \" +\n                               args.session_ids)\n\n        if server_kwargs['sign_sessions'] and not server_kwargs['secret_key']:\n            die(\"To sign sessions, the BOKEH_SECRET_KEY environment variable must be set; \" +\n                \"the `bokeh secret` command can be used to generate a new key.\")\n\n        server_kwargs['use_index'] = not args.disable_index\n        server_kwargs['redirect_root'] = not args.disable_index_redirect\n        server_kwargs['autoreload'] = args.dev is not None\n\n        def find_autoreload_targets(app_path):\n            path = os.path.abspath(app_path)\n            if not os.path.isdir(path):\n                return\n\n            for path, subdirs, files in os.walk(path):\n                for name in files:\n                    if (fnmatch(name, '*.html') or\n                        fnmatch(name, '*.css') or\n                        fnmatch(name, '*.yaml')):\n                        log.info(\"Watching: \" + os.path.join(path, name))\n                        watch(os.path.join(path, name))\n\n        def add_optional_autoreload_files(file_list):\n            for filen in file_list:\n                if os.path.isdir(filen):\n                    log.warning(\"Cannot watch directory \" + filen)\n                    continue\n                log.info(\"Watching: \" + filen)\n                watch(filen)\n\n        if server_kwargs['autoreload']:\n            if len(applications.keys()) != 1:\n                die(\"--dev can only support a single app.\")\n            if server_kwargs['num_procs'] != 1:\n                log.info(\"Running in --dev mode. --num-procs is limited to 1.\")\n                server_kwargs['num_procs'] = 1\n\n            find_autoreload_targets(args.files[0])\n            add_optional_autoreload_files(args.dev)\n\n        with report_server_init_errors(**server_kwargs):\n            server = Server(applications, **server_kwargs)\n\n            if args.show:\n\n                # we have to defer opening in browser until we start up the server\n                def show_callback():\n                    for route in applications.keys():\n                        server.show(route)\n\n                server.io_loop.add_callback(show_callback)\n\n            address_string = 'localhost'\n            if server.address is not None and server.address != '':\n                address_string = server.address\n\n            for route in sorted(applications.keys()):\n                url = \"http://%s:%d%s%s\" % (address_string, server.port, server.prefix, route)\n                log.info(\"Bokeh app running at: %s\" % url)\n\n            log.info(\"Starting Bokeh server with process id: %d\" % os.getpid())\n            server.run_until_shutdown()",
  "smell": [
    {
      "smell_id": 3,
      "line_no": 125,
      "description": "The variable referenced in the statement has inconsistent types."
    }
  ]
}