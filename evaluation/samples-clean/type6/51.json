{
  "code": "def _cat_compare_op(op):\n    def f(self, other):\n        # On python2, you can usually compare any type to any type, and Categoricals can be\n        # seen as a custom type, but having different results depending whether categories are\n        # the same or not is kind of insane, so be a bit stricter here and use the python3 idea\n        # of comparing only things of equal type.\n        if not self.ordered:\n            if op in ['__lt__', '__gt__','__le__','__ge__']:\n                raise TypeError(\"Unordered Categoricals can only compare equality or not\")\n        if isinstance(other, Categorical):\n            # Two Categoricals can only be be compared if the categories are the same\n            if (len(self.categories) != len(other.categories)) or \\\n                    not ((self.categories == other.categories).all()):\n                raise TypeError(\"Categoricals can only be compared if 'categories' are the same\")\n            if not (self.ordered == other.ordered):\n                raise TypeError(\"Categoricals can only be compared if 'ordered' is the same\")\n            na_mask = (self._codes == -1) | (other._codes == -1)\n            f = getattr(self._codes, op)\n            ret = f(other._codes)\n            if na_mask.any():\n                # In other series, the leads to False, so do that here too\n                ret[na_mask] = False\n            return ret\n\n        # Numpy-1.9 and earlier may convert a scalar to a zerodim array during\n        # comparison operation when second arg has higher priority, e.g.\n        #\n        #     cat[0] < cat\n        #\n        # With cat[0], for example, being ``np.int64(1)`` by the time it gets\n        # into this function would become ``np.array(1)``.\n        other = lib.item_from_zerodim(other)\n        if lib.isscalar(other):\n            if other in self.categories:\n                i = self.categories.get_loc(other)\n                return getattr(self._codes, op)(i)\n            else:\n                if op == '__eq__':\n                    return np.repeat(False, len(self))\n                elif op == '__ne__':\n                    return np.repeat(True, len(self))\n                else:\n                    msg  = \"Cannot compare a Categorical for op {op} with a scalar, \" \\\n                           \"which is not a category.\"\n                    raise TypeError(msg.format(op=op))\n        else:\n\n            # allow categorical vs object dtype array comparisons for equality\n            # these are only positional comparisons\n            if op in ['__eq__','__ne__']:\n                return getattr(np.array(self),op)(np.array(other))\n\n            msg = \"Cannot compare a Categorical for op {op} with type {typ}. If you want to \\n\" \\\n                  \"compare values, use 'np.asarray(cat) <op> other'.\"\n            raise TypeError(msg.format(op=op,typ=type(other)))\n\n    f.__name__ = op\n\n    return f",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 51,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}