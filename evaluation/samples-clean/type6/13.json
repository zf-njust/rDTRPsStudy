{
  "code": "def fetch_initial_state_data(user_profile, event_types, queue_id,\n                             include_subscribers=True):\n    # type: (UserProfile, Optional[Iterable[str]], str, bool) -> Dict[str, Any]\n    state = {'queue_id': queue_id}  # type: Dict[str, Any]\n\n    if event_types is None:\n        # return True always\n        want = always_want  # type: Callable[[str], bool]\n    else:\n        want = set(event_types).__contains__\n\n    if want('alert_words'):\n        state['alert_words'] = user_alert_words(user_profile)\n\n    if want('custom_profile_fields'):\n        fields = custom_profile_fields_for_realm(user_profile.realm.id)\n        state['custom_profile_fields'] = [f.as_dict() for f in fields]\n\n    if want('attachments'):\n        state['attachments'] = user_attachments(user_profile)\n\n    if want('upload_quota'):\n        state['upload_quota'] = user_profile.quota\n\n    if want('total_uploads_size'):\n        state['total_uploads_size'] = get_total_uploads_size_for_user(user_profile)\n\n    if want('hotspots'):\n        state['hotspots'] = get_next_hotspots(user_profile)\n\n    if want('message'):\n        # The client should use get_messages() to fetch messages\n        # starting with the max_message_id.  They will get messages\n        # newer than that ID via get_events()\n        messages = Message.objects.filter(usermessage__user_profile=user_profile).order_by('-id')[:1]\n        if messages:\n            state['max_message_id'] = messages[0].id\n        else:\n            state['max_message_id'] = -1\n\n    if want('muted_topics'):\n        state['muted_topics'] = get_topic_mutes(user_profile)\n\n    if want('pointer'):\n        state['pointer'] = user_profile.pointer\n\n    if want('presence'):\n        state['presences'] = get_status_dict(user_profile)\n\n    if want('realm'):\n        for property_name in Realm.property_types:\n            state['realm_' + property_name] = getattr(user_profile.realm, property_name)\n\n        # Most state is handled via the property_types framework;\n        # these manual entries are for those realm settings that don't\n        # fit into that framework.\n        state['realm_authentication_methods'] = user_profile.realm.authentication_methods_dict()\n        state['realm_allow_message_editing'] = user_profile.realm.allow_message_editing\n        state['realm_message_content_edit_limit_seconds'] = user_profile.realm.message_content_edit_limit_seconds\n        state['realm_icon_url'] = realm_icon_url(user_profile.realm)\n        state['realm_icon_source'] = user_profile.realm.icon_source\n        state['max_icon_file_size'] = settings.MAX_ICON_FILE_SIZE\n        state['realm_bot_domain'] = user_profile.realm.get_bot_domain()\n        state['realm_uri'] = user_profile.realm.uri\n        state['realm_presence_disabled'] = user_profile.realm.presence_disabled\n        state['realm_show_digest_email'] = user_profile.realm.show_digest_email\n        state['realm_is_zephyr_mirror_realm'] = user_profile.realm.is_zephyr_mirror_realm\n        state['realm_email_auth_enabled'] = email_auth_enabled(user_profile.realm)\n        state['realm_password_auth_enabled'] = password_auth_enabled(user_profile.realm)\n        if user_profile.realm.notifications_stream and not user_profile.realm.notifications_stream.deactivated:\n            notifications_stream = user_profile.realm.notifications_stream\n            state['realm_notifications_stream_id'] = notifications_stream.id\n        else:\n            state['realm_notifications_stream_id'] = -1\n\n    if want('realm_domains'):\n        state['realm_domains'] = get_realm_domains(user_profile.realm)\n\n    if want('realm_emoji'):\n        state['realm_emoji'] = user_profile.realm.get_emoji()\n\n    if want('realm_filters'):\n        state['realm_filters'] = realm_filters_for_realm(user_profile.realm_id)\n\n    if want('realm_user'):\n        state['realm_users'] = get_realm_user_dicts(user_profile)\n        state['avatar_source'] = user_profile.avatar_source\n        state['avatar_url_medium'] = avatar_url(user_profile, medium=True)\n        state['avatar_url'] = avatar_url(user_profile)\n        state['can_create_streams'] = user_profile.can_create_streams()\n        state['cross_realm_bots'] = list(get_cross_realm_dicts())\n        state['is_admin'] = user_profile.is_realm_admin\n        state['user_id'] = user_profile.id\n        state['enter_sends'] = user_profile.enter_sends\n        state['email'] = user_profile.email\n        state['full_name'] = user_profile.full_name\n\n    if want('realm_bot'):\n        state['realm_bots'] = get_owned_bot_dicts(user_profile)\n\n    # This does not yet have an apply_event counterpart, since currently,\n    # new entries for EMBEDDED_BOTS can only be added directly in the codebase.\n    if want('realm_embedded_bots'):\n        state['realm_embedded_bots'] = list(bot.name for bot in EMBEDDED_BOTS)\n\n    if want('subscription'):\n        subscriptions, unsubscribed, never_subscribed = gather_subscriptions_helper(\n            user_profile, include_subscribers=include_subscribers)\n        state['subscriptions'] = subscriptions\n        state['unsubscribed'] = unsubscribed\n        state['never_subscribed'] = never_subscribed\n\n    if want('update_message_flags') and want('message'):\n        # Keeping unread_msgs updated requires both message flag updates and\n        # message updates. This is due to the fact that new messages will not\n        # generate a flag update so we need to use the flags field in the\n        # message event.\n        state['raw_unread_msgs'] = get_raw_unread_data(user_profile)\n\n    if want('stream'):\n        state['streams'] = do_get_streams(user_profile)\n    if want('default_streams'):\n        state['realm_default_streams'] = streams_to_dicts_sorted(get_default_streams_for_realm(user_profile.realm_id))\n\n    if want('update_display_settings'):\n        for prop in UserProfile.property_types:\n            state[prop] = getattr(user_profile, prop)\n        state['emojiset_choices'] = user_profile.emojiset_choices()\n        state['autoscroll_forever'] = user_profile.autoscroll_forever\n\n    if want('update_global_notifications'):\n        for notification in UserProfile.notification_setting_types:\n            state[notification] = getattr(user_profile, notification)\n        state['default_desktop_notifications'] = user_profile.default_desktop_notifications\n\n    if want('zulip_version'):\n        state['zulip_version'] = ZULIP_VERSION\n\n    return state",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 127,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}