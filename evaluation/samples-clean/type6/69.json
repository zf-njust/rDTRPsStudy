{
  "code": "def _fit(self, X):\n        X = check_array(X, accept_sparse='csr', copy=self.copy)\n        threshold = self.threshold\n        branching_factor = self.branching_factor\n\n        if branching_factor <= 1:\n            raise ValueError(\"Branching_factor should be greater than one.\")\n        n_samples, n_features = X.shape\n\n        # If partial_fit is called for the first time or fit is called, we\n        # start a new tree.\n        partial_fit = getattr(self, 'partial_fit_')\n        has_root = getattr(self, 'root_', None)\n        if getattr(self, 'fit_') or (partial_fit and not has_root):\n            # The first root is the leaf. Manipulate this object throughout.\n            self.root_ = _CFNode(threshold, branching_factor, is_leaf=True,\n                                 n_features=n_features)\n\n            # To enable getting back subclusters.\n            self.dummy_leaf_ = _CFNode(threshold, branching_factor,\n                                       is_leaf=True, n_features=n_features)\n            self.dummy_leaf_.next_leaf_ = self.root_\n            self.root_.prev_leaf_ = self.dummy_leaf_\n\n        # Cannot vectorize. Enough to convince to use cython.\n        if not sparse.issparse(X):\n            iter_func = iter\n        else:\n            iter_func = _iterate_sparse_X\n\n        for sample in iter_func(X):\n            subcluster = _CFSubcluster(linear_sum=sample)\n            split = self.root_.insert_cf_subcluster(subcluster)\n\n            if split:\n                new_subcluster1, new_subcluster2 = _split_node(\n                    self.root_, threshold, branching_factor)\n                del self.root_\n                self.root_ = _CFNode(threshold, branching_factor,\n                                     is_leaf=False,\n                                     n_features=n_features)\n                self.root_.append_subcluster(new_subcluster1)\n                self.root_.append_subcluster(new_subcluster2)\n\n        centroids = np.concatenate([\n            leaf.centroids_ for leaf in self._get_leaves()])\n        self.subcluster_centers_ = centroids\n\n        self._global_clustering(X)\n        return self",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 14,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}