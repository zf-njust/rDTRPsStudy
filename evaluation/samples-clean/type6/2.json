{
  "code": "def decode(obj):\n    \"\"\"\n    Decoder for deserializing numpy data types.\n    \"\"\"\n\n    typ = obj.get('typ')\n    if typ is None:\n        return obj\n    elif typ == 'timestamp':\n        return Timestamp(obj['value'], tz=obj['tz'], offset=obj['offset'])\n    elif typ == 'period':\n        return Period(ordinal=obj['ordinal'], freq=obj['freq'])\n    elif typ == 'index':\n        dtype = dtype_for(obj['dtype'])\n        data = unconvert(obj['data'], dtype,\n                         obj.get('compress'))\n        return globals()[obj['klass']](data, dtype=dtype, name=obj['name'])\n    elif typ == 'multi_index':\n        dtype = dtype_for(obj['dtype'])\n        data = unconvert(obj['data'], dtype,\n                         obj.get('compress'))\n        data = [tuple(x) for x in data]\n        return globals()[obj['klass']].from_tuples(data, names=obj['names'])\n    elif typ == 'period_index':\n        data = unconvert(obj['data'], np.int64, obj.get('compress'))\n        d = dict(name=obj['name'], freq=obj['freq'])\n        return globals()[obj['klass']](data, **d)\n    elif typ == 'datetime_index':\n        data = unconvert(obj['data'], np.int64, obj.get('compress'))\n        d = dict(name=obj['name'], freq=obj['freq'], verify_integrity=False)\n        result = globals()[obj['klass']](data, **d)\n        tz = obj['tz']\n\n        # reverse tz conversion\n        if tz is not None:\n            result = result.tz_localize('UTC').tz_convert(tz)\n        return result\n\n    elif typ == 'series':\n        dtype = dtype_for(obj['dtype'])\n        index = obj['index']\n        return globals()[obj['klass']](unconvert(obj['data'], dtype,\n                                                 obj['compress']),\n                                       index=index,\n                                       dtype=dtype,\n                                       name=obj['name'])\n    elif typ == 'block_manager':\n        axes = obj['axes']\n\n        def create_block(b):\n            values = unconvert(b['values'], dtype_for(b['dtype']),\n                               b['compress']).reshape(b['shape'])\n\n            # locs handles duplicate column names, and should be used instead of items; see GH 9618\n            if 'locs' in b:\n                placement = b['locs']\n            else:\n                placement = axes[0].get_indexer(b['items'])\n            return make_block(values=values,\n                              klass=getattr(internals, b['klass']),\n                              placement=placement)\n\n        blocks = [create_block(b) for b in obj['blocks']]\n        return globals()[obj['klass']](BlockManager(blocks, axes))\n    elif typ == 'datetime':\n        return parse(obj['data'])\n    elif typ == 'datetime64':\n        return np.datetime64(parse(obj['data']))\n    elif typ == 'date':\n        return parse(obj['data']).date()\n    elif typ == 'timedelta':\n        return timedelta(*obj['data'])\n    elif typ == 'timedelta64':\n        return np.timedelta64(int(obj['data']))\n    #elif typ == 'sparse_series':\n    #    dtype = dtype_for(obj['dtype'])\n    #    return globals()[obj['klass']](\n    #        unconvert(obj['sp_values'], dtype, obj['compress']),\n    #        sparse_index=obj['sp_index'], index=obj['index'],\n    #        fill_value=obj['fill_value'], kind=obj['kind'], name=obj['name'])\n    #elif typ == 'sparse_dataframe':\n    #    return globals()[obj['klass']](\n    #        obj['data'], columns=obj['columns'],\n    #        default_fill_value=obj['default_fill_value'],\n    #        default_kind=obj['default_kind']\n    #    )\n    #elif typ == 'sparse_panel':\n    #    return globals()[obj['klass']](\n    #        obj['data'], items=obj['items'],\n    #        default_fill_value=obj['default_fill_value'],\n    #        default_kind=obj['default_kind'])\n    elif typ == 'block_index':\n        return globals()[obj['klass']](obj['length'], obj['blocs'],\n                                       obj['blengths'])\n    elif typ == 'int_index':\n        return globals()[obj['klass']](obj['length'], obj['indices'])\n    elif typ == 'ndarray':\n        return unconvert(obj['data'], np.typeDict[obj['dtype']],\n                         obj.get('compress')).reshape(obj['shape'])\n    elif typ == 'np_scalar':\n        if obj.get('sub_typ') == 'np_complex':\n            return c2f(obj['real'], obj['imag'], obj['dtype'])\n        else:\n            dtype = dtype_for(obj['dtype'])\n            try:\n                return dtype(obj['data'])\n            except:\n                return dtype.type(obj['data'])\n    elif typ == 'np_complex':\n        return complex(obj['real'] + '+' + obj['imag'] + 'j')\n    elif isinstance(obj, (dict, list, set)):\n        return obj\n    else:\n        return obj",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 60,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}