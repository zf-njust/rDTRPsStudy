{
  "code": "def test_ufunc_override_rop_simple(self):\n        # Check parts of the binary op overriding behavior in an\n        # explicit test case that is easier to understand.\n        class SomeClass(object):\n            def __numpy_ufunc__(self, *a, **kw):\n                return \"ufunc\"\n\n            def __mul__(self, other):\n                return 123\n\n            def __rmul__(self, other):\n                return 321\n\n            def __rsub__(self, other):\n                return \"no subs for me\"\n\n            def __gt__(self, other):\n                return \"yep\"\n\n            def __lt__(self, other):\n                return \"nope\"\n\n        class SomeClass2(SomeClass, np.ndarray):\n            def __numpy_ufunc__(self, ufunc, method, i, inputs, **kw):\n                if ufunc is np.multiply or ufunc is np.bitwise_and:\n                    return \"ufunc\"\n                else:\n                    inputs = list(inputs)\n                    if i < len(inputs):\n                        inputs[i] = np.asarray(self)\n                    func = getattr(ufunc, method)\n                    if ('out' in kw) and (kw['out'] is not None):\n                        kw['out'] = np.asarray(kw['out'])\n                    r = func(*inputs, **kw)\n                    x = self.__class__(r.shape, dtype=r.dtype)\n                    x[...] = r\n                    return x\n\n        class SomeClass3(SomeClass2):\n            def __rsub__(self, other):\n                return \"sub for me\"\n\n        arr = np.array([0])\n        obj = SomeClass()\n        obj2 = SomeClass2((1,), dtype=np.int_)\n        obj2[0] = 9\n        obj3 = SomeClass3((1,), dtype=np.int_)\n        obj3[0] = 4\n\n        # obj is first, so should get to define outcome.\n        assert_equal(obj * arr, 123)\n        # obj is second, but has __numpy_ufunc__ and defines __rmul__.\n        assert_equal(arr * obj, 321)\n        # obj is second, but has __numpy_ufunc__ and defines __rsub__.\n        assert_equal(arr - obj, \"no subs for me\")\n        # obj is second, but has __numpy_ufunc__ and defines __lt__.\n        assert_equal(arr > obj, \"nope\")\n        # obj is second, but has __numpy_ufunc__ and defines __gt__.\n        assert_equal(arr < obj, \"yep\")\n        # Called as a ufunc, obj.__numpy_ufunc__ is used.\n        assert_equal(np.multiply(arr, obj), \"ufunc\")\n        # obj is second, but has __numpy_ufunc__ and defines __rmul__.\n        arr *= obj\n        assert_equal(arr, 321)\n\n        # obj2 is an ndarray subclass, so CPython takes care of the same rules.\n        assert_equal(obj2 * arr, 123)\n        assert_equal(arr * obj2, 321)\n        assert_equal(arr - obj2, \"no subs for me\")\n        assert_equal(arr > obj2, \"nope\")\n        assert_equal(arr < obj2, \"yep\")\n        # Called as a ufunc, obj2.__numpy_ufunc__ is called.\n        assert_equal(np.multiply(arr, obj2), \"ufunc\")\n        # Also when the method is not overridden.\n        assert_equal(arr & obj2, \"ufunc\")\n        arr *= obj2\n        assert_equal(arr, 321)\n\n        obj2 += 33\n        assert_equal(obj2[0], 42)\n        assert_equal(obj2.sum(), 42)\n        assert_(isinstance(obj2, SomeClass2))\n\n        # Obj3 is subclass that defines __rsub__.  CPython calls it.\n        assert_equal(arr - obj3, \"sub for me\")\n        assert_equal(obj2 - obj3, \"sub for me\")\n        # obj3 is a subclass that defines __rmul__.  CPython calls it.\n        assert_equal(arr * obj3, 321)\n        # But not here, since obj3.__rmul__ is obj2.__rmul__.\n        assert_equal(obj2 * obj3, 123)\n        # And of course, here obj3.__mul__ should be called.\n        assert_equal(obj3 * obj2, 123)\n        # obj3 defines __numpy_ufunc__ but obj3.__radd__ is obj2.__radd__.\n        # (and both are just ndarray.__radd__); see #4815.\n        res = obj2 + obj3\n        assert_equal(res, 46)\n        assert_(isinstance(res, SomeClass2))\n        # Since obj3 is a subclass, it should have precedence, like CPython\n        # would give, even though obj2 has __numpy_ufunc__ and __radd__.\n        # See gh-4815 and gh-5747.\n        res = obj3 + obj2\n        assert_equal(res, 46)\n        assert_(isinstance(res, SomeClass3))",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 31,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}