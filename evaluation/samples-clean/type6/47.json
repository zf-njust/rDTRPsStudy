{
  "code": "def main():\n    global_config = config['Global']\n    # build dataloader\n    valid_dataloader = build_dataloader(config, 'Eval', device, logger)\n\n    # build post process\n    post_process_class = build_post_process(config['PostProcess'],\n                                            global_config)\n\n    # build model\n    # for rec algorithm\n    if hasattr(post_process_class, 'character'):\n        char_num = len(getattr(post_process_class, 'character'))\n        if config['Architecture'][\"algorithm\"] in [\"Distillation\",\n                                                   ]:  # distillation model\n            for key in config['Architecture'][\"Models\"]:\n                if config['Architecture']['Models'][key]['Head'][\n                        'name'] == 'MultiHead':  # for multi head\n                    out_channels_list = {}\n                    if config['PostProcess'][\n                            'name'] == 'DistillationSARLabelDecode':\n                        char_num = char_num - 2\n                    out_channels_list['CTCLabelDecode'] = char_num\n                    out_channels_list['SARLabelDecode'] = char_num + 2\n                    config['Architecture']['Models'][key]['Head'][\n                        'out_channels_list'] = out_channels_list\n                else:\n                    config['Architecture'][\"Models\"][key][\"Head\"][\n                        'out_channels'] = char_num\n        elif config['Architecture']['Head'][\n                'name'] == 'MultiHead':  # for multi head\n            out_channels_list = {}\n            if config['PostProcess']['name'] == 'SARLabelDecode':\n                char_num = char_num - 2\n            out_channels_list['CTCLabelDecode'] = char_num\n            out_channels_list['SARLabelDecode'] = char_num + 2\n            config['Architecture']['Head'][\n                'out_channels_list'] = out_channels_list\n        else:  # base rec model\n            config['Architecture'][\"Head\"]['out_channels'] = char_num\n\n    model = build_model(config['Architecture'])\n    extra_input_models = [\n        \"SRN\", \"NRTR\", \"SAR\", \"SEED\", \"SVTR\", \"VisionLAN\", \"RobustScanner\"\n    ]\n    extra_input = False\n    if config['Architecture']['algorithm'] == 'Distillation':\n        for key in config['Architecture'][\"Models\"]:\n            extra_input = extra_input or config['Architecture']['Models'][key][\n                'algorithm'] in extra_input_models\n    else:\n        extra_input = config['Architecture']['algorithm'] in extra_input_models\n    if \"model_type\" in config['Architecture'].keys():\n        if config['Architecture']['algorithm'] == 'CAN':\n            model_type = 'can'\n        else:\n            model_type = config['Architecture']['model_type']\n    else:\n        model_type = None\n\n    # build metric\n    eval_class = build_metric(config['Metric'])\n    # amp\n    use_amp = config[\"Global\"].get(\"use_amp\", False)\n    amp_level = config[\"Global\"].get(\"amp_level\", 'O2')\n    amp_custom_black_list = config['Global'].get('amp_custom_black_list', [])\n    if use_amp:\n        AMP_RELATED_FLAGS_SETTING = {\n            'FLAGS_cudnn_batchnorm_spatial_persistent': 1,\n            'FLAGS_max_inplace_grad_add': 8,\n        }\n        paddle.fluid.set_flags(AMP_RELATED_FLAGS_SETTING)\n        scale_loss = config[\"Global\"].get(\"scale_loss\", 1.0)\n        use_dynamic_loss_scaling = config[\"Global\"].get(\n            \"use_dynamic_loss_scaling\", False)\n        scaler = paddle.amp.GradScaler(\n            init_loss_scaling=scale_loss,\n            use_dynamic_loss_scaling=use_dynamic_loss_scaling)\n        if amp_level == \"O2\":\n            model = paddle.amp.decorate(\n                models=model, level=amp_level, master_weight=True)\n    else:\n        scaler = None\n\n    best_model_dict = load_model(\n        config, model, model_type=config['Architecture'][\"model_type\"])\n    if len(best_model_dict):\n        logger.info('metric in ckpt ***************')\n        for k, v in best_model_dict.items():\n            logger.info('{}:{}'.format(k, v))\n\n    # start eval\n    metric = program.eval(model, valid_dataloader, post_process_class,\n                          eval_class, model_type, extra_input, scaler,\n                          amp_level, amp_custom_black_list)\n    logger.info('metric eval ***************')\n    for k, v in metric.items():\n        logger.info('{}:{}'.format(k, v))",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 13,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}