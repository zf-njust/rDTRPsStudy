{
  "code": "def create_nd_panel_factory(klass_name, orders, slices, slicer, aliases=None,\n                            stat_axis=2, info_axis=0, ns=None):\n    \"\"\" manufacture a n-d class:\n\n        Parameters\n        ----------\n        klass_name : the klass name\n        orders : the names of the axes in order (highest to lowest)\n        slices : a dictionary that defines how the axes map to the slice axis\n        slicer : the class representing a slice of this panel\n        aliases : a dictionary defining aliases for various axes\n            default = { major : major_axis, minor : minor_axis }\n        stat_axis : the default statistic axis default = 2\n        info_axis : the info axis\n\n        Returns\n        -------\n        a class object representing this panel\n\n    \"\"\"\n\n    # if slicer is a name, get the object\n    if isinstance(slicer, compat.string_types):\n        import pandas\n        try:\n            slicer = getattr(pandas, slicer)\n        except:\n            raise Exception(\"cannot create this slicer [%s]\" % slicer)\n\n    # build the klass\n    ns = {} if not ns else ns\n    klass = type(klass_name, (slicer,), ns)\n\n    # setup the axes\n    klass._setup_axes(axes=orders, info_axis=info_axis, stat_axis=stat_axis,\n                      aliases=aliases, slicers=slices)\n\n    klass._constructor_sliced = slicer\n\n    # define the methods ####\n    def __init__(self, *args, **kwargs):\n        if not (kwargs.get('data') or len(args)):\n            raise Exception(\n                \"must supply at least a data argument to [%s]\" % klass_name)\n        if 'copy' not in kwargs:\n            kwargs['copy'] = False\n        if 'dtype' not in kwargs:\n            kwargs['dtype'] = None\n        self._init_data(*args, **kwargs)\n    klass.__init__ = __init__\n\n    def _get_plane_axes_index(self, axis):\n        \"\"\" return the sliced index for this object \"\"\"\n\n        axis_name = self._get_axis_name(axis)\n        index = self._AXIS_ORDERS.index(axis)\n\n        planes = []\n        if index:\n            planes.extend(self._AXIS_ORDERS[0:index])\n        if index != self._AXIS_LEN:\n            planes.extend(self._AXIS_ORDERS[index + 1:])\n\n        return planes\n    klass._get_plane_axes_index = _get_plane_axes_index\n\n    def _combine(self, other, func, axis=0):\n        if isinstance(other, klass):\n            return self._combine_with_constructor(other, func)\n        return super(klass, self)._combine(other, func, axis=axis)\n    klass._combine = _combine\n\n    def _combine_with_constructor(self, other, func):\n\n        # combine labels to form new axes\n        new_axes = []\n        for a in self._AXIS_ORDERS:\n            new_axes.append(getattr(self, a).union(getattr(other, a)))\n\n        # reindex: could check that everything's the same size, but forget it\n        d = dict([(a, ax) for a, ax in zip(self._AXIS_ORDERS, new_axes)])\n        d['copy'] = False\n        this = self.reindex(**d)\n        other = other.reindex(**d)\n\n        result_values = func(this.values, other.values)\n\n        return self._constructor(result_values, **d)\n    klass._combine_with_constructor = _combine_with_constructor\n\n    # set as NonImplemented operations which we don't support\n    for f in ['to_frame', 'to_excel', 'to_sparse', 'groupby', 'join', 'filter',\n              'dropna', 'shift']:\n        def func(self, *args, **kwargs):\n            raise NotImplementedError(\"this operation is not supported\")\n        setattr(klass, f, func)\n\n    # add the aggregate operations\n    klass._add_aggregate_operations()\n    klass._add_numeric_operations()\n\n    return klass",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 26,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}