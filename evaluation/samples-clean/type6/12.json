{
  "code": "def test_arith_flex_frame(self):\n        ops = ['add', 'sub', 'mul', 'div', 'truediv', 'pow', 'floordiv', 'mod']\n        if not compat.PY3:\n            aliases = {}\n        else:\n            aliases = {'div': 'truediv'}\n\n        for op in ops:\n            try:\n                alias = aliases.get(op, op)\n                f = getattr(operator, alias)\n                result = getattr(self.frame, op)(2 * self.frame)\n                exp = f(self.frame, 2 * self.frame)\n                assert_frame_equal(result, exp)\n\n                # vs mix float\n                result = getattr(self.mixed_float, op)(2 * self.mixed_float)\n                exp = f(self.mixed_float, 2 * self.mixed_float)\n                assert_frame_equal(result, exp)\n                _check_mixed_float(result, dtype = dict(C = None))\n\n                # vs mix int\n                if op in ['add','sub','mul']:\n                    result = getattr(self.mixed_int, op)(2 + self.mixed_int)\n                    exp = f(self.mixed_int, 2 + self.mixed_int)\n\n                    # overflow in the uint\n                    dtype = None\n                    if op in ['sub']:\n                        dtype = dict(B = 'object', C = None)\n                    elif op in ['add','mul']:\n                        dtype = dict(C = None)\n                    assert_frame_equal(result, exp)\n                    _check_mixed_int(result, dtype = dtype)\n\n                    # rops\n                    r_f = lambda x, y: f(y, x)\n                    result = getattr(self.frame, 'r' + op)(2 * self.frame)\n                    exp = r_f(self.frame, 2 * self.frame)\n                    assert_frame_equal(result, exp)\n\n                    # vs mix float\n                    result = getattr(self.mixed_float, op)(2 * self.mixed_float)\n                    exp = f(self.mixed_float, 2 * self.mixed_float)\n                    assert_frame_equal(result, exp)\n                    _check_mixed_float(result, dtype = dict(C = None))\n\n                    result = getattr(self.intframe, op)(2 * self.intframe)\n                    exp = f(self.intframe, 2 * self.intframe)\n                    assert_frame_equal(result, exp)\n\n                    # vs mix int\n                    if op in ['add','sub','mul']:\n                        result = getattr(self.mixed_int, op)(2 + self.mixed_int)\n                        exp = f(self.mixed_int, 2 + self.mixed_int)\n\n                        # overflow in the uint\n                        dtype = None\n                        if op in ['sub']:\n                            dtype = dict(B = 'object', C = None)\n                        elif op in ['add','mul']:\n                            dtype = dict(C = None)\n                        assert_frame_equal(result, exp)\n                        _check_mixed_int(result, dtype = dtype)\n            except:\n                com.pprint_thing(\"Failing operation %r\" % op)\n                raise\n\n            # ndim >= 3\n            ndim_5 = np.ones(self.frame.shape + (3, 4, 5))\n            with assertRaisesRegexp(ValueError, 'shape'):\n                f(self.frame, ndim_5)\n\n            with assertRaisesRegexp(ValueError, 'shape'):\n                getattr(self.frame, op)(ndim_5)\n\n\n        # res_add = self.frame.add(self.frame)\n        # res_sub = self.frame.sub(self.frame)\n        # res_mul = self.frame.mul(self.frame)\n        # res_div = self.frame.div(2 * self.frame)\n\n        # assert_frame_equal(res_add, self.frame + self.frame)\n        # assert_frame_equal(res_sub, self.frame - self.frame)\n        # assert_frame_equal(res_mul, self.frame * self.frame)\n        # assert_frame_equal(res_div, self.frame / (2 * self.frame))\n\n        const_add = self.frame.add(1)\n        assert_frame_equal(const_add, self.frame + 1)\n\n        # corner cases\n        result = self.frame.add(self.frame[:0])\n        assert_frame_equal(result, self.frame * np.nan)\n\n        result = self.frame[:0].add(self.frame)\n        assert_frame_equal(result, self.frame * np.nan)\n        with assertRaisesRegexp(NotImplementedError, 'fill_value'):\n            self.frame.add(self.frame.iloc[0], fill_value=3)\n        with assertRaisesRegexp(NotImplementedError, 'fill_value'):\n            self.frame.add(self.frame.iloc[0], axis='index', fill_value=3)",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 24,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}