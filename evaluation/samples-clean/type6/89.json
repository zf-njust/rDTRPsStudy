{
  "code": "def pandas(cls, **tqdm_kwargs):\n        \"\"\"\n        Registers the current `tqdm` class with\n            pandas.core.\n            ( frame.DataFrame\n            | series.Series\n            | groupby.(generic.)DataFrameGroupBy\n            | groupby.(generic.)SeriesGroupBy\n            ).progress_apply\n\n        A new instance will be created every time `progress_apply` is called,\n        and each instance will automatically `close()` upon completion.\n\n        Parameters\n        ----------\n        tqdm_kwargs  : arguments for the tqdm instance\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from tqdm import tqdm\n        >>> from tqdm.gui import tqdm as tqdm_gui\n        >>>\n        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n        >>> # Now you can use `progress_apply` instead of `apply`\n        >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n        References\n        ----------\n        <https://stackoverflow.com/questions/18603270/\\\n        progress-indicator-during-pandas-operations-python>\n        \"\"\"\n        from warnings import catch_warnings, simplefilter\n\n        from pandas.core.frame import DataFrame\n        from pandas.core.series import Series\n        try:\n            with catch_warnings():\n                simplefilter(\"ignore\", category=FutureWarning)\n                from pandas import Panel\n        except ImportError:  # pandas>=1.2.0\n            Panel = None\n        Rolling, Expanding = None, None\n        try:  # pandas>=1.0.0\n            from pandas.core.window.rolling import _Rolling_and_Expanding\n        except ImportError:\n            try:  # pandas>=0.18.0\n                from pandas.core.window import _Rolling_and_Expanding\n            except ImportError:  # pandas>=1.2.0\n                try:  # pandas>=1.2.0\n                    from pandas.core.window.expanding import Expanding\n                    from pandas.core.window.rolling import Rolling\n                    _Rolling_and_Expanding = Rolling, Expanding\n                except ImportError:  # pragma: no cover\n                    _Rolling_and_Expanding = None\n        try:  # pandas>=0.25.0\n            from pandas.core.groupby.generic import SeriesGroupBy  # , NDFrameGroupBy\n            from pandas.core.groupby.generic import DataFrameGroupBy\n        except ImportError:  # pragma: no cover\n            try:  # pandas>=0.23.0\n                from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy\n            except ImportError:\n                from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import GroupBy\n        except ImportError:  # pragma: no cover\n            from pandas.core.groupby import GroupBy\n\n        try:  # pandas>=0.23.0\n            from pandas.core.groupby.groupby import PanelGroupBy\n        except ImportError:\n            try:\n                from pandas.core.groupby import PanelGroupBy\n            except ImportError:  # pandas>=0.25.0\n                PanelGroupBy = None\n\n        tqdm_kwargs = tqdm_kwargs.copy()\n        deprecated_t = [tqdm_kwargs.pop('deprecated_t', None)]\n\n        def inner_generator(df_function='apply'):\n            def inner(df, func, *args, **kwargs):\n                \"\"\"\n                Parameters\n                ----------\n                df  : (DataFrame|Series)[GroupBy]\n                    Data (may be grouped).\n                func  : function\n                    To be applied on the (grouped) data.\n                **kwargs  : optional\n                    Transmitted to `df.apply()`.\n                \"\"\"\n\n                # Precompute total iterations\n                total = tqdm_kwargs.pop(\"total\", getattr(df, 'ngroups', None))\n                if total is None:  # not grouped\n                    if df_function == 'applymap':\n                        total = df.size\n                    elif isinstance(df, Series):\n                        total = len(df)\n                    elif (_Rolling_and_Expanding is None or\n                          not isinstance(df, _Rolling_and_Expanding)):\n                        # DataFrame or Panel\n                        axis = kwargs.get('axis', 0)\n                        if axis == 'index':\n                            axis = 0\n                        elif axis == 'columns':\n                            axis = 1\n                        # when axis=0, total is shape[axis1]\n                        total = df.size // df.shape[axis]\n\n                # Init bar\n                if deprecated_t[0] is not None:\n                    t = deprecated_t[0]\n                    deprecated_t[0] = None\n                else:\n                    t = cls(total=total, **tqdm_kwargs)\n\n                if len(args) > 0:\n                    # *args intentionally not supported (see #244, #299)\n                    TqdmDeprecationWarning(\n                        \"Except func, normal arguments are intentionally\" +\n                        \" not supported by\" +\n                        \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                        \" Use keyword arguments instead.\",\n                        fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n                try:  # pandas>=1.3.0\n                    from pandas.core.common import is_builtin_func\n                except ImportError:\n                    is_builtin_func = df._is_builtin_func\n                try:\n                    func = is_builtin_func(func)\n                except TypeError:\n                    pass\n\n                # Define bar updating wrapper\n                def wrapper(*args, **kwargs):\n                    # update tbar correctly\n                    # it seems `pandas apply` calls `func` twice\n                    # on the first column/row to decide whether it can\n                    # take a fast or slow code path; so stop when t.total==t.n\n                    t.update(n=1 if not t.total or t.n < t.total else 0)\n                    return func(*args, **kwargs)\n\n                # Apply the provided function (in **kwargs)\n                # on the df using our wrapper (which provides bar updating)\n                try:\n                    return getattr(df, df_function)(wrapper, **kwargs)\n                finally:\n                    t.close()\n\n            return inner\n\n        # Monkeypatch pandas to provide easy methods\n        # Enable custom tqdm progress in pandas!\n        Series.progress_apply = inner_generator()\n        SeriesGroupBy.progress_apply = inner_generator()\n        Series.progress_map = inner_generator('map')\n        SeriesGroupBy.progress_map = inner_generator('map')\n\n        DataFrame.progress_apply = inner_generator()\n        DataFrameGroupBy.progress_apply = inner_generator()\n        DataFrame.progress_applymap = inner_generator('applymap')\n\n        if Panel is not None:\n            Panel.progress_apply = inner_generator()\n        if PanelGroupBy is not None:\n            PanelGroupBy.progress_apply = inner_generator()\n\n        GroupBy.progress_apply = inner_generator()\n        GroupBy.progress_aggregate = inner_generator('aggregate')\n        GroupBy.progress_transform = inner_generator('transform')\n\n        if Rolling is not None and Expanding is not None:\n            Rolling.progress_apply = inner_generator()\n            Expanding.progress_apply = inner_generator()\n        elif _Rolling_and_Expanding is not None:\n            _Rolling_and_Expanding.progress_apply = inner_generator()",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 150,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}