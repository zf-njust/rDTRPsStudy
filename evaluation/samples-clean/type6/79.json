{
  "code": "def test_expanding_consistency(self):\n\n        # suppress warnings about empty slices, as we are deliberately testing with empty/0-length Series/DataFrames\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"ignore\", message=\".*(empty slice|0 for slice).*\", category=RuntimeWarning)\n\n            for min_periods in [0, 1, 2, 3, 4]:\n\n                # test consistency between different expanding_* moments\n                self._test_moments_consistency(\n                    min_periods=min_periods,\n                    count=mom.expanding_count,\n                    mean=lambda x: mom.expanding_mean(x, min_periods=min_periods),\n                    mock_mean=lambda x: mom.expanding_sum(x, min_periods=min_periods) / mom.expanding_count(x),\n                    corr=lambda x, y: mom.expanding_corr(x, y, min_periods=min_periods),\n                    var_unbiased=lambda x: mom.expanding_var(x, min_periods=min_periods),\n                    std_unbiased=lambda x: mom.expanding_std(x, min_periods=min_periods),\n                    cov_unbiased=lambda x, y: mom.expanding_cov(x, y, min_periods=min_periods),\n                    var_biased=lambda x: mom.expanding_var(x, min_periods=min_periods, ddof=0),\n                    std_biased=lambda x: mom.expanding_std(x, min_periods=min_periods, ddof=0),\n                    cov_biased=lambda x, y: mom.expanding_cov(x, y, min_periods=min_periods, ddof=0),\n                    var_debiasing_factors=lambda x: mom.expanding_count(x) / (mom.expanding_count(x) - 1.).replace(0., np.nan)\n                    )\n\n                # test consistency between expanding_xyz() and either (a) expanding_apply of Series.xyz(),\n                #                                                  or (b) expanding_apply of np.nanxyz()\n                for (x, is_constant, no_nans) in self.data:\n                    assert_equal = assert_series_equal if isinstance(x, Series) else assert_frame_equal\n                    functions = self.base_functions\n\n                    # GH 8269\n                    if no_nans:\n                        functions = self.base_functions + self.no_nan_functions\n                    for (f, require_min_periods, name) in functions:\n                        expanding_f = getattr(mom,'expanding_{0}'.format(name))\n\n                        if require_min_periods and (min_periods is not None) and (min_periods < require_min_periods):\n                            continue\n\n                        if expanding_f is mom.expanding_count:\n                            expanding_f_result = expanding_f(x)\n                            expanding_apply_f_result = mom.expanding_apply(x, func=f, min_periods=0)\n                        else:\n                            if expanding_f in [mom.expanding_cov, mom.expanding_corr]:\n                                expanding_f_result = expanding_f(x, min_periods=min_periods, pairwise=False)\n                            else:\n                                expanding_f_result = expanding_f(x, min_periods=min_periods)\n                            expanding_apply_f_result = mom.expanding_apply(x, func=f, min_periods=min_periods)\n\n                        if not tm._incompat_bottleneck_version(name):\n                            assert_equal(expanding_f_result, expanding_apply_f_result)\n\n                        if (expanding_f in [mom.expanding_cov, mom.expanding_corr]) and isinstance(x, DataFrame):\n                            # test pairwise=True\n                            expanding_f_result = expanding_f(x, x, min_periods=min_periods, pairwise=True)\n                            expected = Panel(items=x.index, major_axis=x.columns, minor_axis=x.columns)\n                            for i, _ in enumerate(x.columns):\n                                for j, _ in enumerate(x.columns):\n                                    expected.iloc[:, i, j] = expanding_f(x.iloc[:, i], x.iloc[:, j], min_periods=min_periods)\n                            assert_panel_equal(expanding_f_result, expected)",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 35,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}