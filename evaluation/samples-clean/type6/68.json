{
  "code": "def test_resnet_backbone():\n    \"\"\"Test resnet backbone.\"\"\"\n    with pytest.raises(KeyError):\n        # ResNet depth should be in [18, 34, 50, 101, 152]\n        ResNet(20)\n\n    with pytest.raises(AssertionError):\n        # In ResNet: 1 <= num_stages <= 4\n        ResNet(50, num_stages=0)\n\n    with pytest.raises(AssertionError):\n        # len(stage_with_dcn) == num_stages\n        dcn = dict(type='DCN', deform_groups=1, fallback_on_stride=False)\n        ResNet(50, dcn=dcn, stage_with_dcn=(True, ))\n\n    with pytest.raises(AssertionError):\n        # len(stage_with_plugin) == num_stages\n        plugins = [\n            dict(\n                cfg=dict(type='ContextBlock', ratio=1. / 16),\n                stages=(False, True, True),\n                position='after_conv3')\n        ]\n        ResNet(50, plugins=plugins)\n\n    with pytest.raises(AssertionError):\n        # In ResNet: 1 <= num_stages <= 4\n        ResNet(50, num_stages=5)\n\n    with pytest.raises(AssertionError):\n        # len(strides) == len(dilations) == num_stages\n        ResNet(50, strides=(1, ), dilations=(1, 1), num_stages=3)\n\n    with pytest.raises(TypeError):\n        # pretrained must be a string path\n        model = ResNet(50, pretrained=0)\n\n    with pytest.raises(AssertionError):\n        # Style must be in ['pytorch', 'caffe']\n        ResNet(50, style='tensorflow')\n\n    # Test ResNet50 norm_eval=True\n    model = ResNet(50, norm_eval=True, base_channels=1)\n    model.train()\n    assert check_norm_state(model.modules(), False)\n\n    # Test ResNet50 with torchvision pretrained weight\n    model = ResNet(\n        depth=50, norm_eval=True, pretrained='torchvision://resnet50')\n    model.train()\n    assert check_norm_state(model.modules(), False)\n\n    # Test ResNet50 with first stage frozen\n    frozen_stages = 1\n    model = ResNet(50, frozen_stages=frozen_stages, base_channels=1)\n    model.train()\n    assert model.norm1.training is False\n    for layer in [model.conv1, model.norm1]:\n        for param in layer.parameters():\n            assert param.requires_grad is False\n    for i in range(1, frozen_stages + 1):\n        layer = getattr(model, f'layer{i}')\n        for mod in layer.modules():\n            if isinstance(mod, _BatchNorm):\n                assert mod.training is False\n        for param in layer.parameters():\n            assert param.requires_grad is False\n\n    # Test ResNet50V1d with first stage frozen\n    model = ResNetV1d(depth=50, frozen_stages=frozen_stages, base_channels=2)\n    assert len(model.stem) == 9\n    model.train()\n    assert check_norm_state(model.stem, False)\n    for param in model.stem.parameters():\n        assert param.requires_grad is False\n    for i in range(1, frozen_stages + 1):\n        layer = getattr(model, f'layer{i}')\n        for mod in layer.modules():\n            if isinstance(mod, _BatchNorm):\n                assert mod.training is False\n        for param in layer.parameters():\n            assert param.requires_grad is False\n\n    # Test ResNet18 forward\n    model = ResNet(18)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 64, 8, 8])\n    assert feat[1].shape == torch.Size([1, 128, 4, 4])\n    assert feat[2].shape == torch.Size([1, 256, 2, 2])\n    assert feat[3].shape == torch.Size([1, 512, 1, 1])\n\n    # Test ResNet18 with checkpoint forward\n    model = ResNet(18, with_cp=True)\n    for m in model.modules():\n        if is_block(m):\n            assert m.with_cp\n\n    # Test ResNet50 with BatchNorm forward\n    model = ResNet(50, base_channels=1)\n    for m in model.modules():\n        if is_norm(m):\n            assert isinstance(m, _BatchNorm)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 4, 8, 8])\n    assert feat[1].shape == torch.Size([1, 8, 4, 4])\n    assert feat[2].shape == torch.Size([1, 16, 2, 2])\n    assert feat[3].shape == torch.Size([1, 32, 1, 1])\n\n    # Test ResNet50 with layers 1, 2, 3 out forward\n    model = ResNet(50, out_indices=(0, 1, 2), base_channels=1)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 3\n    assert feat[0].shape == torch.Size([1, 4, 8, 8])\n    assert feat[1].shape == torch.Size([1, 8, 4, 4])\n    assert feat[2].shape == torch.Size([1, 16, 2, 2])\n\n    # Test ResNet50 with checkpoint forward\n    model = ResNet(50, with_cp=True, base_channels=1)\n    for m in model.modules():\n        if is_block(m):\n            assert m.with_cp\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 4, 8, 8])\n    assert feat[1].shape == torch.Size([1, 8, 4, 4])\n    assert feat[2].shape == torch.Size([1, 16, 2, 2])\n    assert feat[3].shape == torch.Size([1, 32, 1, 1])\n\n    # Test ResNet50 with GroupNorm forward\n    model = ResNet(\n        50,\n        base_channels=4,\n        norm_cfg=dict(type='GN', num_groups=2, requires_grad=True))\n    for m in model.modules():\n        if is_norm(m):\n            assert isinstance(m, GroupNorm)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 16, 8, 8])\n    assert feat[1].shape == torch.Size([1, 32, 4, 4])\n    assert feat[2].shape == torch.Size([1, 64, 2, 2])\n    assert feat[3].shape == torch.Size([1, 128, 1, 1])\n\n    # Test ResNet50 with 1 GeneralizedAttention after conv2, 1 NonLocal2D\n    # after conv2, 1 ContextBlock after conv3 in layers 2, 3, 4\n    plugins = [\n        dict(\n            cfg=dict(\n                type='GeneralizedAttention',\n                spatial_range=-1,\n                num_heads=8,\n                attention_type='0010',\n                kv_stride=2),\n            stages=(False, True, True, True),\n            position='after_conv2'),\n        dict(cfg=dict(type='NonLocal2d'), position='after_conv2'),\n        dict(\n            cfg=dict(type='ContextBlock', ratio=1. / 16),\n            stages=(False, True, True, False),\n            position='after_conv3')\n    ]\n    model = ResNet(50, plugins=plugins, base_channels=8)\n    for m in model.layer1.modules():\n        if is_block(m):\n            assert not hasattr(m, 'context_block')\n            assert not hasattr(m, 'gen_attention_block')\n            assert m.nonlocal_block.in_channels == 8\n    for m in model.layer2.modules():\n        if is_block(m):\n            assert m.nonlocal_block.in_channels == 16\n            assert m.gen_attention_block.in_channels == 16\n            assert m.context_block.in_channels == 64\n\n    for m in model.layer3.modules():\n        if is_block(m):\n            assert m.nonlocal_block.in_channels == 32\n            assert m.gen_attention_block.in_channels == 32\n            assert m.context_block.in_channels == 128\n\n    for m in model.layer4.modules():\n        if is_block(m):\n            assert m.nonlocal_block.in_channels == 64\n            assert m.gen_attention_block.in_channels == 64\n            assert not hasattr(m, 'context_block')\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 32, 8, 8])\n    assert feat[1].shape == torch.Size([1, 64, 4, 4])\n    assert feat[2].shape == torch.Size([1, 128, 2, 2])\n    assert feat[3].shape == torch.Size([1, 256, 1, 1])\n\n    # Test ResNet50 with 1 ContextBlock after conv2, 1 ContextBlock after\n    # conv3 in layers 2, 3, 4\n    plugins = [\n        dict(\n            cfg=dict(type='ContextBlock', ratio=1. / 16, postfix=1),\n            stages=(False, True, True, False),\n            position='after_conv3'),\n        dict(\n            cfg=dict(type='ContextBlock', ratio=1. / 16, postfix=2),\n            stages=(False, True, True, False),\n            position='after_conv3')\n    ]\n\n    model = ResNet(50, plugins=plugins, base_channels=8)\n    for m in model.layer1.modules():\n        if is_block(m):\n            assert not hasattr(m, 'context_block')\n            assert not hasattr(m, 'context_block1')\n            assert not hasattr(m, 'context_block2')\n    for m in model.layer2.modules():\n        if is_block(m):\n            assert not hasattr(m, 'context_block')\n            assert m.context_block1.in_channels == 64\n            assert m.context_block2.in_channels == 64\n\n    for m in model.layer3.modules():\n        if is_block(m):\n            assert not hasattr(m, 'context_block')\n            assert m.context_block1.in_channels == 128\n            assert m.context_block2.in_channels == 128\n\n    for m in model.layer4.modules():\n        if is_block(m):\n            assert not hasattr(m, 'context_block')\n            assert not hasattr(m, 'context_block1')\n            assert not hasattr(m, 'context_block2')\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 32, 8, 8])\n    assert feat[1].shape == torch.Size([1, 64, 4, 4])\n    assert feat[2].shape == torch.Size([1, 128, 2, 2])\n    assert feat[3].shape == torch.Size([1, 256, 1, 1])\n\n    # Test ResNet50 zero initialization of residual\n    model = ResNet(50, zero_init_residual=True, base_channels=1)\n    model.init_weights()\n    for m in model.modules():\n        if isinstance(m, Bottleneck):\n            assert assert_params_all_zeros(m.norm3)\n        elif isinstance(m, BasicBlock):\n            assert assert_params_all_zeros(m.norm2)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 4, 8, 8])\n    assert feat[1].shape == torch.Size([1, 8, 4, 4])\n    assert feat[2].shape == torch.Size([1, 16, 2, 2])\n    assert feat[3].shape == torch.Size([1, 32, 1, 1])\n\n    # Test ResNetV1d forward\n    model = ResNetV1d(depth=50, base_channels=2)\n    model.train()\n\n    imgs = torch.randn(1, 3, 32, 32)\n    feat = model(imgs)\n    assert len(feat) == 4\n    assert feat[0].shape == torch.Size([1, 8, 8, 8])\n    assert feat[1].shape == torch.Size([1, 16, 4, 4])\n    assert feat[2].shape == torch.Size([1, 32, 2, 2])\n    assert feat[3].shape == torch.Size([1, 64, 1, 1])",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 77,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}