{
  "code": "def get_scheme(\n    dist_name: str,\n    user: bool = False,\n    home: typing.Optional[str] = None,\n    root: typing.Optional[str] = None,\n    isolated: bool = False,\n    prefix: typing.Optional[str] = None,\n) -> Scheme:\n    \"\"\"\n    Get the \"scheme\" corresponding to the input parameters.\n\n    :param dist_name: the name of the package to retrieve the scheme for, used\n        in the headers scheme path\n    :param user: indicates to use the \"user\" scheme\n    :param home: indicates to use the \"home\" scheme\n    :param root: root under which other directories are re-based\n    :param isolated: ignored, but kept for distutils compatibility (where\n        this controls whether the user-site pydistutils.cfg is honored)\n    :param prefix: indicates to use the \"prefix\" scheme and provides the\n        base directory for the same\n    \"\"\"\n    if user and prefix:\n        raise InvalidSchemeCombination(\"--user\", \"--prefix\")\n    if home and prefix:\n        raise InvalidSchemeCombination(\"--home\", \"--prefix\")\n\n    if home is not None:\n        scheme_name = _infer_home()\n    elif user:\n        scheme_name = _infer_user()\n    else:\n        scheme_name = _infer_prefix()\n\n    # Special case: When installing into a custom prefix, use posix_prefix\n    # instead of osx_framework_library. See _should_use_osx_framework_prefix()\n    # docstring for details.\n    if prefix is not None and scheme_name == \"osx_framework_library\":\n        scheme_name = \"posix_prefix\"\n\n    if home is not None:\n        variables = {k: home for k in _HOME_KEYS}\n    elif prefix is not None:\n        variables = {k: prefix for k in _HOME_KEYS}\n    else:\n        variables = {}\n\n    paths = sysconfig.get_paths(scheme=scheme_name, vars=variables)\n\n    # Logic here is very arbitrary, we're doing it for compatibility, don't ask.\n    # 1. Pip historically uses a special header path in virtual environments.\n    # 2. If the distribution name is not known, distutils uses 'UNKNOWN'. We\n    #    only do the same when not running in a virtual environment because\n    #    pip's historical header path logic (see point 1) did not do this.\n    if running_under_virtualenv():\n        if user:\n            base = variables.get(\"userbase\", sys.prefix)\n        else:\n            base = variables.get(\"base\", sys.prefix)\n        python_xy = f\"python{get_major_minor_version()}\"\n        paths[\"include\"] = os.path.join(base, \"include\", \"site\", python_xy)\n    elif not dist_name:\n        dist_name = \"UNKNOWN\"\n\n    scheme = Scheme(\n        platlib=paths[\"platlib\"],\n        purelib=paths[\"purelib\"],\n        headers=os.path.join(paths[\"include\"], dist_name),\n        scripts=paths[\"scripts\"],\n        data=paths[\"data\"],\n    )\n    if root is not None:\n        for key in SCHEME_KEYS:\n            value = change_root(root, getattr(scheme, key))\n            setattr(scheme, key, value)\n    return scheme",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 73,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}