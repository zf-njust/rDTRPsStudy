{
  "code": "def _check_stat_op(self, name, alternative, frame=None, has_skipna=True,\n                       has_numeric_only=False, check_dtype=True, check_dates=False,\n                       check_less_precise=False):\n        if frame is None:\n            frame = self.frame\n            # set some NAs\n            frame.ix[5:10] = np.nan\n            frame.ix[15:20, -2:] = np.nan\n\n        f = getattr(frame, name)\n\n        if check_dates:\n            df = DataFrame({'b': date_range('1/1/2001', periods=2)})\n            _f = getattr(df, name)\n            result = _f()\n            self.assertIsInstance(result, Series)\n\n            df['a'] = lrange(len(df))\n            result = getattr(df, name)()\n            self.assertIsInstance(result, Series)\n            self.assertTrue(len(result))\n\n        if has_skipna:\n            def skipna_wrapper(x):\n                nona = x.dropna()\n                if len(nona) == 0:\n                    return np.nan\n                return alternative(nona)\n\n            def wrapper(x):\n                return alternative(x.values)\n\n            result0 = f(axis=0, skipna=False)\n            result1 = f(axis=1, skipna=False)\n            assert_series_equal(result0, frame.apply(wrapper),\n                                check_dtype=check_dtype,\n                                check_less_precise=check_less_precise)\n            assert_series_equal(result1, frame.apply(wrapper, axis=1),\n                                check_dtype=False,\n                                check_less_precise=check_less_precise)  # HACK: win32\n        else:\n            skipna_wrapper = alternative\n            wrapper = alternative\n\n        result0 = f(axis=0)\n        result1 = f(axis=1)\n        assert_series_equal(result0, frame.apply(skipna_wrapper),\n                            check_dtype=check_dtype,\n                            check_less_precise=check_less_precise)\n        if not tm._incompat_bottleneck_version(name):\n            assert_series_equal(result1, frame.apply(skipna_wrapper, axis=1),\n                                check_dtype=False,\n                                check_less_precise=check_less_precise)\n\n        # check dtypes\n        if check_dtype:\n            lcd_dtype = frame.values.dtype\n            self.assertEqual(lcd_dtype, result0.dtype)\n            self.assertEqual(lcd_dtype, result1.dtype)\n\n        # result = f(axis=1)\n        # comp = frame.apply(alternative, axis=1).reindex(result.index)\n        # assert_series_equal(result, comp)\n\n        # bad axis\n        assertRaisesRegexp(ValueError, 'No axis named 2', f, axis=2)\n        # make sure works on mixed-type frame\n        getattr(self.mixed_frame, name)(axis=0)\n        getattr(self.mixed_frame, name)(axis=1)\n\n        if has_numeric_only:\n            getattr(self.mixed_frame, name)(axis=0, numeric_only=True)\n            getattr(self.mixed_frame, name)(axis=1, numeric_only=True)\n            getattr(self.frame, name)(axis=0, numeric_only=False)\n            getattr(self.frame, name)(axis=1, numeric_only=False)\n\n        # all NA case\n        if has_skipna:\n            all_na = self.frame * np.NaN\n            r0 = getattr(all_na, name)(axis=0)\n            r1 = getattr(all_na, name)(axis=1)\n            if not tm._incompat_bottleneck_version(name):\n                self.assertTrue(np.isnan(r0).all())\n                self.assertTrue(np.isnan(r1).all())",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 10,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}