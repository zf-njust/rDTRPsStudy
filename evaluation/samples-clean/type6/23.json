{
  "code": "def test_datetime64_with_DateOffset(self):\n        for klass, assert_func in zip([Series, DatetimeIndex],\n                                      [self.assert_series_equal,\n                                       tm.assert_index_equal]):\n            s = klass(date_range('2000-01-01', '2000-01-31'), name='a')\n            result = s + pd.DateOffset(years=1)\n            result2 = pd.DateOffset(years=1) + s\n            exp = klass(date_range('2001-01-01', '2001-01-31'), name='a')\n            assert_func(result, exp)\n            assert_func(result2, exp)\n\n            result = s - pd.DateOffset(years=1)\n            exp = klass(date_range('1999-01-01', '1999-01-31'), name='a')\n            assert_func(result, exp)\n\n            s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),\n                       pd.Timestamp('2000-02-15', tz='US/Central')], name='a')\n            result = s + pd.offsets.Day()\n            result2 = pd.offsets.Day() + s\n            exp = klass([Timestamp('2000-01-16 00:15:00', tz='US/Central'),\n                         Timestamp('2000-02-16', tz='US/Central')], name='a')\n            assert_func(result, exp)\n            assert_func(result2, exp)\n\n            s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),\n                       pd.Timestamp('2000-02-15', tz='US/Central')], name='a')\n            result = s + pd.offsets.MonthEnd()\n            result2 = pd.offsets.MonthEnd() + s\n            exp = klass([Timestamp('2000-01-31 00:15:00', tz='US/Central'),\n                         Timestamp('2000-02-29', tz='US/Central')], name='a')\n            assert_func(result, exp)\n            assert_func(result2, exp)\n\n            # array of offsets - valid for Series only\n            if klass is Series:\n                with tm.assert_produces_warning(PerformanceWarning):\n                    s = klass([Timestamp('2000-1-1'), Timestamp('2000-2-1')])\n                    result = s + Series([pd.offsets.DateOffset(years=1),\n                                        pd.offsets.MonthEnd()])\n                    exp = klass([Timestamp('2001-1-1'), Timestamp('2000-2-29')])\n                    assert_func(result, exp)\n\n                    # same offset\n                    result = s + Series([pd.offsets.DateOffset(years=1),\n                                         pd.offsets.DateOffset(years=1)])\n                    exp = klass([Timestamp('2001-1-1'), Timestamp('2001-2-1')])\n                    assert_func(result, exp)\n\n            s = klass([Timestamp('2000-01-05 00:15:00'), Timestamp('2000-01-31 00:23:00'),\n                       Timestamp('2000-01-01'), Timestamp('2000-02-29'), Timestamp('2000-12-31')])\n\n            #DateOffset relativedelta fastpath\n            relative_kwargs = [('years', 2), ('months', 5), ('days', 3),\n                            ('hours', 5), ('minutes', 10), ('seconds', 2),\n                            ('microseconds', 5)]\n            for i, kwd in enumerate(relative_kwargs):\n                op = pd.DateOffset(**dict([kwd]))\n                assert_func(klass([x + op for x in s]), s + op)\n                assert_func(klass([x - op for x in s]), s - op)\n                op = pd.DateOffset(**dict(relative_kwargs[:i+1]))\n                assert_func(klass([x + op for x in s]), s + op)\n                assert_func(klass([x - op for x in s]), s - op)\n\n\n            # split by fast/slow path to test perf warning\n            off = {False:\n                   ['YearBegin', ('YearBegin', {'month': 5}),\n                    'YearEnd', ('YearEnd', {'month': 5}),\n                    'MonthBegin', 'MonthEnd', 'Week', ('Week', {'weekday': 3}),\n                    'BusinessDay', 'BDay', 'QuarterEnd', 'QuarterBegin'],\n                   PerformanceWarning:\n                   ['CustomBusinessDay', 'CDay', 'CBMonthEnd','CBMonthBegin',\n                    'BMonthBegin', 'BMonthEnd', 'BusinessHour', 'BYearBegin',\n                    'BYearEnd','BQuarterBegin', ('LastWeekOfMonth', {'weekday':2}),\n                    ('FY5253Quarter', {'qtr_with_extra_week': 1, 'startingMonth': 1,\n                                       'weekday': 2, 'variation': 'nearest'}),\n                    ('FY5253',{'weekday': 0, 'startingMonth': 2, 'variation': 'nearest'}),\n                    ('WeekOfMonth', {'weekday': 2, 'week': 2}), 'Easter',\n                    ('DateOffset', {'day': 4}), ('DateOffset', {'month': 5})]}\n\n            for normalize in (True, False):\n                for warning, offsets in off.items():\n                    for do in offsets:\n                        if isinstance(do, tuple):\n                            do, kwargs = do\n                        else:\n                            do = do\n                            kwargs = {}\n                        op = getattr(pd.offsets,do)(5, normalize=normalize, **kwargs)\n                        with tm.assert_produces_warning(warning):\n                            assert_func(klass([x + op for x in s]), s + op)\n                            assert_func(klass([x - op for x in s]), s - op)\n                            assert_func(klass([op + x for x in s]), op + s)",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 89,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}