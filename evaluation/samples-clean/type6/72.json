{
  "code": "def get_distribution_facts(self):\n        # The platform module provides information about the running\n        # system/distribution. Use this as a baseline and fix buggy systems\n        # afterwards\n        self.facts['distribution'] = self.system\n        self.facts['distribution_release'] = platform.release()\n        self.facts['distribution_version'] = platform.version()\n        systems_implemented = ('AIX', 'HP-UX', 'Darwin', 'FreeBSD', 'OpenBSD', 'SunOS', 'DragonFly')\n\n        self.facts['distribution'] = self.system\n\n        if self.system in systems_implemented:\n            cleanedname = self.system.replace('-','')\n            distfunc = getattr(self, 'get_distribution_'+cleanedname)\n            distfunc()\n        elif self.system == 'Linux':\n            # try to find out which linux distribution this is\n            dist = platform.dist()\n            self.facts['distribution'] = dist[0].capitalize() or 'NA'\n            self.facts['distribution_version'] = dist[1] or 'NA'\n            self.facts['distribution_major_version'] = dist[1].split('.')[0] or 'NA'\n            self.facts['distribution_release'] = dist[2] or 'NA'\n            # Try to handle the exceptions now ...\n            # self.facts['distribution_debug'] = []\n            for ddict in self.OSDIST_LIST:\n                name = ddict['name']\n                path = ddict['path']\n\n                if not os.path.exists(path):\n                    continue\n                # if allowempty is set, we only check for file existance but not content\n                if 'allowempty' in ddict and ddict['allowempty']:\n                    self.facts['distribution'] = name\n                    break\n                if os.path.getsize(path) == 0:\n                    continue\n\n                data = get_file_content(path)\n                if name in self.SEARCH_STRING:\n                    # look for the distribution string in the data and replace according to RELEASE_NAME_MAP\n                    # only the distribution name is set, the version is assumed to be correct from platform.dist()\n                    if self.SEARCH_STRING[name] in data:\n                        # this sets distribution=RedHat if 'Red Hat' shows up in data\n                        self.facts['distribution'] = name\n                    else:\n                        # this sets distribution to what's in the data, e.g. CentOS, Scientific, ...\n                        self.facts['distribution'] = data.split()[0]\n                    break\n                else:\n                    # call a dedicated function for parsing the file content\n                    try:\n                        distfunc = getattr(self, 'get_distribution_' + name)\n                        parsed = distfunc(name, data, path)\n                        if parsed is None or parsed:\n                            # distfunc return False if parsing failed\n                            # break only if parsing was succesful\n                            # otherwise continue with other distributions\n                            break\n                    except AttributeError:\n                        # this should never happen, but if it does fail quitely and not with a traceback\n                        pass\n\n\n\n                    # to debug multiple matching release files, one can use:\n                    # self.facts['distribution_debug'].append({path + ' ' + name:\n                    #         (parsed,\n                    #          self.facts['distribution'],\n                    #          self.facts['distribution_version'],\n                    #          self.facts['distribution_release'],\n                    #          )})\n\n        self.facts['os_family'] = self.facts['distribution']\n        distro = self.facts['distribution'].replace(' ', '_')\n        if distro in self.OS_FAMILY:\n            self.facts['os_family'] = self.OS_FAMILY[distro]",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 14,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}