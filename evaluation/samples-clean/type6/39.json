{
  "code": "def test_chart_based_annotations_accumulator_gt_densepose(self):\n        data_relative_keys = [\n            DensePoseDataRelative.X_KEY,\n            DensePoseDataRelative.Y_KEY,\n            DensePoseDataRelative.I_KEY,\n            DensePoseDataRelative.U_KEY,\n            DensePoseDataRelative.V_KEY,\n            DensePoseDataRelative.S_KEY,\n        ]\n        annotations = [DensePoseDataRelative({k: [0] for k in data_relative_keys})] * n_instances\n        instances.gt_densepose = DensePoseList(annotations, instances.gt_boxes, image_shape)\n        accumulator = ChartBasedAnnotationsAccumulator()\n        accumulator.accumulate(instances)\n        bbox_xywh_est = BoxMode.convert(\n            instances.proposal_boxes.tensor.clone(), BoxMode.XYXY_ABS, BoxMode.XYWH_ABS\n        )\n        bbox_xywh_gt = BoxMode.convert(\n            instances.gt_boxes.tensor.clone(), BoxMode.XYXY_ABS, BoxMode.XYWH_ABS\n        )\n        expected_values = {\n            \"s_gt\": [\n                torch.zeros((3, DensePoseDataRelative.MASK_SIZE, DensePoseDataRelative.MASK_SIZE))\n            ]\n            * n_instances,\n            \"bbox_xywh_est\": bbox_xywh_est.split(1),\n            \"bbox_xywh_gt\": bbox_xywh_gt.split(1),\n            \"point_bbox_with_dp_indices\": [torch.tensor([i]) for i in range(n_instances)],\n            \"point_bbox_indices\": [torch.tensor([i]) for i in range(n_instances)],\n            \"bbox_indices\": list(range(n_instances)),\n            \"nxt_bbox_with_dp_index\": n_instances,\n            \"nxt_bbox_index\": n_instances,\n        }\n        default_value = [torch.tensor([0])] * 3\n        for key in accumulator.__dict__:\n            to_test = getattr(accumulator, key)\n            gt_value = expected_values.get(key, default_value)\n            if key in [\"nxt_bbox_with_dp_index\", \"nxt_bbox_index\"]:\n                self.assertEqual(to_test, gt_value)\n            elif key == \"bbox_indices\":\n                self.assertListEqual(to_test, gt_value)\n            else:\n                self.assertTrue(torch.allclose(torch.stack(to_test), torch.stack(gt_value)))",
  "smell": [
    {
      "smell_id": 6,
      "line_no": 35,
      "description": "The attribute is visited based on a dynamically determined name."
    }
  ]
}