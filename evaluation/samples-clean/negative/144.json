{
    "code": "def find_best_candidate(\n        self,\n        package_name,  # type: str\n        target_package_version=None,  # type:  Union[str, None]\n        allow_prereleases=False,  # type: bool\n    ):  # type: (...) -> Union[Package, bool]\n        \"\"\"\n        Given a package name and optional version,\n        returns the latest Package that matches\n        \"\"\"\n        if target_package_version:\n            constraint = parse_constraint(target_package_version)\n        else:\n            constraint = parse_constraint(\"*\")\n\n        candidates = self._pool.find_packages(\n            package_name, constraint, allow_prereleases=True\n        )\n        only_prereleases = all([c.version.is_prerelease() for c in candidates])\n\n        if not candidates:\n            return False\n\n        dependency = Dependency(package_name, constraint)\n\n        # Select highest version if we have many\n        package = candidates[0]\n        for candidate in candidates:\n            if (\n                candidate.is_prerelease()\n                and not dependency.allows_prereleases()\n                and not allow_prereleases\n                and not only_prereleases\n            ):\n                continue\n\n            # Select highest version of the two\n            if package.version < candidate.version:\n                package = candidate\n\n        return package",
    "smell": []
}