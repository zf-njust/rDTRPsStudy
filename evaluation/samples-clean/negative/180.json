{
    "code": "def to_float_timestamp(\n    time_object: Union[int, float, dtm.timedelta, dtm.datetime, dtm.time],\n    reference_timestamp: Optional[float] = None,\n    tzinfo: Optional[dtm.tzinfo] = None,\n) -> float:\n    \"\"\"\n    Converts a given time object to a float POSIX timestamp.\n    Used to convert different time specifications to a common format. The time object\n    can be relative (i.e. indicate a time increment, or a time of day) or absolute.\n    Objects from the :class:`datetime` module that are timezone-naive will be assumed\n    to be in UTC, if ``bot`` is not passed or ``bot.defaults`` is :obj:`None`.\n\n    Args:\n        time_object (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | \\\n            :obj:`datetime.datetime` | :obj:`datetime.time`):\n            Time value to convert. The semantics of this parameter will depend on its type:\n\n            * :obj:`int` or :obj:`float` will be interpreted as \"seconds from\n              :paramref:`reference_t`\"\n            * :obj:`datetime.timedelta` will be interpreted as\n              \"time increment from :paramref:`reference_timestamp`\"\n            * :obj:`datetime.datetime` will be interpreted as an absolute date/time value\n            * :obj:`datetime.time` will be interpreted as a specific time of day\n\n        reference_timestamp (:obj:`float`, optional): POSIX timestamp that indicates the absolute\n            time from which relative calculations are to be performed (e.g. when\n            :paramref:`time_object` is given as an :obj:`int`, indicating \"seconds from\n            :paramref:`reference_time`\"). Defaults to now (the time at which this function is\n            called).\n\n            If :paramref:`time_object` is given as an absolute representation of date & time (i.e.\n            a :obj:`datetime.datetime` object), :paramref:`reference_timestamp` is not relevant\n            and so its value should be :obj:`None`. If this is not the case, a :exc:`ValueError`\n            will be raised.\n        tzinfo (:class:`datetime.tzinfo`, optional): If :paramref:`time_object` is a naive object\n            from the :mod:`datetime` module, it will be interpreted as this timezone. Defaults to\n            ``pytz.utc``, if available, and :attr:`datetime.timezone.utc` otherwise.\n\n            Note:\n                Only to be used by ``telegram.ext``.\n\n    Returns:\n        :obj:`float` | :obj:`None`:\n            The return value depends on the type of argument :paramref:`time_object`.\n            If :paramref:`time_object` is given as a time increment (i.e. as a :obj:`int`,\n            :obj:`float` or :obj:`datetime.timedelta`), then the return value will be\n            :paramref:`reference_timestamp` + :paramref:`time_object`.\n\n            Else if it is given as an absolute date/time value (i.e. a :obj:`datetime.datetime`\n            object), the equivalent value as a POSIX timestamp will be returned.\n\n            Finally, if it is a time of the day without date (i.e. a :obj:`datetime.time`\n            object), the return value is the nearest future occurrence of that time of day.\n\n    Raises:\n        TypeError: If :paramref:`time_object` s type is not one of those described above.\n        ValueError: If :paramref:`time_object` is a :obj:`datetime.datetime` and\n            :paramref:`reference_timestamp` is not :obj:`None`.\n    \"\"\"\n    if reference_timestamp is None:\n        reference_timestamp = time.time()\n    elif isinstance(time_object, dtm.datetime):\n        raise ValueError(\"t is an (absolute) datetime while reference_timestamp is not None\")\n\n    if isinstance(time_object, dtm.timedelta):\n        return reference_timestamp + time_object.total_seconds()\n    if isinstance(time_object, (int, float)):\n        return reference_timestamp + time_object\n\n    if tzinfo is None:\n        tzinfo = UTC\n\n    if isinstance(time_object, dtm.time):\n        reference_dt = dtm.datetime.fromtimestamp(\n            reference_timestamp, tz=time_object.tzinfo or tzinfo\n        )\n        reference_date = reference_dt.date()\n        reference_time = reference_dt.timetz()\n\n        aware_datetime = dtm.datetime.combine(reference_date, time_object)\n        if aware_datetime.tzinfo is None:\n            aware_datetime = _localize(aware_datetime, tzinfo)\n\n        # if the time of day has passed today, use tomorrow\n        if reference_time > aware_datetime.timetz():\n            aware_datetime += dtm.timedelta(days=1)\n        return _datetime_to_float_timestamp(aware_datetime)\n    if isinstance(time_object, dtm.datetime):\n        if time_object.tzinfo is None:\n            time_object = _localize(time_object, tzinfo)\n        return _datetime_to_float_timestamp(time_object)\n\n    raise TypeError(f\"Unable to convert {type(time_object).__name__} object to timestamp\")",
    "smell": []
}