{
    "code": "def _thread_run(self, **kwargs):\n            input_fn = kwargs.get('input_fn')\n            queue = kwargs.get('queue')\n            device = kwargs.get('device')\n            drs = kwargs.get('default_ranges').get\n            touches = {}\n            touches_sent = []\n            l_points = {}\n\n            # prepare some vars to get limit of some component\n            range_min_position_x = 0\n            range_max_position_x = 2048\n            range_min_position_y = 0\n            range_max_position_y = 2048\n            range_min_pressure = 0\n            range_max_pressure = 255\n            invert_x = int(bool(drs('invert_x', 0)))\n            invert_y = int(bool(drs('invert_y', 0)))\n            reset_touch = False\n\n            def process(points):\n                actives = list(points.keys())\n                for args in points.values():\n                    tid = args['id']\n                    try:\n                        touch = touches[tid]\n                    except KeyError:\n                        touch = LinuxWacomMotionEvent(device, tid, args)\n                        touches[touch.id] = touch\n                    if touch.sx == args['x'] \\\n                            and touch.sy == args['y'] \\\n                            and tid in touches_sent:\n                        continue\n                    touch.move(args)\n                    if tid not in touches_sent:\n                        queue.append(('begin', touch))\n                        touches_sent.append(tid)\n                    queue.append(('update', touch))\n\n                for tid in list(touches.keys())[:]:\n                    if tid not in actives:\n                        touch = touches[tid]\n                        if tid in touches_sent:\n                            touch.update_time_end()\n                            queue.append(('end', touch))\n                            touches_sent.remove(tid)\n                        del touches[tid]\n\n            def normalize(value, vmin, vmax):\n                return (value - vmin) / float(vmax - vmin)\n\n            # open the input\n            try:\n                fd = open(input_fn, 'rb')\n            except IOError:\n                Logger.exception('Unable to open %s' % input_fn)\n                return\n\n            # get the controler name (EVIOCGNAME)\n            device_name = fcntl.ioctl(fd, EVIOCGNAME + (256 << 16),\n                                      \" \" * 256).split('\\x00')[0]\n            Logger.info('LinuxWacom: using <%s>' % device_name)\n\n            # get abs infos\n            bit = fcntl.ioctl(fd, EVIOCGBIT + (EV_MAX << 16), ' ' * sz_l)\n            bit, = struct.unpack('Q', bit)\n            for x in range(EV_MAX):\n                # preserve this, we may want other things than EV_ABS\n                if x != EV_ABS:\n                    continue\n                # EV_ABS available for this device ?\n                if (bit & (1 << x)) == 0:\n                    continue\n                # ask abs info keys to the devices\n                sbit = fcntl.ioctl(fd, EVIOCGBIT + x + (KEY_MAX << 16),\n                                   ' ' * sz_l)\n                sbit, = struct.unpack('Q', sbit)\n                for y in range(KEY_MAX):\n                    if (sbit & (1 << y)) == 0:\n                        continue\n                    absinfo = fcntl.ioctl(fd, EVIOCGABS + y +\n                                          (struct_input_absinfo_sz << 16),\n                                          ' ' * struct_input_absinfo_sz)\n                    abs_value, abs_min, abs_max, abs_fuzz, \\\n                        abs_flat, abs_res = struct.unpack('iiiiii', absinfo)\n                    if y == ABS_X:\n                        range_min_position_x = drs('min_position_x', abs_min)\n                        range_max_position_x = drs('max_position_x', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position X is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_Y:\n                        range_min_position_y = drs('min_position_y', abs_min)\n                        range_max_position_y = drs('max_position_y', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range position Y is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n                    elif y == ABS_PRESSURE:\n                        range_min_pressure = drs('min_pressure', abs_min)\n                        range_max_pressure = drs('max_pressure', abs_max)\n                        Logger.info('LinuxWacom: ' +\n                                    '<%s> range pressure is %d - %d' % (\n                                        device_name, abs_min, abs_max))\n\n            # read until the end\n            changed = False\n            touch_id = 0\n            touch_x = 0\n            touch_y = 0\n            touch_pressure = 0\n            while fd:\n\n                data = fd.read(struct_input_event_sz)\n                if len(data) < struct_input_event_sz:\n                    break\n\n                # extract each event\n                for i in range(len(data) / struct_input_event_sz):\n                    ev = data[i * struct_input_event_sz:]\n\n                    # extract timeval + event infos\n                    tv_sec, tv_usec, ev_type, ev_code, ev_value = \\\n                        struct.unpack('LLHHi', ev[:struct_input_event_sz])\n\n                    if ev_type == EV_SYN and ev_code == SYN_REPORT:\n                        if touch_id in l_points:\n                            p = l_points[touch_id]\n                        else:\n                            p = dict()\n                            l_points[touch_id] = p\n                        p['id'] = touch_id\n                        if not reset_touch:\n                            p['x'] = touch_x\n                            p['y'] = touch_y\n                            p['pressure'] = touch_pressure\n                        if self.mode == 'pen' \\\n                                and touch_pressure == 0 \\\n                                and not reset_touch:\n                            del l_points[touch_id]\n                        if changed:\n                            if 'x' not in p:\n                                reset_touch = False\n                                continue\n                            process(l_points)\n                            changed = False\n                        if reset_touch:\n                            l_points.clear()\n                            reset_touch = False\n                            process(l_points)\n                    elif ev_type == EV_MSC and ev_code == MSC_SERIAL:\n                        touch_id = ev_value\n                    elif ev_type == EV_ABS and ev_code == ABS_X:\n                        val = normalize(ev_value,\n                                        range_min_position_x,\n                                        range_max_position_x)\n                        if invert_x:\n                            val = 1. - val\n                        touch_x = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_Y:\n                        val = 1. - normalize(ev_value,\n                                             range_min_position_y,\n                                             range_max_position_y)\n                        if invert_y:\n                            val = 1. - val\n                        touch_y = val\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_PRESSURE:\n                        touch_pressure = normalize(ev_value,\n                                                   range_min_pressure,\n                                                   range_max_pressure)\n                        changed = True\n                    elif ev_type == EV_ABS and ev_code == ABS_MISC:\n                        if ev_value == 0:\n                            reset_touch = True",
    "smell": []
}