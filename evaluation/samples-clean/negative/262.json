{
    "code": "def install_given_reqs(\n    requirements: List[InstallRequirement],\n    global_options: Sequence[str],\n    root: Optional[str],\n    home: Optional[str],\n    prefix: Optional[str],\n    warn_script_location: bool,\n    use_user_site: bool,\n    pycompile: bool,\n) -> List[InstallationResult]:\n    \"\"\"\n    Install everything in the given list.\n\n    (to be called after having downloaded and unpacked the packages)\n    \"\"\"\n    to_install = collections.OrderedDict(_validate_requirements(requirements))\n\n    if to_install:\n        logger.info(\n            \"Installing collected packages: %s\",\n            \", \".join(to_install.keys()),\n        )\n\n    installed = []\n\n    with indent_log():\n        for req_name, requirement in to_install.items():\n            if requirement.should_reinstall:\n                logger.info(\"Attempting uninstall: %s\", req_name)\n                with indent_log():\n                    uninstalled_pathset = requirement.uninstall(auto_confirm=True)\n            else:\n                uninstalled_pathset = None\n\n            try:\n                requirement.install(\n                    global_options,\n                    root=root,\n                    home=home,\n                    prefix=prefix,\n                    warn_script_location=warn_script_location,\n                    use_user_site=use_user_site,\n                    pycompile=pycompile,\n                )\n            except Exception:\n                # if install did not succeed, rollback previous uninstall\n                if uninstalled_pathset and not requirement.install_succeeded:\n                    uninstalled_pathset.rollback()\n                raise\n            else:\n                if uninstalled_pathset and requirement.install_succeeded:\n                    uninstalled_pathset.commit()\n\n            installed.append(InstallationResult(req_name))\n\n    return installed",
    "smell": []
}