{
    "code": "def _get_next_task_lockstep(self, hosts, iterator):\n        '''\n        Returns a list of (host, task) tuples, where the task may\n        be a noop task to keep the iterator in lock step across\n        all hosts.\n        '''\n\n        noop_task = Task()\n        noop_task.action = 'meta'\n        noop_task.args['_raw_params'] = 'noop'\n        noop_task.set_loader(iterator._play._loader)\n\n        host_tasks = {}\n        display.debug(\"building list of next tasks for hosts\")\n        for host in hosts:\n            host_tasks[host.name] = iterator.get_next_task_for_host(host, peek=True)\n        display.debug(\"done building task lists\")\n\n        num_setups = 0\n        num_tasks  = 0\n        num_rescue = 0\n        num_always = 0\n\n        display.debug(\"counting tasks in each state of execution\")\n        host_tasks_to_run = [(host, state_task)\n                             for host, state_task in iteritems(host_tasks)\n                             if state_task and state_task[1]]\n\n        if host_tasks_to_run:\n            try:\n                lowest_cur_block = min(\n                    (s.cur_block for h, (s, t) in host_tasks_to_run\n                    if s.run_state != PlayIterator.ITERATING_COMPLETE))\n            except ValueError:\n                lowest_cur_block = None\n        else:\n            # empty host_tasks_to_run will just run till the end of the function\n            # without ever touching lowest_cur_block\n            lowest_cur_block = None\n\n        for (k, v) in host_tasks_to_run:\n            (s, t) = v\n\n            if s.cur_block > lowest_cur_block:\n                # Not the current block, ignore it\n                continue\n\n            if s.run_state == PlayIterator.ITERATING_SETUP:\n                num_setups += 1\n            elif s.run_state == PlayIterator.ITERATING_TASKS:\n                num_tasks += 1\n            elif s.run_state == PlayIterator.ITERATING_RESCUE:\n                num_rescue += 1\n            elif s.run_state == PlayIterator.ITERATING_ALWAYS:\n                num_always += 1\n        display.debug(\"done counting tasks in each state of execution:\\n\\tnum_setups: %s\\n\\tnum_tasks: %s\\n\\tnum_rescue: %s\\n\\tnum_always: %s\" % (num_setups, num_tasks, num_rescue, num_always))\n\n        def _advance_selected_hosts(hosts, cur_block, cur_state):\n            '''\n            This helper returns the task for all hosts in the requested\n            state, otherwise they get a noop dummy task. This also advances\n            the state of the host, since the given states are determined\n            while using peek=True.\n            '''\n            # we return the values in the order they were originally\n            # specified in the given hosts array\n            rvals = []\n            display.debug(\"starting to advance hosts\")\n            for host in hosts:\n                host_state_task = host_tasks.get(host.name)\n                if host_state_task is None:\n                    continue\n                (s, t) = host_state_task\n                if t is None:\n                    continue\n                if s.run_state == cur_state and s.cur_block == cur_block:\n                    new_t = iterator.get_next_task_for_host(host)\n                    rvals.append((host, t))\n                else:\n                    rvals.append((host, noop_task))\n            display.debug(\"done advancing hosts to next task\")\n            return rvals\n\n        # if any hosts are in ITERATING_SETUP, return the setup task\n        # while all other hosts get a noop\n        if num_setups:\n            display.debug(\"advancing hosts in ITERATING_SETUP\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_SETUP)\n\n        # if any hosts are in ITERATING_TASKS, return the next normal\n        # task for these hosts, while all other hosts get a noop\n        if num_tasks:\n            display.debug(\"advancing hosts in ITERATING_TASKS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_TASKS)\n\n        # if any hosts are in ITERATING_RESCUE, return the next rescue\n        # task for these hosts, while all other hosts get a noop\n        if num_rescue:\n            display.debug(\"advancing hosts in ITERATING_RESCUE\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_RESCUE)\n\n        # if any hosts are in ITERATING_ALWAYS, return the next always\n        # task for these hosts, while all other hosts get a noop\n        if num_always:\n            display.debug(\"advancing hosts in ITERATING_ALWAYS\")\n            return _advance_selected_hosts(hosts, lowest_cur_block, PlayIterator.ITERATING_ALWAYS)\n\n        # at this point, everything must be ITERATING_COMPLETE, so we\n        # return None for all hosts in the list\n        display.debug(\"all hosts are done, so returning None's for all hosts\")\n        return [(host, None) for host in hosts]",
    "smell": []
}