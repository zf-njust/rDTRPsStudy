{
    "code": "def __init__(\n      self,\n      config: ExperimentConfig,\n      prog_task: base_task.Task,  # also implemented ProgressivePolicy.\n      ckpt_dir: str = '',\n      train: bool = True,\n      evaluate: bool = True,\n      checkpoint_exporter: Any = None):\n    \"\"\"Initialize common trainer for TensorFlow models.\n\n    Args:\n      config: An `ExperimentConfig` instance specifying experiment config.\n      prog_task: An instance both implemented policies.ProgressivePolicy and\n        base_task.Task.\n      ckpt_dir: Checkpoint directory.\n      train: bool, whether or not this trainer will be used for training.\n        default to True.\n      evaluate: bool, whether or not this trainer will be used for evaluation.\n        default to True.\n      checkpoint_exporter: an object that has the `maybe_export_checkpoint`\n        interface.\n    \"\"\"\n    # Gets the current distribution strategy. If not inside any strategy scope,\n    # it gets a single-replica no-op strategy.\n    self._strategy = tf.distribute.get_strategy()\n    self._config = config\n    self._runtime_options = trainer_lib.get_runtime_options(config)\n    self._task = prog_task\n\n    # Directory for non-progressive checkpoint\n    self._export_ckpt_dir = os.path.join(ckpt_dir, 'exported_ckpts')\n    tf.io.gfile.makedirs(self._export_ckpt_dir)\n    self._export_ckpt_manager = None\n\n    # Receive other checkpoint export, e.g, best checkpoint exporter.\n    # TODO(lehou): unify the checkpoint exporting logic, although the default\n    # setting does not use checkpoint_exporter.\n    self._checkpoint_exporter = checkpoint_exporter\n\n    self._global_step = orbit.utils.create_global_step()\n\n    self._checkpoint = utils.CheckpointWithHooks(\n        before_load_hook=self._update_pt_stage_from_ckpt,\n        global_step=self.global_step,\n        **self._task.cur_checkpoint_items)\n\n    self._train_loss = tf.keras.metrics.Mean('training_loss', dtype=tf.float32)\n    self._validation_loss = tf.keras.metrics.Mean(\n        'validation_loss', dtype=tf.float32)\n    self._train_metrics = self.task.build_metrics(\n        training=True) + self.model.metrics\n    self._validation_metrics = self.task.build_metrics(\n        training=False) + self.model.metrics\n\n    if train:\n      orbit.StandardTrainer.__init__(\n          self,\n          None,  # Manage train_dataset by ourselves, not by StandardTrainer.\n          options=orbit.StandardTrainerOptions(\n              use_tf_while_loop=config.trainer.train_tf_while_loop,\n              use_tf_function=config.trainer.train_tf_function))\n\n    if evaluate:\n      orbit.StandardEvaluator.__init__(\n          self,\n          None,  # Manage train_dataset by ourselves, not by StandardEvaluator.\n          options=orbit.StandardEvaluatorOptions(\n              use_tf_function=config.trainer.eval_tf_function))",
    "smell": []
}