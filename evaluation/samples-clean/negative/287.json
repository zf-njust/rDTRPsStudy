{
    "code": "def score_target_hypo(\n    args, a, b, c, lenpen, target_outfile, hypo_outfile, write_hypos, normalize\n):\n\n    print(\"lenpen\", lenpen, \"weight1\", a, \"weight2\", b, \"weight3\", c)\n    gen_output_lst, bitext1_lst, bitext2_lst, lm_res_lst = load_score_files(args)\n    dict = dictionary.Dictionary()\n    scorer = scorer = bleu.Scorer(\n        bleu.BleuConfig(\n            pad=dict.pad(),\n            eos=dict.eos(),\n            unk=dict.unk(),\n        )\n    )\n\n    ordered_hypos = {}\n    ordered_targets = {}\n\n    for shard_id in range(len(bitext1_lst)):\n        bitext1 = bitext1_lst[shard_id]\n        bitext2 = bitext2_lst[shard_id]\n        gen_output = gen_output_lst[shard_id]\n        lm_res = lm_res_lst[shard_id]\n\n        total = len(bitext1.rescore_source.keys())\n        source_lst = []\n        hypo_lst = []\n        score_lst = []\n        reference_lst = []\n        j = 1\n        best_score = -math.inf\n\n        for i in range(total):\n            # length is measured in terms of words, not bpe tokens, since models may not share the same bpe\n            target_len = len(bitext1.rescore_hypo[i].split())\n\n            if lm_res is not None:\n                lm_score = lm_res.score[i]\n            else:\n                lm_score = 0\n\n            if bitext2 is not None:\n                bitext2_score = bitext2.rescore_score[i]\n                bitext2_backwards = bitext2.backwards\n            else:\n                bitext2_score = None\n                bitext2_backwards = None\n\n            score = rerank_utils.get_score(\n                a,\n                b,\n                c,\n                target_len,\n                bitext1.rescore_score[i],\n                bitext2_score,\n                lm_score=lm_score,\n                lenpen=lenpen,\n                src_len=bitext1.source_lengths[i],\n                tgt_len=bitext1.target_lengths[i],\n                bitext1_backwards=bitext1.backwards,\n                bitext2_backwards=bitext2_backwards,\n                normalize=normalize,\n            )\n\n            if score > best_score:\n                best_score = score\n                best_hypo = bitext1.rescore_hypo[i]\n\n            if j == gen_output.num_hypos[i] or j == args.num_rescore:\n                j = 1\n                hypo_lst.append(best_hypo)\n                score_lst.append(best_score)\n                source_lst.append(bitext1.rescore_source[i])\n                reference_lst.append(bitext1.rescore_target[i])\n\n                best_score = -math.inf\n                best_hypo = \"\"\n            else:\n                j += 1\n\n        gen_keys = list(sorted(gen_output.no_bpe_target.keys()))\n\n        for key in range(len(gen_keys)):\n            if args.prefix_len is None:\n                assert hypo_lst[key] in gen_output.no_bpe_hypo[gen_keys[key]], (\n                    \"pred and rescore hypo mismatch: i: \"\n                    + str(key)\n                    + \", \"\n                    + str(hypo_lst[key])\n                    + str(gen_keys[key])\n                    + str(gen_output.no_bpe_hypo[key])\n                )\n                sys_tok = dict.encode_line(hypo_lst[key])\n                ref_tok = dict.encode_line(gen_output.no_bpe_target[gen_keys[key]])\n                scorer.add(ref_tok, sys_tok)\n\n            else:\n                full_hypo = rerank_utils.get_full_from_prefix(\n                    hypo_lst[key], gen_output.no_bpe_hypo[gen_keys[key]]\n                )\n                sys_tok = dict.encode_line(full_hypo)\n                ref_tok = dict.encode_line(gen_output.no_bpe_target[gen_keys[key]])\n                scorer.add(ref_tok, sys_tok)\n\n        # if only one set of hyper parameters is provided, write the predictions to a file\n        if write_hypos:\n            # recover the orinal ids from n best list generation\n            for key in range(len(gen_output.no_bpe_target)):\n                if args.prefix_len is None:\n                    assert hypo_lst[key] in gen_output.no_bpe_hypo[gen_keys[key]], (\n                        \"pred and rescore hypo mismatch:\"\n                        + \"i:\"\n                        + str(key)\n                        + str(hypo_lst[key])\n                        + str(gen_output.no_bpe_hypo[key])\n                    )\n                    ordered_hypos[gen_keys[key]] = hypo_lst[key]\n                    ordered_targets[gen_keys[key]] = gen_output.no_bpe_target[\n                        gen_keys[key]\n                    ]\n\n                else:\n                    full_hypo = rerank_utils.get_full_from_prefix(\n                        hypo_lst[key], gen_output.no_bpe_hypo[gen_keys[key]]\n                    )\n                    ordered_hypos[gen_keys[key]] = full_hypo\n                    ordered_targets[gen_keys[key]] = gen_output.no_bpe_target[\n                        gen_keys[key]\n                    ]\n\n    # write the hypos in the original order from nbest list generation\n    if args.num_shards == (len(bitext1_lst)):\n        with open(target_outfile, \"w\") as t:\n            with open(hypo_outfile, \"w\") as h:\n                for key in range(len(ordered_hypos)):\n                    t.write(ordered_targets[key])\n                    h.write(ordered_hypos[key])\n\n    res = scorer.result_string(4)\n    if write_hypos:\n        print(res)\n    score = rerank_utils.parse_bleu_scoring(res)\n    return score",
    "smell": []
}