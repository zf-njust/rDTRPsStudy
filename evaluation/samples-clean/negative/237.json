{
    "code": "def _log_object_sources(\n    max_objects: int, last_ids: set[int], last_stats: dict[str, int]\n) -> None:\n    # Imports deferred to avoid loading modules\n    # in memory since usually only one part of this\n    # integration is used at a time\n    import gc  # pylint: disable=import-outside-toplevel\n\n    gc.collect()\n\n    objects = gc.get_objects()\n    new_objects: list[object] = []\n    new_objects_overflow: dict[str, int] = {}\n    current_ids = set()\n    new_stats: dict[str, int] = {}\n    had_new_object_growth = False\n    try:\n        for _object in objects:\n            object_type = type(_object).__name__\n            new_stats[object_type] = new_stats.get(object_type, 0) + 1\n\n        for _object in objects:\n            id_ = id(_object)\n            current_ids.add(id_)\n            if id_ in last_ids:\n                continue\n            object_type = type(_object).__name__\n            if last_stats.get(object_type, 0) < new_stats[object_type]:\n                if len(new_objects) < max_objects:\n                    new_objects.append(_object)\n                else:\n                    new_objects_overflow.setdefault(object_type, 0)\n                    new_objects_overflow[object_type] += 1\n\n        for _object in new_objects:\n            had_new_object_growth = True\n            object_type = type(_object).__name__\n            _LOGGER.critical(\n                \"New object %s (%s/%s) at %s: %s\",\n                object_type,\n                last_stats.get(object_type, 0),\n                new_stats[object_type],\n                _get_function_absfile(_object) or _find_backrefs_not_to_self(_object),\n                _safe_repr(_object),\n            )\n\n        for object_type, count in last_stats.items():\n            new_stats[object_type] = max(new_stats.get(object_type, 0), count)\n    finally:\n        # Break reference cycles\n        del objects\n        del new_objects\n        last_ids.clear()\n        last_ids.update(current_ids)\n        last_stats.clear()\n        last_stats.update(new_stats)\n        del new_stats\n        del current_ids\n\n    if new_objects_overflow:\n        _LOGGER.critical(\"New objects overflowed by %s\", new_objects_overflow)\n    elif not had_new_object_growth:\n        _LOGGER.critical(\"No new object growth found\")",
    "smell": []
}