{
    "code": "def check_shortcut_signature(\n    shortcut: Callable,\n    bot_method: Callable,\n    shortcut_kwargs: List[str],\n    additional_kwargs: List[str],\n) -> bool:\n    \"\"\"\n    Checks that the signature of a shortcut matches the signature of the underlying bot method.\n\n    Args:\n        shortcut: The shortcut, e.g. :meth:`telegram.Message.reply_text`\n        bot_method: The bot method, e.g. :meth:`telegram.Bot.send_message`\n        shortcut_kwargs: The kwargs passed by the shortcut directly, e.g. ``chat_id``\n        additional_kwargs: Additional kwargs of the shortcut that the bot method doesn't have, e.g.\n            ``quote``.\n\n    Returns:\n        :obj:`bool`: Whether or not the signature matches.\n    \"\"\"\n\n    def resolve_class(class_name: str) -> Optional[type]:\n        \"\"\"Attempts to resolve a PTB class (telegram module only) from a ForwardRef.\n\n        E.g. resolves <class 'telegram._files.sticker.StickerSet'> from \"StickerSet\".\n\n        Returns a class on success, :obj:`None` if nothing could be resolved.\n        \"\"\"\n        for module in telegram, telegram.request:\n            cls = getattr(module, class_name, None)\n            if cls is not None:\n                return cls\n        return None  # for ruff\n\n    shortcut_sig = inspect.signature(shortcut)\n    effective_shortcut_args = set(shortcut_sig.parameters.keys()).difference(additional_kwargs)\n    effective_shortcut_args.discard(\"self\")\n\n    bot_sig = inspect.signature(bot_method)\n    expected_args = set(bot_sig.parameters.keys()).difference(shortcut_kwargs)\n    expected_args.discard(\"self\")\n\n    args_check = expected_args == effective_shortcut_args\n    if not args_check:\n        raise Exception(f\"Expected arguments {expected_args}, got {effective_shortcut_args}\")\n\n    # TODO: Also check annotation of return type. Would currently be a hassle b/c typing doesn't\n    # resolve `ForwardRef('Type')` to `Type`. For now we rely on MyPy, which probably allows the\n    # shortcuts to return more specific types than the bot method, but it's only annotations after\n    # all\n    for kwarg in effective_shortcut_args:\n        expected_kind = bot_sig.parameters[kwarg].kind\n        if shortcut_sig.parameters[kwarg].kind != expected_kind:\n            raise Exception(f\"Argument {kwarg} must be of kind {expected_kind}.\")\n\n        if bot_sig.parameters[kwarg].annotation != shortcut_sig.parameters[kwarg].annotation:\n            if FORWARD_REF_PATTERN.search(str(shortcut_sig.parameters[kwarg])):\n                # If a shortcut signature contains a ForwardRef, the simple comparison of\n                # annotations can fail. Try and resolve the .__args__, then compare them.\n\n                for shortcut_arg, bot_arg in zip(\n                    shortcut_sig.parameters[kwarg].annotation.__args__,\n                    bot_sig.parameters[kwarg].annotation.__args__,\n                ):\n                    shortcut_arg_to_check = shortcut_arg  # for ruff\n                    match = FORWARD_REF_PATTERN.search(str(shortcut_arg))\n                    if match:\n                        shortcut_arg_to_check = resolve_class(match.group(\"class_name\"))\n\n                    if shortcut_arg_to_check != bot_arg:\n                        raise Exception(\n                            f\"For argument {kwarg} I expected \"\n                            f\"{bot_sig.parameters[kwarg].annotation}, but \"\n                            f\"got {shortcut_sig.parameters[kwarg].annotation}.\"\n                            f\"Comparison of {shortcut_arg} and {bot_arg} failed.\"\n                        )\n            elif isinstance(bot_sig.parameters[kwarg].annotation, type):\n                if bot_sig.parameters[kwarg].annotation.__name__ != str(\n                    shortcut_sig.parameters[kwarg].annotation\n                ):\n                    raise Exception(\n                        f\"For argument {kwarg} I expected {bot_sig.parameters[kwarg].annotation}, \"\n                        f\"but got {shortcut_sig.parameters[kwarg].annotation}\"\n                    )\n            else:\n                raise Exception(\n                    f\"For argument {kwarg} I expected {bot_sig.parameters[kwarg].annotation},\"\n                    f\"but got {shortcut_sig.parameters[kwarg].annotation}\"\n                )\n\n    bot_method_sig = inspect.signature(bot_method)\n    shortcut_sig = inspect.signature(shortcut)\n    for arg in expected_args:\n        if not shortcut_sig.parameters[arg].default == bot_method_sig.parameters[arg].default:\n            raise Exception(\n                f\"Default for argument {arg} does not match the default of the Bot method.\"\n            )\n\n    for kwarg in additional_kwargs:\n        if not shortcut_sig.parameters[kwarg].kind == inspect.Parameter.KEYWORD_ONLY:\n            raise Exception(f\"Argument {kwarg} must be a positional-only argument!\")\n\n    return True",
    "smell": []
}