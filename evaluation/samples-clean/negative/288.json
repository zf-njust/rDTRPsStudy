{
    "code": "def async_calculate_period(\n    duration: datetime.timedelta | None,\n    start_template: Template | None,\n    end_template: Template | None,\n) -> tuple[datetime.datetime, datetime.datetime]:\n    \"\"\"Parse the templates and return the period.\"\"\"\n    bounds: dict[str, datetime.datetime | None] = {\n        DURATION_START: None,\n        DURATION_END: None,\n    }\n    for bound, template in (\n        (DURATION_START, start_template),\n        (DURATION_END, end_template),\n    ):\n        # Parse start\n        if template is None:\n            continue\n        try:\n            rendered = template.async_render()\n        except (TemplateError, TypeError) as ex:\n            if ex.args and not ex.args[0].startswith(\n                \"UndefinedError: 'None' has no attribute\"\n            ):\n                _LOGGER.error(\"Error parsing template for field %s\", bound, exc_info=ex)\n            raise\n        if isinstance(rendered, str):\n            bounds[bound] = dt_util.parse_datetime(rendered)\n        if bounds[bound] is not None:\n            continue\n        try:\n            bounds[bound] = dt_util.as_local(\n                dt_util.utc_from_timestamp(math.floor(float(rendered)))\n            )\n        except ValueError as ex:\n            raise ValueError(\n                f\"Parsing error: {bound} must be a datetime or a timestamp: {ex}\"\n            ) from ex\n\n    start = bounds[DURATION_START]\n    end = bounds[DURATION_END]\n\n    # Calculate start or end using the duration\n    if start is None:\n        assert end is not None\n        assert duration is not None\n        start = end - duration\n    if end is None:\n        assert start is not None\n        assert duration is not None\n        end = start + duration\n\n    return start, end",
    "smell": []
}