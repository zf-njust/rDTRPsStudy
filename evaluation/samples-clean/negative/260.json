{
    "code": "def rolling(  # pylint: disable=too-many-arguments\n    df: DataFrame,\n    rolling_type: str,\n    columns: dict[str, str],\n    window: Optional[int] = None,\n    rolling_type_options: Optional[dict[str, Any]] = None,\n    center: bool = False,\n    win_type: Optional[str] = None,\n    min_periods: Optional[int] = None,\n) -> DataFrame:\n    \"\"\"\n    Apply a rolling window on the dataset. See the Pandas docs for further details:\n    https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html\n\n    :param df: DataFrame on which the rolling period will be based.\n    :param columns: columns on which to perform rolling, mapping source column to\n           target column. For instance, `{'y': 'y'}` will replace the column `y` with\n           the rolling value in `y`, while `{'y': 'y2'}` will add a column `y2` based\n           on rolling values calculated from `y`, leaving the original column `y`\n           unchanged.\n    :param rolling_type: Type of rolling window. Any numpy function will work.\n    :param window: Size of the window.\n    :param rolling_type_options: Optional options to pass to rolling method. Needed\n           for e.g. quantile operation.\n    :param center: Should the label be at the center of the window.\n    :param win_type: Type of window function.\n    :param min_periods: The minimum amount of periods required for a row to be included\n                        in the result set.\n    :return: DataFrame with the rolling columns\n    :raises InvalidPostProcessingError: If the request in incorrect\n    \"\"\"\n    rolling_type_options = rolling_type_options or {}\n    df_rolling = df.loc[:, columns.keys()]\n\n    kwargs: dict[str, Union[str, int]] = {}\n    if window is None:\n        raise InvalidPostProcessingError(_(\"Undefined window for rolling operation\"))\n    if window == 0:\n        raise InvalidPostProcessingError(_(\"Window must be > 0\"))\n\n    kwargs[\"window\"] = window\n    if min_periods is not None:\n        kwargs[\"min_periods\"] = min_periods\n    if center is not None:\n        kwargs[\"center\"] = center\n    if win_type is not None:\n        kwargs[\"win_type\"] = win_type\n\n    df_rolling = df_rolling.rolling(**kwargs)\n    if rolling_type not in DENYLIST_ROLLING_FUNCTIONS or not hasattr(\n        df_rolling, rolling_type\n    ):\n        raise InvalidPostProcessingError(\n            _(\"Invalid rolling_type: %(type)s\", type=rolling_type)\n        )\n    try:\n        df_rolling = getattr(df_rolling, rolling_type)(**rolling_type_options)\n    except TypeError as ex:\n        raise InvalidPostProcessingError(\n            _(\n                \"Invalid options for %(rolling_type)s: %(options)s\",\n                rolling_type=rolling_type,\n                options=rolling_type_options,\n            )\n        ) from ex\n\n    df_rolling = _append_columns(df, df_rolling, columns)\n\n    if min_periods:\n        df_rolling = df_rolling[min_periods:]\n    return df_rolling",
    "smell": []
}