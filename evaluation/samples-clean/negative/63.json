{
    "code": "def combined_roidb_for_training(dataset_names, proposal_files):\n    \"\"\"Load and concatenate roidbs for one or more datasets, along with optional\n    object proposals. The roidb entries are then prepared for use in training,\n    which involves caching certain types of metadata for each roidb entry.\n    \"\"\"\n    def get_roidb(dataset_name, proposal_file):\n        ds = JsonDataset(dataset_name)\n        roidb = ds.get_roidb(\n            gt=True,\n            proposal_file=proposal_file,\n            crowd_filter_thresh=cfg.TRAIN.CROWD_FILTER_THRESH\n        )\n        if cfg.TRAIN.USE_FLIPPED:\n            logger.info('Appending horizontally-flipped training examples...')\n            extend_with_flipped_entries(roidb, ds)\n        logger.info('Loaded dataset: {:s}'.format(ds.name))\n        return roidb\n\n    if isinstance(dataset_names, basestring):\n        dataset_names = (dataset_names, )\n    if isinstance(proposal_files, basestring):\n        proposal_files = (proposal_files, )\n    if len(proposal_files) == 0:\n        proposal_files = (None, ) * len(dataset_names)\n    assert len(dataset_names) == len(proposal_files)\n    roidbs = [get_roidb(*args) for args in zip(dataset_names, proposal_files)]\n    roidb = roidbs[0]\n    for r in roidbs[1:]:\n        roidb.extend(r)\n    roidb = filter_for_training(roidb)\n\n    logger.info('Computing bounding-box regression targets...')\n    add_bbox_regression_targets(roidb)\n    logger.info('done')\n\n    _compute_and_log_stats(roidb)\n\n    return roidb",
    "smell": []
}