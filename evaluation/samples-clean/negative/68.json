{
    "code": "def check_forward_backward(self):\n        def test_with_place(place):\n            out_grad = np.random.random_sample(self.x.shape).astype(np.float32)\n            x_grad = out_grad\n            sum_axis = list(range(0, len(self.x.shape)))\n            del sum_axis[self.axis]\n            y_grad = np.sum(out_grad, axis=tuple(sum_axis))\n\n            var_dict = locals()\n            var_dict['y'] = self.y\n            var_dict['x'] = self.x\n            var_dict['out'] = self.out\n            var_dict['y@GRAD'] = y_grad\n            var_dict['x@GRAD'] = x_grad\n            var_dict['out@GRAD'] = out_grad\n\n            var_names = ['x', 'y', 'out', 'y@GRAD', 'x@GRAD', 'out@GRAD']\n            ground_truth = {name: var_dict[name] for name in var_names}\n\n            program = fluid.Program()\n            with fluid.program_guard(program):\n                block = program.global_block()\n                for name in ground_truth:\n                    block.create_var(\n                        name=name,\n                        dtype='float32',\n                        shape=ground_truth[name].shape)\n                elementwise_add_op = block.append_op(\n                    type=\"elementwise_add\",\n                    inputs={\n                        \"X\": block.var('x'),\n                        \"Y\": block.var('y'),\n                    },\n                    outputs={\"Out\": block.var('out'), },\n                    attrs={\"axis\": self.axis, })\n\n                # generate backward op_desc\n                grad_op_desc_list, op_grad_to_var = core.get_grad_op_desc(\n                    elementwise_add_op.desc, set(), [])\n                grad_op_desc = grad_op_desc_list[0]\n                new_op_desc = block.desc.append_op()\n                new_op_desc.copy_from(grad_op_desc)\n                for var_name in grad_op_desc.output_arg_names():\n                    block.desc.var(var_name.encode(\"ascii\"))\n                grad_op_desc.infer_var_type(block.desc)\n                grad_op_desc.infer_shape(block.desc)\n                for arg in grad_op_desc.output_arg_names():\n                    grad_var = block.desc.find_var(arg.encode(\"ascii\"))\n                    grad_var.set_dtype(core.VarDesc.VarType.FP32)\n\n                exe = fluid.Executor(place)\n                out = exe.run(program,\n                              feed={\n                                  name: var_dict[name]\n                                  for name in ['x', 'y', 'out@GRAD']\n                              },\n                              fetch_list=['x@GRAD', 'y@GRAD'])\n                self.__assert_close(x_grad, out[0], \"x@GRAD\")\n                self.__assert_close(y_grad, out[1], \"y@GRAD\", atol=1.4)\n\n        places = [core.CPUPlace()]\n        if core.is_compiled_with_cuda() and core.op_support_gpu(\n                \"elementwise_add\"):\n            places.append(core.CUDAPlace(0))\n\n        for place in places:\n            test_with_place(place)",
    "smell": []
}