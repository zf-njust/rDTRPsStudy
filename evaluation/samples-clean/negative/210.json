{
    "code": "def run(\n    cmd: Union[str, List[str]],\n    print_error=True,\n    asynchronous=False,\n    stdin=False,\n    stderr=subprocess.STDOUT,\n    outfile=None,\n    env_vars: Optional[Dict[AnyStr, AnyStr]] = None,\n    inherit_cwd=False,\n    inherit_env=True,\n    tty=False,\n    shell=True,\n    cwd: str = None,\n) -> Union[str, subprocess.Popen]:\n    LOG.debug(\"Executing command: %s\", cmd)\n    env_dict = os.environ.copy() if inherit_env else {}\n    if env_vars:\n        env_dict.update(env_vars)\n    env_dict = {k: to_str(str(v)) for k, v in env_dict.items()}\n\n    if isinstance(cmd, list):\n        # See docs of subprocess.Popen(...):\n        #  \"On POSIX with shell=True, the shell defaults to /bin/sh. If args is a string,\n        #   the string specifies the command to execute through the shell. [...] If args is\n        #   a sequence, the first item specifies the command string, and any additional\n        #   items will be treated as additional arguments to the shell itself.\"\n        # Hence, we should *disable* shell mode here to be on the safe side, to prevent\n        #  arguments in the cmd list from leaking into arguments to the shell itself. This will\n        #  effectively allow us to call run(..) with both - str and list - as cmd argument, although\n        #  over time we should move from \"cmd: Union[str, List[str]]\" to \"cmd: List[str]\" only.\n        shell = False\n\n    if tty:\n        asynchronous = True\n        stdin = True\n\n    try:\n        if inherit_cwd and not cwd:\n            cwd = os.getcwd()\n        if not asynchronous:\n            if stdin:\n                return subprocess.check_output(\n                    cmd, shell=shell, stderr=stderr, env=env_dict, stdin=subprocess.PIPE, cwd=cwd\n                )\n            output = subprocess.check_output(cmd, shell=shell, stderr=stderr, env=env_dict, cwd=cwd)\n            return output.decode(config.DEFAULT_ENCODING)\n\n        stdin_arg = subprocess.PIPE if stdin else None\n        stdout_arg = open(outfile, \"ab\") if isinstance(outfile, str) else outfile\n        stderr_arg = stderr\n        if tty:\n            # Note: leave the \"pty\" import here (not supported in Windows)\n            import pty\n\n            master_fd, slave_fd = pty.openpty()\n            stdin_arg = slave_fd\n            stdout_arg = stderr_arg = None\n\n        # start the actual sub process\n        kwargs = {}\n        if is_linux() or is_mac_os():\n            kwargs[\"start_new_session\"] = True\n        process = subprocess.Popen(\n            cmd,\n            shell=shell,\n            stdin=stdin_arg,\n            bufsize=-1,\n            stderr=stderr_arg,\n            stdout=stdout_arg,\n            env=env_dict,\n            cwd=cwd,\n            **kwargs,\n        )\n\n        if tty:\n            # based on: https://stackoverflow.com/questions/41542960\n            def pipe_streams(*args):\n                while process.poll() is None:\n                    r, w, e = select.select([sys.stdin, master_fd], [], [])\n                    if sys.stdin in r:\n                        d = os.read(sys.stdin.fileno(), 10240)\n                        os.write(master_fd, d)\n                    elif master_fd in r:\n                        o = os.read(master_fd, 10240)\n                        if o:\n                            os.write(sys.stdout.fileno(), o)\n\n            FuncThread(pipe_streams, name=\"pipe-streams\").start()\n\n        return process\n    except subprocess.CalledProcessError as e:\n        if print_error:\n            print(\"ERROR: '%s': exit code %s; output: %s\" % (cmd, e.returncode, e.output))\n            sys.stdout.flush()\n        raise e",
    "smell": []
}