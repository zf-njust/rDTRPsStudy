{
    "code": "def run(\n        local_rank: int,\n        work_run: Callable,\n        main_address: str,\n        main_port: int,\n        num_nodes: int,\n        node_rank: int,\n        nprocs: int,\n    ):\n        fabrics = []\n        strategies = []\n        mps_accelerators = []\n\n        for pkg_name in (\"lightning.fabric\", \"lightning_\" + \"fabric\"):\n            try:\n                pkg = importlib.import_module(pkg_name)\n                fabrics.append(pkg.Fabric)\n                strategies.append(pkg.strategies.DDPStrategy)\n                mps_accelerators.append(pkg.accelerators.MPSAccelerator)\n            except (ImportError, ModuleNotFoundError):\n                continue\n\n        # Used to configure PyTorch progress group\n        os.environ[\"MASTER_ADDR\"] = main_address\n        os.environ[\"MASTER_PORT\"] = str(main_port)\n\n        # Used to hijack TorchElastic Cluster Environnement.\n        os.environ[\"GROUP_RANK\"] = str(node_rank)\n        os.environ[\"RANK\"] = str(local_rank + node_rank * nprocs)\n        os.environ[\"LOCAL_RANK\"] = str(local_rank)\n        os.environ[\"WORLD_SIZE\"] = str(num_nodes * nprocs)\n        os.environ[\"LOCAL_WORLD_SIZE\"] = str(nprocs)\n        os.environ[\"TORCHELASTIC_RUN_ID\"] = \"1\"\n\n        # Used to force Fabric to setup the distributed environnement.\n        os.environ[\"LT_CLI_USED\"] = \"1\"\n\n        # Used to pass information to Fabric directly.\n        def pre_fn(fabric, *args: Any, **kwargs: Any):\n            kwargs[\"devices\"] = nprocs\n            kwargs[\"num_nodes\"] = num_nodes\n\n            if any(acc.is_available() for acc in mps_accelerators):\n                old_acc_value = kwargs.get(\"accelerator\", \"auto\")\n                kwargs[\"accelerator\"] = \"cpu\"\n\n                if old_acc_value != kwargs[\"accelerator\"]:\n                    warnings.warn(\"Forcing `accelerator=cpu` as MPS does not support distributed training.\")\n            else:\n                kwargs[\"accelerator\"] = \"auto\"\n            strategy = kwargs.get(\"strategy\", None)\n            if strategy:\n                if isinstance(strategy, str):\n                    if strategy == \"ddp_spawn\":\n                        strategy = \"ddp\"\n                    elif strategy == \"ddp_sharded_spawn\":\n                        strategy = \"ddp_sharded\"\n                elif isinstance(strategy, tuple(strategies)) and strategy._start_method in (\"spawn\", \"fork\"):\n                    raise ValueError(\"DDP Spawned strategies aren't supported yet.\")\n\n            kwargs[\"strategy\"] = strategy\n\n            return {}, args, kwargs\n\n        tracer = Tracer()\n        for lf in fabrics:\n            tracer.add_traced(lf, \"__init__\", pre_fn=pre_fn)\n        tracer._instrument()\n        ret_val = work_run()\n        tracer._restore()\n        return ret_val",
    "smell": []
}