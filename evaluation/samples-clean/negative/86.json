{
    "code": "def run(self, tmp=None, task_vars=None):\n        ''' run the pause action module '''\n        if task_vars is None:\n            task_vars = dict()\n\n        result = super(ActionModule, self).run(tmp, task_vars)\n\n        duration_unit = 'minutes'\n        prompt = None\n        seconds = None\n        result.update(dict(\n            changed = False,\n            rc      = 0,\n            stderr  = '',\n            stdout  = '',\n            start   = None,\n            stop    = None,\n            delta   = None,\n        ))\n\n        # Is 'args' empty, then this is the default prompted pause\n        if self._task.args is None or len(self._task.args.keys()) == 0:\n            prompt = \"[%s]\\nPress enter to continue:\" % self._task.get_name().strip()\n\n        # Are 'minutes' or 'seconds' keys that exist in 'args'?\n        elif 'minutes' in self._task.args or 'seconds' in self._task.args:\n            try:\n                if 'minutes' in self._task.args:\n                    # The time() command operates in seconds so we need to\n                    # recalculate for minutes=X values.\n                    seconds = int(self._task.args['minutes']) * 60\n                else:\n                    seconds = int(self._task.args['seconds'])\n                    duration_unit = 'seconds'\n\n            except ValueError as e:\n                result['failed'] = True\n                result['msg'] = \"non-integer value given for prompt duration:\\n%s\" % str(e)\n                return result\n\n        # Is 'prompt' a key in 'args'?\n        elif 'prompt' in self._task.args:\n            prompt = \"[%s]\\n%s:\" % (self._task.get_name().strip(), self._task.args['prompt'])\n\n        else:\n            # I have no idea what you're trying to do. But it's so wrong.\n            result['failed'] = True\n            result['msg'] = \"invalid pause type given. must be one of: %s\" % \", \".join(self.PAUSE_TYPES)\n            return result\n\n        ########################################################################\n        # Begin the hard work!\n\n        start = time.time()\n        result['start'] = str(datetime.datetime.now())\n        result['user_input'] = ''\n\n        fd = None\n        old_settings = None\n        try:\n            if seconds is not None:\n                if seconds < 1:\n                    seconds = 1\n                # setup the alarm handler\n                signal.signal(signal.SIGALRM, timeout_handler)\n                signal.alarm(seconds)\n                # show the prompt\n                display.display(\"Pausing for %d seconds\" % seconds)\n                display.display(\"(ctrl+C then 'C' = continue early, ctrl+C then 'A' = abort)\\r\"),\n            else:\n                display.display(prompt)\n\n            # save the attributes on the existing (duped) stdin so\n            # that we can restore them later after we set raw mode\n            fd = None\n            try:\n                fd = self._connection._new_stdin.fileno()\n            except ValueError:\n                # someone is using a closed file descriptor as stdin\n                pass\n            if fd is not None:\n                if isatty(fd):\n                    old_settings = termios.tcgetattr(fd)\n                    tty.setraw(fd)\n\n                    # flush the buffer to make sure no previous key presses\n                    # are read in below\n                    termios.tcflush(self._connection._new_stdin, termios.TCIFLUSH)\n            while True:\n                try:\n                    if fd is not None:\n                        key_pressed = self._connection._new_stdin.read(1)\n                        if key_pressed == '\\x03':\n                            raise KeyboardInterrupt\n\n                    if not seconds:\n                        if fd is None or not isatty(fd):\n                            display.warning(\"Not waiting from prompt as stdin is not interactive\")\n                            break\n                        # read key presses and act accordingly\n                        if key_pressed == '\\r':\n                            break\n                        else:\n                            result['user_input'] += key_pressed\n\n                except KeyboardInterrupt:\n                    if seconds is not None:\n                        signal.alarm(0)\n                    display.display(\"Press 'C' to continue the play or 'A' to abort \\r\"),\n                    if self._c_or_a():\n                        break\n                    else:\n                        raise AnsibleError('user requested abort!')\n\n\n        except AnsibleTimeoutExceeded:\n            # this is the exception we expect when the alarm signal\n            # fires, so we simply ignore it to move into the cleanup\n            pass\n        finally:\n            # cleanup and save some information\n            # restore the old settings for the duped stdin fd\n            if not(None in (fd, old_settings)) and isatty(fd):\n                termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n\n            duration = time.time() - start\n            result['stop'] = str(datetime.datetime.now())\n            result['delta'] = int(duration)\n\n            if duration_unit == 'minutes':\n                duration = round(duration / 60.0, 2)\n            else:\n                duration = round(duration, 2)\n            result['stdout'] = \"Paused for %s %s\" % (duration, duration_unit)\n\n        return result",
    "smell": []
}