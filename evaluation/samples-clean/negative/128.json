{
    "code": "def pivot_annual(series, freq=None):\n    \"\"\"\n    Group a series by years, taking leap years into account.\n\n    The output has as many rows as distinct years in the original series,\n    and as many columns as the length of a leap year in the units corresponding\n    to the original frequency (366 for daily frequency, 366*24 for hourly...).\n    The fist column of the output corresponds to Jan. 1st, 00:00:00,\n    while the last column corresponds to Dec, 31st, 23:59:59.\n    Entries corresponding to Feb. 29th are masked for non-leap years.\n\n    For example, if the initial series has a daily frequency, the 59th column\n    of the output always corresponds to Feb. 28th, the 61st column to Mar. 1st,\n    and the 60th column is masked for non-leap years.\n    With a hourly initial frequency, the (59*24)th column of the output always\n    correspond to Feb. 28th 23:00, the (61*24)th column to Mar. 1st, 00:00, and\n    the 24 columns between (59*24) and (61*24) are masked.\n\n    If the original frequency is less than daily, the output is equivalent to\n    ``series.convert('A', func=None)``.\n\n    Parameters\n    ----------\n    series : Series\n    freq : string or None, default None\n\n    Returns\n    -------\n    annual : DataFrame\n    \"\"\"\n    index = series.index\n    year = index.year\n    years = nanops.unique1d(year)\n\n    if freq is not None:\n        freq = freq.upper()\n    else:\n        freq = series.index.freq\n\n    if freq == 'D':\n        width = 366\n        offset = index.dayofyear - 1\n\n        # adjust for leap year\n        offset[(~isleapyear(year)) & (offset >= 59)] += 1\n\n        columns = lrange(1, 367)\n        # todo: strings like 1/1, 1/25, etc.?\n    elif freq in ('M', 'BM'):\n        width = 12\n        offset = index.month - 1\n        columns = lrange(1, 13)\n    elif freq == 'H':\n        width = 8784\n        grouped = series.groupby(series.index.year)\n        defaulted = grouped.apply(lambda x: x.reset_index(drop=True))\n        defaulted.index = defaulted.index.droplevel(0)\n        offset = np.asarray(defaulted.index)\n        offset[~isleapyear(year) & (offset >= 1416)] += 24\n        columns = lrange(1, 8785)\n    else:\n        raise NotImplementedError(freq)\n\n    flat_index = (year - years.min()) * width + offset\n    flat_index = com._ensure_platform_int(flat_index)\n\n    values = np.empty((len(years), width))\n    values.fill(np.nan)\n    values.put(flat_index, series.values)\n\n    return DataFrame(values, index=years, columns=columns)",
    "smell": []
}