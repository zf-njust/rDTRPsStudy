{
    "code": "def _upgrade(args: Namespace) -> None:\n    path = Path(args.path).absolute()\n    extension: str = args.extension if args.extension.startswith(\".\") else f\".{args.extension}\"\n    files: List[Path] = []\n\n    if not path.exists():\n        _log.error(\n            f\"The path {path} does not exist. Please provide a valid path to a checkpoint file or a directory\"\n            f\" containing checkpoints ending in {extension}.\"\n        )\n        exit(1)\n\n    if path.is_file():\n        files = [path]\n    if path.is_dir():\n        files = [Path(p) for p in glob.glob(str(path / \"**\" / f\"*{extension}\"), recursive=True)]\n    if not files:\n        _log.error(\n            f\"No checkpoint files with extension {extension} were found in {path}.\"\n            f\" HINT: Try setting the `--extension` option to specify the right file extension to look for.\"\n        )\n        exit(1)\n\n    _log.info(\"Creating a backup of the existing checkpoint files before overwriting in the upgrade process.\")\n    for file in files:\n        backup_file = file.with_suffix(\".bak\")\n        if backup_file.exists():\n            # never overwrite backup files - they are the original, untouched checkpoints\n            continue\n        copyfile(file, backup_file)\n\n    _log.info(\"Upgrading checkpoints ...\")\n    for file in tqdm(files):\n        with pl_legacy_patch():\n            checkpoint = torch.load(file, map_location=(torch.device(\"cpu\") if args.map_to_cpu else None))\n        migrate_checkpoint(checkpoint)\n        torch.save(checkpoint, file)\n\n    _log.info(\"Done.\")",
    "smell": []
}