{
    "code": "def _install(self, target: InstallTarget) -> None:\n        \"\"\"\n        The StepFunctionsLocal JAR files are downloaded using the artifacts in DockerHub (because AWS only provides an\n        HTTP link to the most recent version). Installers are executed when building Docker, this means they _cannot_ use\n        the Docker socket. Therefore, this installer downloads a pinned Docker Layer Digest (i.e. only the data for a single\n        Docker build step which adds the JAR files of the desired version to a Docker image) using plain HTTP requests.\n        \"\"\"\n        install_dir = self._get_install_dir(target)\n        install_destination = self._get_install_marker_path(install_dir)\n        if not os.path.exists(install_destination):\n\n            # Download layer that contains the necessary jars\n            def download_stepfunctions_jar(image, image_digest, target_path):\n                registry_base = \"https://registry-1.docker.io\"\n                auth_base = \"https://auth.docker.io\"\n                auth_service = \"registry.docker.io\"\n                token_request = requests.get(\n                    f\"{auth_base}/token?service={auth_service}&scope=repository:{image}:pull\"\n                )\n                token = json.loads(token_request.content.decode(\"utf-8\"))[\"token\"]\n                headers = {\"Authorization\": f\"Bearer {token}\"}\n                response = requests.get(\n                    headers=headers,\n                    url=f\"{registry_base}/v2/{image}/blobs/{image_digest}\",\n                )\n                temp_path = new_tmp_file()\n                with open(temp_path, \"wb\") as f:\n                    f.write(response.content)\n                untar(temp_path, target_path)\n\n            download_stepfunctions_jar(SFN_IMAGE, SFN_IMAGE_LAYER_DIGEST, target.value)\n            mkdir(install_dir)\n            path = Path(f\"{target.value}/home/stepfunctionslocal\")\n            for file in path.glob(\"*.jar\"):\n                file.rename(Path(install_dir) / file.name)\n            rm_rf(f\"{target.value}/home\")\n\n        classes = [\n            SFN_PATCH_CLASS1,\n            SFN_PATCH_CLASS2,\n            SFN_PATCH_CLASS_REGION,\n            SFN_PATCH_CLASS_STARTER,\n            SFN_PATCH_CLASS_ASYNC2SERVICEAPI,\n            SFN_PATCH_CLASS_DESCRIBEEXECUTIONPARSED,\n            SFN_PATCH_FILE_METAINF,\n        ]\n        for patch_class in classes:\n            patch_url = f\"{SFN_PATCH_URL_PREFIX}/{patch_class}\"\n            add_file_to_jar(patch_class, patch_url, target_jar=install_destination)\n\n        # add additional classpath entries to JAR manifest file\n        classpath = \" \".join([os.path.basename(jar) for jar in JAR_URLS])\n        update_jar_manifest(\n            \"StepFunctionsLocal.jar\",\n            install_dir,\n            \"Class-Path: . \",\n            f\"Class-Path: {classpath} . \",\n        )\n        update_jar_manifest(\n            \"StepFunctionsLocal.jar\",\n            install_dir,\n            re.compile(r\"Main-Class: com\\.amazonaws.+\"),\n            \"Main-Class: cloud.localstack.StepFunctionsStarter\",\n        )\n\n        # download additional jar libs\n        for jar_url in JAR_URLS:\n            jar_target = os.path.join(install_dir, os.path.basename(jar_url))\n            if not file_exists_not_empty(jar_target):\n                download(jar_url, jar_target)\n\n        # download aws-sdk lambda handler\n        target = os.path.join(install_dir, \"localstack-internal-awssdk\", \"awssdk.zip\")\n        if not file_exists_not_empty(target):\n            download(SFN_AWS_SDK_LAMBDA_ZIP_FILE, target)",
    "smell": []
}