{
    "code": "def _real_extract(self, url):\n        mobj = re.match(self._VALID_URL, url)\n        show_path = mobj.group('show_path')\n        episode_path = mobj.group('episode_path')\n        is_playlist = True if mobj.group('is_playlist') else False\n\n        webpage = self._download_webpage(url, episode_path)\n\n        # Extract the value of `bootstrappedData` from the Javascript in the page.\n        bootstrapped_data = self._parse_json(self._search_regex(\n            r'var bootstrappedData = ({.*});', webpage, 'bootstraped data'), episode_path)\n\n        # Downloading videos from a /videos/playlist/ URL needs to be handled differently.\n        # NOTE: We are only downloading one video (the current one) not the playlist\n        if is_playlist:\n            collections = bootstrapped_data['playlists']['collections']\n            collection = self.find_collection_by_linkURL(collections, show_path)\n            video_info = self.find_video_info(collection, episode_path)\n\n            show_title = video_info['showTitle']\n            segment_ids = [video_info['videoPlaybackID']]\n        else:\n            collections = bootstrapped_data['show']['collections']\n            collection, video_info = self.find_collection_containing_video(collections, episode_path)\n            # Video wasn't found in the collections, let's try `slugged_video`.\n            if video_info is None:\n                if bootstrapped_data.get('slugged_video', {}).get('slug') == episode_path:\n                    video_info = bootstrapped_data['slugged_video']\n                else:\n                    raise ExtractorError('Unable to find video info')\n\n            show = bootstrapped_data['show']\n            show_title = show['title']\n            stream = video_info.get('stream')\n            clips = [stream] if stream else video_info.get('clips')\n            if not clips:\n                raise ExtractorError(\n                    'This video is only available via cable service provider subscription that'\n                    ' is not currently supported. You may want to use --cookies.'\n                    if video_info.get('auth') is True else 'Unable to find stream or clips',\n                    expected=True)\n            segment_ids = [clip['videoPlaybackID'] for clip in clips]\n\n        episode_id = video_info['id']\n        episode_title = video_info['title']\n        episode_description = video_info['description']\n        episode_duration = video_info.get('duration')\n\n        entries = []\n        for part_num, segment_id in enumerate(segment_ids):\n            segment_url = 'http://www.adultswim.com/videos/api/v0/assets?id=%s&platform=desktop' % segment_id\n\n            segment_title = '%s - %s' % (show_title, episode_title)\n            if len(segment_ids) > 1:\n                segment_title += ' Part %d' % (part_num + 1)\n\n            idoc = self._download_xml(\n                segment_url, segment_title,\n                'Downloading segment information', 'Unable to download segment information')\n\n            segment_duration = float_or_none(\n                xpath_text(idoc, './/trt', 'segment duration').strip())\n\n            formats = []\n            file_els = idoc.findall('.//files/file') or idoc.findall('./files/file')\n\n            unique_urls = []\n            unique_file_els = []\n            for file_el in file_els:\n                media_url = file_el.text\n                if not media_url or determine_ext(media_url) == 'f4m':\n                    continue\n                if file_el.text not in unique_urls:\n                    unique_urls.append(file_el.text)\n                    unique_file_els.append(file_el)\n\n            for file_el in unique_file_els:\n                bitrate = file_el.attrib.get('bitrate')\n                ftype = file_el.attrib.get('type')\n                media_url = file_el.text\n                if determine_ext(media_url) == 'm3u8':\n                    formats.extend(self._extract_m3u8_formats(\n                        media_url, segment_title, 'mp4', 'm3u8_native', preference=0, m3u8_id='hls'))\n                else:\n                    formats.append({\n                        'format_id': '%s_%s' % (bitrate, ftype),\n                        'url': file_el.text.strip(),\n                        # The bitrate may not be a number (for example: 'iphone')\n                        'tbr': int(bitrate) if bitrate.isdigit() else None,\n                    })\n\n            self._sort_formats(formats)\n\n            entries.append({\n                'id': segment_id,\n                'title': segment_title,\n                'formats': formats,\n                'duration': segment_duration,\n                'description': episode_description\n            })\n\n        return {\n            '_type': 'playlist',\n            'id': episode_id,\n            'display_id': episode_path,\n            'entries': entries,\n            'title': '%s - %s' % (show_title, episode_title),\n            'description': episode_description,\n            'duration': episode_duration\n        }",
    "smell": []
}