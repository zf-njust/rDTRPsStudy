{
    "code": "def _time_weighted_average(\n    fstates: list[tuple[float, State]], start: datetime.datetime, end: datetime.datetime\n) -> float:\n    \"\"\"Calculate a time weighted average.\n\n    The average is calculated by weighting the states by duration in seconds between\n    state changes.\n    Note: there's no interpolation of values between state changes.\n    \"\"\"\n    old_fstate: float | None = None\n    old_start_time: datetime.datetime | None = None\n    accumulated = 0.0\n\n    for fstate, state in fstates:\n        # The recorder will give us the last known state, which may be well\n        # before the requested start time for the statistics\n        start_time = start if state.last_updated < start else state.last_updated\n        if old_start_time is None:\n            # Adjust start time, if there was no last known state\n            start = start_time\n        else:\n            duration = start_time - old_start_time\n            # Accumulate the value, weighted by duration until next state change\n            assert old_fstate is not None\n            accumulated += old_fstate * duration.total_seconds()\n\n        old_fstate = fstate\n        old_start_time = start_time\n\n    if old_fstate is not None:\n        # Accumulate the value, weighted by duration until end of the period\n        assert old_start_time is not None\n        duration = end - old_start_time\n        accumulated += old_fstate * duration.total_seconds()\n\n    period_seconds = (end - start).total_seconds()\n    if period_seconds == 0:\n        # If the only state changed that happened was at the exact moment\n        # at the end of the period, we can't calculate a meaningful average\n        # so we return 0.0 since it represents a time duration smaller than\n        # we can measure. This probably means the precision of statistics\n        # column schema in the database is incorrect but it is actually possible\n        # to happen if the state change event fired at the exact microsecond\n        return 0.0\n    return accumulated / period_seconds",
    "smell": []
}