{
    "code": "def inputhook_pyglet():\n    \"\"\"Run the pyglet event loop by processing pending events only.\n\n    This keeps processing pending events until stdin is ready.  After\n    processing all pending events, a call to time.sleep is inserted.  This is\n    needed, otherwise, CPU usage is at 100%.  This sleep time should be tuned\n    though for best performance.\n    \"\"\"\n    # We need to protect against a user pressing Control-C when IPython is\n    # idle and this is running. We trap KeyboardInterrupt and pass.\n    try:\n        t = clock()\n        while not stdin_ready():\n            pyglet.clock.tick()\n            for window in pyglet.app.windows:\n                window.switch_to()\n                window.dispatch_events()\n                window.dispatch_event('on_draw')\n                flip(window)\n\n            # We need to sleep at this point to keep the idle CPU load\n            # low.  However, if sleep to long, GUI response is poor.  As\n            # a compromise, we watch how often GUI events are being processed\n            # and switch between a short and long sleep time.  Here are some\n            # stats useful in helping to tune this.\n            # time    CPU load\n            # 0.001   13%\n            # 0.005   3%\n            # 0.01    1.5%\n            # 0.05    0.5%\n            used_time = clock() - t\n            if used_time > 10.0:\n                # print 'Sleep for 1 s'  # dbg\n                time.sleep(1.0)\n            elif used_time > 0.1:\n                # Few GUI events coming in, so we can sleep longer\n                # print 'Sleep for 0.05 s'  # dbg\n                time.sleep(0.05)\n            else:\n                # Many GUI events coming in, so sleep only very little\n                time.sleep(0.001)\n    except KeyboardInterrupt:\n        pass\n    return 0",
    "smell": []
}