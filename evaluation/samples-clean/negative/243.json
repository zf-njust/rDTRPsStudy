{
    "code": "def clone(estimator, safe=True):\n    \"\"\"Constructs a new estimator with the same parameters.\n\n    Clone does a deep copy of the model in an estimator\n    without actually copying attached data. It yields a new estimator\n    with the same parameters that has not been fit on any data.\n\n    Parameters\n    ----------\n    estimator: estimator object, or list, tuple or set of objects\n        The estimator or group of estimators to be cloned\n\n    safe: boolean, optional\n        If safe is false, clone will fall back to a deepcopy on objects\n        that are not estimators.\n\n    \"\"\"\n    estimator_type = type(estimator)\n    # XXX: not handling dictionaries\n    if estimator_type in (list, tuple, set, frozenset):\n        return estimator_type([clone(e, safe=safe) for e in estimator])\n    elif not hasattr(estimator, 'get_params'):\n        if not safe:\n            return copy.deepcopy(estimator)\n        else:\n            raise TypeError(\"Cannot clone object '%s' (type %s): \"\n                            \"it does not seem to be a scikit-learn estimator \"\n                            \"as it does not implement a 'get_params' methods.\"\n                            % (repr(estimator), type(estimator)))\n    klass = estimator.__class__\n    new_object_params = estimator.get_params(deep=False)\n    for name, param in six.iteritems(new_object_params):\n        new_object_params[name] = clone(param, safe=False)\n    new_object = klass(**new_object_params)\n    params_set = new_object.get_params(deep=False)\n\n    # quick sanity check of the parameters of the clone\n    for name in new_object_params:\n        param1 = new_object_params[name]\n        param2 = params_set[name]\n        if isinstance(param1, np.ndarray):\n            # For most ndarrays, we do not test for complete equality\n            if not isinstance(param2, type(param1)):\n                equality_test = False\n            elif (param1.ndim > 0\n                    and param1.shape[0] > 0\n                    and isinstance(param2, np.ndarray)\n                    and param2.ndim > 0\n                    and param2.shape[0] > 0):\n                equality_test = (\n                    param1.shape == param2.shape\n                    and param1.dtype == param2.dtype\n                    # We have to use '.flat' for 2D arrays\n                    and param1.flat[0] == param2.flat[0]\n                    and param1.flat[-1] == param2.flat[-1]\n                )\n            else:\n                equality_test = np.all(param1 == param2)\n        elif sparse.issparse(param1):\n            # For sparse matrices equality doesn't work\n            if not sparse.issparse(param2):\n                equality_test = False\n            elif param1.size == 0 or param2.size == 0:\n                equality_test = (\n                    param1.__class__ == param2.__class__\n                    and param1.size == 0\n                    and param2.size == 0\n                )\n            else:\n                equality_test = (\n                    param1.__class__ == param2.__class__\n                    and param1.data[0] == param2.data[0]\n                    and param1.data[-1] == param2.data[-1]\n                    and param1.nnz == param2.nnz\n                    and param1.shape == param2.shape\n                )\n        else:\n            new_obj_val = new_object_params[name]\n            params_set_val = params_set[name]\n            # The following construct is required to check equality on special\n            # singletons such as np.nan that are not equal to them-selves:\n            equality_test = (new_obj_val == params_set_val or\n                             new_obj_val is params_set_val)\n        if not equality_test:\n            raise RuntimeError('Cannot clone object %s, as the constructor '\n                               'does not seem to set parameter %s' %\n                               (estimator, name))\n\n    return new_object",
    "smell": []
}