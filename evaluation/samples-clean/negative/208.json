{
    "code": "def run(self, tmp=None, task_vars=None):\n        ''' handler for file transfer operations '''\n        if task_vars is None:\n            task_vars = dict()\n\n        result = super(ActionModule, self).run(tmp, task_vars)\n\n        if self._play_context.check_mode:\n            result['skipped'] = True\n            result['msg'] = 'check mode not supported for this module'\n            return result\n\n        remote_user = task_vars.get('ansible_ssh_user') or self._play_context.remote_user\n        if not tmp:\n            tmp = self._make_tmp_path(remote_user)\n            self._cleanup_remote_tmp = True\n\n        creates = self._task.args.get('creates')\n        if creates:\n            # do not run the command if the line contains creates=filename\n            # and the filename already exists. This allows idempotence\n            # of command executions.\n            if self._remote_file_exists(creates):\n                self._remove_tmp_path(tmp)\n                return dict(skipped=True, msg=(\"skipped, since %s exists\" % creates))\n\n        removes = self._task.args.get('removes')\n        if removes:\n            # do not run the command if the line contains removes=filename\n            # and the filename does not exist. This allows idempotence\n            # of command executions.\n            if not self._remote_file_exists(removes):\n                self._remove_tmp_path(tmp)\n                return dict(skipped=True, msg=(\"skipped, since %s does not exist\" % removes))\n\n        # the script name is the first item in the raw params, so we split it\n        # out now so we know the file name we need to transfer to the remote,\n        # and everything else is an argument to the script which we need later\n        # to append to the remote command\n        parts  = self._task.args.get('_raw_params', '').strip().split()\n        source = parts[0]\n        args   = ' '.join(parts[1:])\n\n        try:\n            source = self._loader.get_real_file(self._find_needle('files', source))\n        except AnsibleError as e:\n            return dict(failed=True, msg=to_native(e))\n\n        # transfer the file to a remote tmp location\n        tmp_src = self._connection._shell.join_path(tmp, os.path.basename(source))\n        self._transfer_file(source, tmp_src)\n\n        # set file permissions, more permissive when the copy is done as a different user\n        self._fixup_perms2((tmp, tmp_src), remote_user, execute=True)\n\n        # add preparation steps to one ssh roundtrip executing the script\n        env_string = self._compute_environment_string()\n        script_cmd = ' '.join([env_string, tmp_src, args])\n\n        result.update(self._low_level_execute_command(cmd=script_cmd, sudoable=True))\n\n        # clean up after\n        self._remove_tmp_path(tmp)\n\n        result['changed'] = True\n\n        return result",
    "smell": []
}