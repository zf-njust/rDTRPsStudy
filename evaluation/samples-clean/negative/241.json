{
    "code": "def __init__(\n        self,\n        prf: typing.Callable,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: typing.Optional[int],\n        location: CounterLocation,\n        break_location: typing.Optional[int],\n        label: typing.Optional[bytes],\n        context: typing.Optional[bytes],\n        fixed: typing.Optional[bytes],\n    ):\n        assert callable(prf)\n\n        if not isinstance(mode, Mode):\n            raise TypeError(\"mode must be of type Mode\")\n\n        if not isinstance(location, CounterLocation):\n            raise TypeError(\"location must be of type CounterLocation\")\n\n        if break_location is None and location is CounterLocation.MiddleFixed:\n            raise ValueError(\"Please specify a break_location\")\n\n        if (\n            break_location is not None\n            and location != CounterLocation.MiddleFixed\n        ):\n            raise ValueError(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            )\n\n        if break_location is not None and not isinstance(break_location, int):\n            raise TypeError(\"break_location must be an integer\")\n\n        if break_location is not None and break_location < 0:\n            raise ValueError(\"break_location must be a positive integer\")\n\n        if (label or context) and fixed:\n            raise ValueError(\n                \"When supplying fixed data, \" \"label and context are ignored.\"\n            )\n\n        if rlen is None or not self._valid_byte_length(rlen):\n            raise ValueError(\"rlen must be between 1 and 4\")\n\n        if llen is None and fixed is None:\n            raise ValueError(\"Please specify an llen\")\n\n        if llen is not None and not isinstance(llen, int):\n            raise TypeError(\"llen must be an integer\")\n\n        if label is None:\n            label = b\"\"\n\n        if context is None:\n            context = b\"\"\n\n        utils._check_bytes(\"label\", label)\n        utils._check_bytes(\"context\", context)\n        self._prf = prf\n        self._mode = mode\n        self._length = length\n        self._rlen = rlen\n        self._llen = llen\n        self._location = location\n        self._break_location = break_location\n        self._label = label\n        self._context = context\n        self._used = False\n        self._fixed_data = fixed",
    "smell": []
}