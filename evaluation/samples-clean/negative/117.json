{
    "code": "def update(self):\n        \"\"\"Update disk I/O stats using the input method.\"\"\"\n        # Reset stats\n        self.reset()\n\n        if self.input_method == 'local':\n            # Update stats using the standard system lib\n            # Grab the stat using the PsUtil disk_io_counters method\n            # read_count: number of reads\n            # write_count: number of writes\n            # read_bytes: number of bytes read\n            # write_bytes: number of bytes written\n            # read_time: time spent reading from disk (in milliseconds)\n            # write_time: time spent writing to disk (in milliseconds)\n            try:\n                diskiocounters = psutil.disk_io_counters(perdisk=True)\n            except Exception:\n                return self.stats\n\n            # Previous disk IO stats are stored in the diskio_old variable\n            if not hasattr(self, 'diskio_old'):\n                # First call, we init the network_old var\n                try:\n                    self.diskio_old = diskiocounters\n                except (IOError, UnboundLocalError):\n                    pass\n            else:\n                # By storing time data we enable Rx/s and Tx/s calculations in the\n                # XML/RPC API, which would otherwise be overly difficult work\n                # for users of the API\n                time_since_update = getTimeSinceLastUpdate('disk')\n\n                diskio_new = diskiocounters\n                for disk in diskio_new:\n                    try:\n                        read_bytes = (diskio_new[disk].read_bytes -\n                                      self.diskio_old[disk].read_bytes)\n                        write_bytes = (diskio_new[disk].write_bytes -\n                                       self.diskio_old[disk].write_bytes)\n                        diskstat = {\n                            'time_since_update': time_since_update,\n                            'disk_name': disk,\n                            'read_bytes': read_bytes,\n                            'write_bytes': write_bytes}\n                    except KeyError:\n                        continue\n                    else:\n                        diskstat['key'] = self.get_key()\n                        self.stats.append(diskstat)\n\n                # Save stats to compute next bitrate\n                self.diskio_old = diskio_new\n        elif self.input_method == 'snmp':\n            # Update stats using SNMP\n            # No standard way for the moment...\n            pass\n\n        # Update the history list\n        self.update_stats_history('disk_name')\n\n        # Update the view\n        self.update_views()\n\n        return self.stats",
    "smell": []
}