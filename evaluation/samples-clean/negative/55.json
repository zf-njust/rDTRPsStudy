{
    "code": "def population_count(x):\n  assert np.issubdtype(x.dtype, np.integer)\n  dtype = x.dtype\n  iinfo = np.iinfo(x.dtype)\n  if np.iinfo(x.dtype).bits < 32:\n    assert iinfo.kind in ('i', 'u')\n    x = x.astype(np.uint32 if iinfo.kind == 'u' else np.int32)\n  if iinfo.kind == 'i':\n    x = x.view(f\"uint{np.iinfo(x.dtype).bits}\")\n  assert x.dtype in (np.uint32, np.uint64)\n  m = [\n      np.uint64(0x5555555555555555),  # binary: 0101...\n      np.uint64(0x3333333333333333),  # binary: 00110011..\n      np.uint64(0x0f0f0f0f0f0f0f0f),  # binary:  4 zeros,  4 ones ...\n      np.uint64(0x00ff00ff00ff00ff),  # binary:  8 zeros,  8 ones ...\n      np.uint64(0x0000ffff0000ffff),  # binary: 16 zeros, 16 ones ...\n      np.uint64(0x00000000ffffffff),  # binary: 32 zeros, 32 ones\n  ]\n\n  if x.dtype == np.uint32:\n    m = list(map(np.uint32, m[:-1]))\n\n  x = (x & m[0]) + ((x >>  1) & m[0])  # put count of each  2 bits into those  2 bits\n  x = (x & m[1]) + ((x >>  2) & m[1])  # put count of each  4 bits into those  4 bits\n  x = (x & m[2]) + ((x >>  4) & m[2])  # put count of each  8 bits into those  8 bits\n  x = (x & m[3]) + ((x >>  8) & m[3])  # put count of each 16 bits into those 16 bits\n  x = (x & m[4]) + ((x >> 16) & m[4])  # put count of each 32 bits into those 32 bits\n  if x.dtype == np.uint64:\n    x = (x & m[5]) + ((x >> 32) & m[5])  # put count of each 64 bits into those 64 bits\n  return x.astype(dtype)",
    "smell": []
}