{
    "code": "def generator(test_case):\n\n    def test_template(self):\n        ie = youtube_dl.extractor.get_info_extractor(test_case['name'])\n        other_ies = [get_info_extractor(ie_key) for ie_key in test_case.get('add_ie', [])]\n        is_playlist = any(k.startswith('playlist') for k in test_case)\n        test_cases = test_case.get(\n            'playlist', [] if is_playlist else [test_case])\n\n        def print_skipping(reason):\n            print('Skipping %s: %s' % (test_case['name'], reason))\n        if not ie.working():\n            print_skipping('IE marked as not _WORKING')\n            return\n\n        for tc in test_cases:\n            info_dict = tc.get('info_dict', {})\n            if not (info_dict.get('id') and info_dict.get('ext')):\n                raise Exception('Test definition incorrect. The output file cannot be known. Are both \\'id\\' and \\'ext\\' keys present?')\n\n        if 'skip' in test_case:\n            print_skipping(test_case['skip'])\n            return\n        for other_ie in other_ies:\n            if not other_ie.working():\n                print_skipping('test depends on %sIE, marked as not WORKING' % other_ie.ie_key())\n                return\n\n        params = get_params(test_case.get('params', {}))\n        if is_playlist and 'playlist' not in test_case:\n            params.setdefault('extract_flat', True)\n            params.setdefault('skip_download', True)\n\n        ydl = YoutubeDL(params, auto_init=False)\n        ydl.add_default_info_extractors()\n        finished_hook_called = set()\n\n        def _hook(status):\n            if status['status'] == 'finished':\n                finished_hook_called.add(status['filename'])\n        ydl.add_progress_hook(_hook)\n        expect_warnings(ydl, test_case.get('expected_warnings', []))\n\n        def get_tc_filename(tc):\n            return ydl.prepare_filename(tc.get('info_dict', {}))\n\n        res_dict = None\n\n        def try_rm_tcs_files(tcs=None):\n            if tcs is None:\n                tcs = test_cases\n            for tc in tcs:\n                tc_filename = get_tc_filename(tc)\n                try_rm(tc_filename)\n                try_rm(tc_filename + '.part')\n                try_rm(os.path.splitext(tc_filename)[0] + '.info.json')\n        try_rm_tcs_files()\n        try:\n            try_num = 1\n            while True:\n                try:\n                    # We're not using .download here sine that is just a shim\n                    # for outside error handling, and returns the exit code\n                    # instead of the result dict.\n                    res_dict = ydl.extract_info(\n                        test_case['url'],\n                        force_generic_extractor=params.get('force_generic_extractor', False))\n                except (DownloadError, ExtractorError) as err:\n                    # Check if the exception is not a network related one\n                    if not err.exc_info[0] in (compat_urllib_error.URLError, socket.timeout, UnavailableVideoError, compat_http_client.BadStatusLine) or (err.exc_info[0] == compat_HTTPError and err.exc_info[1].code == 503):\n                        raise\n\n                    if try_num == RETRIES:\n                        report_warning('Failed due to network errors, skipping...')\n                        return\n\n                    print('Retrying: {0} failed tries\\n\\n##########\\n\\n'.format(try_num))\n\n                    try_num += 1\n                else:\n                    break\n\n            if is_playlist:\n                self.assertTrue(res_dict['_type'] in ['playlist', 'multi_video'])\n                self.assertTrue('entries' in res_dict)\n                expect_info_dict(self, res_dict, test_case.get('info_dict', {}))\n\n            if 'playlist_mincount' in test_case:\n                assertGreaterEqual(\n                    self,\n                    len(res_dict['entries']),\n                    test_case['playlist_mincount'],\n                    'Expected at least %d in playlist %s, but got only %d' % (\n                        test_case['playlist_mincount'], test_case['url'],\n                        len(res_dict['entries'])))\n            if 'playlist_count' in test_case:\n                self.assertEqual(\n                    len(res_dict['entries']),\n                    test_case['playlist_count'],\n                    'Expected %d entries in playlist %s, but got %d.' % (\n                        test_case['playlist_count'],\n                        test_case['url'],\n                        len(res_dict['entries']),\n                    ))\n            if 'playlist_duration_sum' in test_case:\n                got_duration = sum(e['duration'] for e in res_dict['entries'])\n                self.assertEqual(\n                    test_case['playlist_duration_sum'], got_duration)\n\n            for tc in test_cases:\n                tc_filename = get_tc_filename(tc)\n                if not test_case.get('params', {}).get('skip_download', False):\n                    self.assertTrue(os.path.exists(tc_filename), msg='Missing file ' + tc_filename)\n                    self.assertTrue(tc_filename in finished_hook_called)\n                    expected_minsize = tc.get('file_minsize', 10000)\n                    if expected_minsize is not None:\n                        if params.get('test'):\n                            expected_minsize = max(expected_minsize, 10000)\n                        got_fsize = os.path.getsize(tc_filename)\n                        assertGreaterEqual(\n                            self, got_fsize, expected_minsize,\n                            'Expected %s to be at least %s, but it\\'s only %s ' %\n                            (tc_filename, format_bytes(expected_minsize),\n                                format_bytes(got_fsize)))\n                    if 'md5' in tc:\n                        md5_for_file = _file_md5(tc_filename)\n                        self.assertEqual(md5_for_file, tc['md5'])\n                info_json_fn = os.path.splitext(tc_filename)[0] + '.info.json'\n                self.assertTrue(\n                    os.path.exists(info_json_fn),\n                    'Missing info file %s' % info_json_fn)\n                with io.open(info_json_fn, encoding='utf-8') as infof:\n                    info_dict = json.load(infof)\n\n                expect_info_dict(self, info_dict, tc.get('info_dict', {}))\n        finally:\n            try_rm_tcs_files()\n            if is_playlist and res_dict is not None and res_dict.get('entries'):\n                # Remove all other files that may have been extracted if the\n                # extractor returns full results even with extract_flat\n                res_tcs = [{'info_dict': e} for e in res_dict['entries']]\n                try_rm_tcs_files(res_tcs)\n\n    return test_template",
    "smell": []
}