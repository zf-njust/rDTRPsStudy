{
    "code": "def get(self, request, project):\n        \"\"\"\n        List a Project's Aggregates\n        ```````````````````````````\n\n        Return a list of aggregates bound to a project.  All parameters are\n        supplied as query string parameters.\n\n        A default query of ``is:resolved`` is applied. To return results\n        with other statuses send an new query value (i.e. ``?query=`` for all\n        results).\n\n        The ``statsPeriod`` parameter can be used to select the timeline\n        stats which should be present. Possible values are: '' (disable),\n        '24h', '14d'\n\n        :qparam string statsPeriod: an optional stat period (can be one of\n                                    ``\"24h\"``, ``\"14d\"``, and ``\"\"``).\n        :qparam querystring query: an optional Sentry structured search\n                                   query.  If not provided an implied\n                                   ``\"is:resolved\"`` is assumed.)\n        :pparam string organization_slug: the slug of the organization the\n                                          groups belong to.\n        :pparam string project_slug: the slug of the project the groups\n                                     belong to.\n        :auth: required\n        \"\"\"\n        query_kwargs = {\n            'project': project,\n        }\n\n        stats_period = request.GET.get('statsPeriod')\n        if stats_period not in (None, '', '24h', '14d'):\n            return Response({\"detail\": ERR_INVALID_STATS_PERIOD}, status=400)\n        elif stats_period is None:\n            # default\n            stats_period = '24h'\n        elif stats_period == '':\n            # disable stats\n            stats_period = None\n\n        if request.GET.get('status'):\n            try:\n                query_kwargs['status'] = STATUS_CHOICES[request.GET['status']]\n            except KeyError:\n                return Response('{\"detail\": \"invalid status\"}', status=400)\n\n        if request.user.is_authenticated() and request.GET.get('bookmarks'):\n            query_kwargs['bookmarked_by'] = request.user\n\n        if request.user.is_authenticated() and request.GET.get('assigned'):\n            query_kwargs['assigned_to'] = request.user\n\n        sort_by = request.GET.get('sort')\n        if sort_by is None:\n            sort_by = DEFAULT_SORT_OPTION\n\n        query_kwargs['sort_by'] = sort_by\n\n        tags = {}\n        for tag_key in TagKey.objects.all_keys(project):\n            if request.GET.get(tag_key):\n                tags[tag_key] = request.GET[tag_key]\n        if tags:\n            query_kwargs['tags'] = tags\n\n        # TODO: dates should include timestamps\n        date_from = request.GET.get('since')\n        date_to = request.GET.get('until')\n        date_filter = request.GET.get('date_filter')\n\n        limit = request.GET.get('limit')\n        if limit:\n            try:\n                query_kwargs['limit'] = int(limit)\n            except ValueError:\n                return Response('{\"detail\": \"invalid limit\"}', status=400)\n\n        if date_from:\n            date_from = self._parse_date(date_from)\n\n        if date_to:\n            date_to = self._parse_date(date_to)\n\n        query_kwargs['date_from'] = date_from\n        query_kwargs['date_to'] = date_to\n        if date_filter:\n            query_kwargs['date_filter'] = date_filter\n\n        # TODO: proper pagination support\n        cursor = request.GET.get('cursor')\n        if cursor:\n            query_kwargs['cursor'] = Cursor.from_string(cursor)\n\n        query = request.GET.get('query', 'is:unresolved').strip()\n        if len(query) == 32:\n            # check to see if we've got an event ID\n            try:\n                matching_event = EventMapping.objects.filter(\n                    project=project,\n                    event_id=query,\n                ).select_related('group')[0]\n            except IndexError:\n                pass\n            else:\n                return Response(serialize(\n                    [matching_event.group], request.user, StreamGroupSerializer(\n                        stats_period=stats_period\n                    )\n                ))\n\n        if query is not None:\n            query_kwargs.update(parse_query(project, query, request.user))\n\n        cursor_result = search.query(**query_kwargs)\n\n        results = list(cursor_result)\n\n        context = serialize(\n            results, request.user, StreamGroupSerializer(\n                stats_period=stats_period\n            )\n        )\n\n        # HACK: remove auto resolved entries\n        if query_kwargs.get('status') == STATUS_UNRESOLVED:\n            context = [\n                r for r in context\n                if r['status'] == 'unresolved'\n            ]\n\n        response = Response(context)\n        response['Link'] = ', '.join([\n            self.build_cursor_link(request, 'previous', cursor_result.prev),\n            self.build_cursor_link(request, 'next', cursor_result.next),\n        ])\n\n        return response",
    "smell": []
}