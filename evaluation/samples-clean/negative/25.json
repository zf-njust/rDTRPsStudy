{
    "code": "def _build_model(self, inputs):\n    \"\"\"Builds model architecture.\n\n    Args:\n      inputs: the keras input spec.\n\n    Returns:\n      endpoints: A dictionary of backbone endpoint features.\n    \"\"\"\n    # Build stem.\n    x = self._build_stem(inputs, stem_type=self._stem_type)\n\n    temporal_kernel_size = 1 if self._stem_pool_temporal_stride == 1 else 3\n    x = layers.MaxPool3D(\n        pool_size=[temporal_kernel_size, 3, 3],\n        strides=[self._stem_pool_temporal_stride, 2, 2],\n        padding='same')(x)\n\n    # Build intermediate blocks and endpoints.\n    resnet_specs = RESNET_SPECS[self._model_id]\n    if len(self._temporal_strides) != len(resnet_specs) or len(\n        self._temporal_kernel_sizes) != len(resnet_specs):\n      raise ValueError(\n          'Number of blocks in temporal specs should equal to resnet_specs.')\n\n    endpoints = {}\n    for i, resnet_spec in enumerate(resnet_specs):\n      if resnet_spec[0] == 'bottleneck3d':\n        block_fn = nn_blocks_3d.BottleneckBlock3D\n      else:\n        raise ValueError('Block fn `{}` is not supported.'.format(\n            resnet_spec[0]))\n\n      use_self_gating = (\n          self._use_self_gating[i] if self._use_self_gating else False)\n      x = self._block_group(\n          inputs=x,\n          filters=resnet_spec[1],\n          temporal_kernel_sizes=self._temporal_kernel_sizes[i],\n          temporal_strides=self._temporal_strides[i],\n          spatial_strides=(1 if i == 0 else 2),\n          block_fn=block_fn,\n          block_repeats=resnet_spec[2],\n          stochastic_depth_drop_rate=nn_layers.get_stochastic_depth_rate(\n              self._init_stochastic_depth_rate, i + 2, 5),\n          use_self_gating=use_self_gating,\n          name='block_group_l{}'.format(i + 2))\n      endpoints[str(i + 2)] = x\n\n    return endpoints",
    "smell": []
}