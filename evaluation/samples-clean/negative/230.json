{
    "code": "def __init__(self, on_kill=None, *args, **kw):\n        code.InteractiveConsole.__init__(self, *args, **kw)\n        self.code_to_run = None\n        self.ready = threading.Condition()\n        self._kill = False\n        if on_kill is None:\n            on_kill = []\n        # Check that all things to kill are callable:\n        for _ in on_kill:\n            if not callable(_):\n                raise TypeError('on_kill must be a list of callables')\n        self.on_kill = on_kill\n        # Set up tab-completer\n        if has_readline:\n            import rlcompleter\n            try:  # this form only works with python 2.3\n                self.completer = rlcompleter.Completer(self.locals)\n            except:  # simpler for py2.2\n                self.completer = rlcompleter.Completer()\n\n            readline.set_completer(self.completer.complete)\n            # Use tab for completions\n            readline.parse_and_bind('tab: complete')\n            # This forces readline to automatically print the above list when tab\n            # completion is set to 'complete'.\n            readline.parse_and_bind('set show-all-if-ambiguous on')\n            # Bindings for incremental searches in the history. These searches\n            # use the string typed so far on the command line and search\n            # anything in the previous input history containing them.\n            readline.parse_and_bind('\"\\C-r\": reverse-search-history')\n            readline.parse_and_bind('\"\\C-s\": forward-search-history')",
    "smell": []
}