{
    "code": "def make_routes(worker: Worker) -> APIRouter:\n    if TRACE_MODE:\n        # third party\n        from opentelemetry import trace\n        from opentelemetry.propagate import extract\n\n    router = APIRouter()\n\n    async def get_body(request: Request) -> bytes:\n        return await request.body()\n\n    @router.get(\n        \"/\",\n        name=\"healthcheck\",\n        status_code=200,\n        response_class=JSONResponse,\n    )\n    def root() -> Dict[str, str]:\n        \"\"\"\n        Currently, all service backends must satisfy either of the following requirements to\n        pass the HTTP health checks sent to it from the GCE loadbalancer: 1. Respond with a\n        200 on '/'. The content does not matter. 2. Expose an arbitrary url as a readiness\n        probe on the pods backing the Service.\n        \"\"\"\n        return {\"status\": \"ok\"}\n\n    # provide information about the node in JSON\n    @router.get(\"/metadata\", response_class=JSONResponse)\n    def syft_metadata() -> JSONResponse:\n        return worker.metadata.to(NodeMetadataJSON)\n\n    @router.get(\"/metadata_capnp\")\n    def syft_metadata_capnp() -> Response:\n        result = worker.metadata\n        return Response(\n            serialize(result, to_bytes=True),\n            media_type=\"application/octet-stream\",\n        )\n\n    def handle_syft_new_api(user_verify_key: SyftVerifyKey) -> Response:\n        return Response(\n            serialize(worker.get_api(user_verify_key), to_bytes=True),\n            media_type=\"application/octet-stream\",\n        )\n\n    # get the SyftAPI object\n    @router.get(\"/api\")\n    def syft_new_api(request: Request, verify_key: str) -> Response:\n        user_verify_key: SyftVerifyKey = SyftVerifyKey.from_string(verify_key)\n        if TRACE_MODE:\n            with trace.get_tracer(syft_new_api.__module__).start_as_current_span(\n                syft_new_api.__qualname__,\n                context=extract(request.headers),\n                kind=trace.SpanKind.SERVER,\n            ):\n                return handle_syft_new_api(user_verify_key)\n        else:\n            return handle_syft_new_api(user_verify_key)\n\n    def handle_new_api_call(data: bytes) -> Response:\n        obj_msg = deserialize(blob=data, from_bytes=True)\n        result = worker.handle_api_call(api_call=obj_msg)\n        return Response(\n            serialize(result, to_bytes=True),\n            media_type=\"application/octet-stream\",\n        )\n\n    # make a request to the SyftAPI\n    @router.post(\"/api_call\")\n    def syft_new_api_call(\n        request: Request, data: Annotated[bytes, Depends(get_body)]\n    ) -> Response:\n        if TRACE_MODE:\n            with trace.get_tracer(syft_new_api_call.__module__).start_as_current_span(\n                syft_new_api_call.__qualname__,\n                context=extract(request.headers),\n                kind=trace.SpanKind.SERVER,\n            ):\n                return handle_new_api_call(data)\n        else:\n            return handle_new_api_call(data)\n\n    def handle_login(email: str, password: str, node: AbstractNode) -> Response:\n        try:\n            login_credentials = UserLoginCredentials(email=email, password=password)\n        except ValidationError as e:\n            return {\"Error\": e.json()}\n\n        method = node.get_service_method(UserService.exchange_credentials)\n        context = UnauthedServiceContext(node=node, login_credentials=login_credentials)\n        result = method(context=context)\n\n        if isinstance(result, SyftError):\n            logger.bind(payload={\"email\": email}).error(result.message)\n            response = {\"Error\": result.message}\n        else:\n            user_private_key = result\n            if not isinstance(user_private_key, UserPrivateKey):\n                raise Exception(f\"Incorrect return type: {type(user_private_key)}\")\n            response = user_private_key\n\n        return Response(\n            serialize(response, to_bytes=True),\n            media_type=\"application/octet-stream\",\n        )\n\n    def handle_register(data: bytes, node: AbstractNode) -> Response:\n        user_create = deserialize(data, from_bytes=True)\n\n        if not isinstance(user_create, UserCreate):\n            raise Exception(f\"Incorrect type received: {user_create}\")\n\n        context = NodeServiceContext(node=node)\n        method = node.get_method_with_context(UserService.register, context)\n\n        result = method(new_user=user_create)\n\n        if isinstance(result, SyftError):\n            logger.bind(payload={\"user\": user_create}).error(result.message)\n            response = SyftError(message=f\"{result.message}\")\n        else:\n            response = result\n\n        return Response(\n            serialize(response, to_bytes=True),\n            media_type=\"application/octet-stream\",\n        )\n\n    # exchange email and password for a SyftSigningKey\n    @router.post(\"/login\", name=\"login\", status_code=200)\n    def login(\n        request: Request,\n        email: Annotated[str, Body(example=\"info@openmined.org\")],\n        password: Annotated[str, Body(example=\"changethis\")],\n    ) -> Response:\n        if TRACE_MODE:\n            with trace.get_tracer(login.__module__).start_as_current_span(\n                login.__qualname__,\n                context=extract(request.headers),\n                kind=trace.SpanKind.SERVER,\n            ):\n                return handle_login(email, password, worker)\n        else:\n            return handle_login(email, password, worker)\n\n    @router.post(\"/register\", name=\"register\", status_code=200)\n    def register(\n        request: Request, data: Annotated[bytes, Depends(get_body)]\n    ) -> Response:\n        if TRACE_MODE:\n            with trace.get_tracer(register.__module__).start_as_current_span(\n                register.__qualname__,\n                context=extract(request.headers),\n                kind=trace.SpanKind.SERVER,\n            ):\n                return handle_register(data, worker)\n        else:\n            return handle_register(data, worker)\n\n    return router",
    "smell": []
}