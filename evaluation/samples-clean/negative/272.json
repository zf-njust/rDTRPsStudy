{
    "code": "def update_legacy_png_header(filename: str, alignments: Alignments\n                             ) -> PNGHeaderDict | None:\n    \"\"\" Update a legacy extracted face from pre v2.1 alignments by placing the alignment data for\n    the face in the png exif header for the given filename with the given alignment data.\n\n    If the given file is not a .png then a png is created and the original file is removed\n\n    Parameters\n    ----------\n    filename: str\n        The image file to update\n    alignments: :class:`lib.align.alignments.Alignments`\n        The alignments data the contains the information to store in the image header. This must be\n        a v2.0 or less alignments file as later versions no longer store the face hash (not\n        required)\n\n    Returns\n    -------\n    dict\n        The metadata that has been applied to the given image\n    \"\"\"\n    if alignments.version > 2.0:\n        raise FaceswapError(\"The faces being passed in do not correspond to the given Alignments \"\n                            \"file. Please double check your sources and try again.\")\n    # Track hashes for multiple files with the same hash. Not the most robust but should be\n    # effective enough\n    folder = os.path.dirname(filename)\n    if folder not in _HASHES_SEEN:\n        _HASHES_SEEN[folder] = {}\n    hashes_seen = _HASHES_SEEN[folder]\n\n    in_image = read_image(filename, raise_error=True)\n    in_hash = sha1(in_image).hexdigest()\n    hashes_seen[in_hash] = hashes_seen.get(in_hash, -1) + 1\n\n    alignment = alignments.hashes_to_alignment.get(in_hash)\n    if not alignment:\n        logger.debug(\"Alignments not found for image: '%s'\", filename)\n        return None\n\n    detected_face = DetectedFace()\n    detected_face.from_alignment(alignment)\n    # For dupe hash handling, make sure we get a different filename for repeat hashes\n    src_fname, face_idx = list(alignments.hashes_to_frame[in_hash].items())[hashes_seen[in_hash]]\n    orig_filename = f\"{os.path.splitext(src_fname)[0]}_{face_idx}.png\"\n    meta = PNGHeaderDict(alignments=detected_face.to_png_meta(),\n                         source=PNGHeaderSourceDict(\n                            alignments_version=alignments.version,\n                            original_filename=orig_filename,\n                            face_index=face_idx,\n                            source_filename=src_fname,\n                            source_is_video=False,  # Can't check so set false\n                            source_frame_dims=None))\n\n    out_filename = f\"{os.path.splitext(filename)[0]}.png\"  # Make sure saved file is png\n    out_image = encode_image(in_image, \".png\", metadata=meta)\n\n    with open(out_filename, \"wb\") as out_file:\n        out_file.write(out_image)\n\n    if filename != out_filename:  # Remove the old non-png:\n        logger.debug(\"Removing replaced face with deprecated extension: '%s'\", filename)\n        os.remove(filename)\n\n    return meta",
    "smell": []
}