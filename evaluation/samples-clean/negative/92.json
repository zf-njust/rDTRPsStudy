{
    "code": "def binary_operator(op):\n    \"\"\"\n    Factory function for making binary operator methods on a Factor subclass.\n\n    Returns a function, \"binary_operator\" suitable for implementing functions\n    like __add__.\n    \"\"\"\n    # When combining a Factor with a NumericalExpression, we use this\n    # attrgetter instance to defer to the commuted implementation of the\n    # NumericalExpression operator.\n    commuted_method_getter = attrgetter(method_name_for_op(op, commute=True))\n\n    def binary_operator(self, other):\n        # This can't be hoisted up a scope because the types returned by\n        # binop_return_type aren't defined when the top-level function is\n        # invoked in the class body of Factor.\n        return_type = binop_return_type(op)\n        if isinstance(self, NumExprFactor):\n            self_expr, other_expr, new_inputs = self.build_binary_op(\n                op, other,\n            )\n            return return_type(\n                \"({left}) {op} ({right})\".format(\n                    left=self_expr,\n                    op=op,\n                    right=other_expr,\n                ),\n                new_inputs,\n            )\n        elif isinstance(other, NumExprFactor):\n            # NumericalExpression overrides ops to correctly handle merging of\n            # inputs.  Look up and call the appropriate reflected operator with\n            # ourself as the input.\n            return commuted_method_getter(other)(self)\n        elif isinstance(other, Factor):\n            if self is other:\n                return return_type(\n                    \"x_0 {op} x_0\".format(op=op),\n                    (self,),\n                )\n            return return_type(\n                \"x_0 {op} x_1\".format(op=op),\n                (self, other),\n            )\n        elif isinstance(other, Number):\n            return return_type(\n                \"x_0 {op} ({constant})\".format(op=op, constant=other),\n                binds=(self,),\n            )\n        raise BadBinaryOperator(op, self, other)\n\n    binary_operator.__doc__ = \"Binary Operator: '%s'\" % op\n    return binary_operator",
    "smell": []
}