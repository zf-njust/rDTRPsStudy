{
    "code": "def do_layout(self, *largs):\n        if not self.children:\n            self.minimum_size = (0., 0.)\n            return\n\n        # optimize layout by preventing looking at the same attribute in a loop\n        selfpos = self.pos\n        selfsize = self.size\n        orientation = self.orientation.split('-')\n        padding_left = self.padding[0]\n        padding_top = self.padding[1]\n        padding_right = self.padding[2]\n        padding_bottom = self.padding[3]\n\n        padding_x = padding_left + padding_right\n        padding_y = padding_top + padding_bottom\n        spacing_x, spacing_y = self.spacing\n\n        # Determine which direction and in what order to place the widgets\n        posattr = [0] * 2\n        posdelta = [0] * 2\n        posstart = [0] * 2\n        for i in (0, 1):\n            posattr[i] = 1 * (orientation[i] in ('tb', 'bt'))\n            k = posattr[i]\n            if orientation[i] == 'lr':\n                # left to right\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_left\n            elif orientation[i] == 'bt':\n                # bottom to top\n                posdelta[i] = 1\n                posstart[i] = selfpos[k] + padding_bottom\n            elif orientation[i] == 'rl':\n                # right to left\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_right\n            else:\n                # top to bottom\n                posdelta[i] = -1\n                posstart[i] = selfpos[k] + selfsize[k] - padding_top\n\n        innerattr, outerattr = posattr\n        ustart, vstart = posstart\n        deltau, deltav = posdelta\n        del posattr, posdelta, posstart\n\n        u = ustart  # inner loop position variable\n        v = vstart  # outer loop position variable\n\n        # space calculation, used for determining when a row or column is full\n\n        if orientation[0] in ('lr', 'rl'):\n            sv = padding_y  # size in v-direction, for minimum_size property\n            su = padding_x  # size in h-direction\n            spacing_u = spacing_x\n            spacing_v = spacing_y\n            padding_u = padding_x\n            padding_v = padding_y\n        else:\n            sv = padding_x  # size in v-direction, for minimum_size property\n            su = padding_y  # size in h-direction\n            spacing_u = spacing_y\n            spacing_v = spacing_x\n            padding_u = padding_y\n            padding_v = padding_x\n\n        # space calculation, row height or column width, for arranging widgets\n        lv = 0\n\n        urev = (deltau < 0)\n        vrev = (deltav < 0)\n        firstchild = self.children[0]\n        sizes = []\n        lc = []\n        for c in reversed(self.children):\n            if c.size_hint[outerattr] is not None:\n                c.size[outerattr] = max(\n                    1, _compute_size(c, selfsize[outerattr] - padding_v,\n                                     outerattr))\n\n            # does the widget fit in the row/column?\n            ccount = len(lc)\n            totalsize = availsize = max(\n                0, selfsize[innerattr] - padding_u - spacing_u * ccount)\n            if not lc:\n                if c.size_hint[innerattr] is not None:\n                    childsize = max(1, _compute_size(c, totalsize, innerattr))\n                else:\n                    childsize = max(0, c.size[innerattr])\n                availsize = selfsize[innerattr] - padding_u - childsize\n                testsizes = [childsize]\n            else:\n                testsizes = [0] * (ccount + 1)\n                for i, child in enumerate(lc):\n                    if availsize <= 0:\n                        # no space left but we're trying to add another widget.\n                        availsize = -1\n                        break\n                    if child.size_hint[innerattr] is not None:\n                        testsizes[i] = childsize = max(\n                            1, _compute_size(child, totalsize, innerattr))\n                    else:\n                        childsize = max(0, child.size[innerattr])\n                        testsizes[i] = childsize\n                    availsize -= childsize\n                if c.size_hint[innerattr] is not None:\n                    testsizes[-1] = max(\n                        1, _compute_size(c, totalsize, innerattr))\n                else:\n                    testsizes[-1] = max(0, c.size[innerattr])\n                availsize -= testsizes[-1]\n\n            # Tiny value added in order to avoid issues with float precision\n            # causing unexpected children reordering when parent resizes.\n            # e.g. if size is 101 and children size_hint_x is 1./5\n            # 5 children would not fit in one line because 101*(1./5) > 101/5\n            if (availsize + 1e-10) >= 0 or not lc:\n                # even if there's no space, we always add one widget to a row\n                lc.append(c)\n                sizes = testsizes\n                lv = max(lv, c.size[outerattr])\n                continue\n\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    # v position is actually the top/right side of the widget\n                    # when going from high to low coordinate values,\n                    # we need to subtract the height/width from the position.\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n            v += deltav * lv\n            v += deltav * spacing_v\n            lc = [c]\n            lv = c.size[outerattr]\n            if c.size_hint[innerattr] is not None:\n                sizes = [\n                    max(1, _compute_size(c, selfsize[innerattr] - padding_u,\n                                         innerattr))]\n            else:\n                sizes = [max(0, c.size[innerattr])]\n            u = ustart\n\n        if lc:\n            # apply the sizes\n            for i, child in enumerate(lc):\n                if child.size_hint[innerattr] is not None:\n                    child.size[innerattr] = sizes[i]\n\n            # push the last (incomplete) line\n            sv += lv + spacing_v\n            for c2 in lc:\n                if urev:\n                    u -= c2.size[innerattr]\n                c2.pos[innerattr] = u\n                pos_outer = v\n                if vrev:\n                    pos_outer -= c2.size[outerattr]\n                c2.pos[outerattr] = pos_outer\n                if urev:\n                    u -= spacing_u\n                else:\n                    u += c2.size[innerattr] + spacing_u\n\n        self.minimum_size[outerattr] = sv",
    "smell": []
}