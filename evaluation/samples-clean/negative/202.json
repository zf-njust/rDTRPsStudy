{
    "code": "def __init__(self,\n                 num_classes: int,\n                 in_channels: int,\n                 regress_ranges: RangeType = ((-1, 64), (64, 128), (128, 256),\n                                              (256, 512), (512, INF)),\n                 center_sampling: bool = False,\n                 center_sample_radius: float = 1.5,\n                 sync_num_pos: bool = True,\n                 gradient_mul: float = 0.1,\n                 bbox_norm_type: str = 'reg_denom',\n                 loss_cls_fl: ConfigType = dict(\n                     type='FocalLoss',\n                     use_sigmoid=True,\n                     gamma=2.0,\n                     alpha=0.25,\n                     loss_weight=1.0),\n                 use_vfl: bool = True,\n                 loss_cls: ConfigType = dict(\n                     type='VarifocalLoss',\n                     use_sigmoid=True,\n                     alpha=0.75,\n                     gamma=2.0,\n                     iou_weighted=True,\n                     loss_weight=1.0),\n                 loss_bbox: ConfigType = dict(\n                     type='GIoULoss', loss_weight=1.5),\n                 loss_bbox_refine: ConfigType = dict(\n                     type='GIoULoss', loss_weight=2.0),\n                 norm_cfg: ConfigType = dict(\n                     type='GN', num_groups=32, requires_grad=True),\n                 use_atss: bool = True,\n                 reg_decoded_bbox: bool = True,\n                 anchor_generator: ConfigType = dict(\n                     type='AnchorGenerator',\n                     ratios=[1.0],\n                     octave_base_scale=8,\n                     scales_per_octave=1,\n                     center_offset=0.0,\n                     strides=[8, 16, 32, 64, 128]),\n                 init_cfg: MultiConfig = dict(\n                     type='Normal',\n                     layer='Conv2d',\n                     std=0.01,\n                     override=dict(\n                         type='Normal',\n                         name='vfnet_cls',\n                         std=0.01,\n                         bias_prob=0.01)),\n                 **kwargs) -> None:\n        # dcn base offsets, adapted from reppoints_head.py\n        self.num_dconv_points = 9\n        self.dcn_kernel = int(np.sqrt(self.num_dconv_points))\n        self.dcn_pad = int((self.dcn_kernel - 1) / 2)\n        dcn_base = np.arange(-self.dcn_pad,\n                             self.dcn_pad + 1).astype(np.float64)\n        dcn_base_y = np.repeat(dcn_base, self.dcn_kernel)\n        dcn_base_x = np.tile(dcn_base, self.dcn_kernel)\n        dcn_base_offset = np.stack([dcn_base_y, dcn_base_x], axis=1).reshape(\n            (-1))\n        self.dcn_base_offset = torch.tensor(dcn_base_offset).view(1, -1, 1, 1)\n\n        super(FCOSHead, self).__init__(\n            num_classes=num_classes,\n            in_channels=in_channels,\n            norm_cfg=norm_cfg,\n            init_cfg=init_cfg,\n            **kwargs)\n        self.regress_ranges = regress_ranges\n        self.reg_denoms = [\n            regress_range[-1] for regress_range in regress_ranges\n        ]\n        self.reg_denoms[-1] = self.reg_denoms[-2] * 2\n        self.center_sampling = center_sampling\n        self.center_sample_radius = center_sample_radius\n        self.sync_num_pos = sync_num_pos\n        self.bbox_norm_type = bbox_norm_type\n        self.gradient_mul = gradient_mul\n        self.use_vfl = use_vfl\n        if self.use_vfl:\n            self.loss_cls = MODELS.build(loss_cls)\n        else:\n            self.loss_cls = MODELS.build(loss_cls_fl)\n        self.loss_bbox = MODELS.build(loss_bbox)\n        self.loss_bbox_refine = MODELS.build(loss_bbox_refine)\n\n        # for getting ATSS targets\n        self.use_atss = use_atss\n        self.reg_decoded_bbox = reg_decoded_bbox\n        self.use_sigmoid_cls = loss_cls.get('use_sigmoid', False)\n\n        self.anchor_center_offset = anchor_generator['center_offset']\n\n        self.num_base_priors = self.prior_generator.num_base_priors[0]\n\n        if self.train_cfg:\n            self.assigner = TASK_UTILS.build(self.train_cfg['assigner'])\n            if self.train_cfg.get('sampler', None) is not None:\n                self.sampler = TASK_UTILS.build(\n                    self.train_cfg['sampler'], default_args=dict(context=self))\n            else:\n                self.sampler = PseudoSampler()\n        # only be used in `get_atss_targets` when `use_atss` is True\n        self.atss_prior_generator = TASK_UTILS.build(anchor_generator)\n\n        self.fcos_prior_generator = MlvlPointGenerator(\n            anchor_generator['strides'],\n            self.anchor_center_offset if self.use_atss else 0.5)\n\n        # In order to reuse the `get_bboxes` in `BaseDenseHead.\n        # Only be used in testing phase.\n        self.prior_generator = self.fcos_prior_generator",
    "smell": []
}