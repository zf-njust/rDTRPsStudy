{
    "code": "def jax2tflite(harness: ModelHarness, use_flex_ops: bool = False):\n  \"\"\"Returns a converter with Flex ops linked in iff `use_flex_ops==True`.\"\"\"\n  tf_fn = tf.function(\n      jax2tf_convert(harness, enable_xla=False),\n      input_signature=harness.tf_input_signature,\n      autograph=False)\n  apply_tf = tf_fn.get_concrete_function()\n  converter = tf.lite.TFLiteConverter.from_concrete_functions([apply_tf], tf_fn)\n  supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]\n  if use_flex_ops:\n    supported_ops.append(tf.lite.OpsSet.SELECT_TF_OPS)\n  converter.target_spec.supported_ops = supported_ops\n\n  # Convert the model.\n  tflite_model = converter.convert()\n\n  # Construct an interpreter for doing a numerical comparison.\n  interpreter = tf.lite.Interpreter(model_content=tflite_model)\n  interpreter.allocate_tensors()\n\n  inputs = interpreter.get_input_details()\n  output_details = interpreter.get_output_details()\n  outputs = tuple(interpreter.tensor(out[\"index\"]) for out in output_details)\n\n  def apply_tflite(*xs):\n    assert len(xs) == len(inputs)\n    for i, x in enumerate(xs):\n      interpreter.set_tensor(inputs[i]['index'], x)\n    interpreter.invoke()\n    if len(outputs) > 1:\n      return tuple(o() for o in outputs)\n    else:\n      return outputs[0]()\n\n  return apply_tflite",
    "smell": []
}