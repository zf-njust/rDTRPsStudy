{
    "code": "def assign(self,\n               pred_instances: InstanceData,\n               gt_instances: InstanceData,\n               gt_instances_ignore: Optional[InstanceData] = None,\n               **kwargs) -> AssignResult:\n        \"\"\"Assign gt to bboxes.\n\n        This method assign a gt bbox to every bbox (proposal/anchor), each bbox\n        will be assigned with -1, or a semi-positive number. -1 means negative\n        sample, semi-positive number is the index (0-based) of assigned gt.\n        The assignment is done in following steps, the order matters.\n\n        1. assign every bbox to the background\n        2. assign proposals whose iou with all gts < neg_iou_thr to 0\n        3. for each bbox, if the iou with its nearest gt >= pos_iou_thr,\n           assign it to that bbox\n        4. for each gt bbox, assign its nearest proposals (may be more than\n           one) to itself\n\n        Args:\n            pred_instances (:obj:`InstanceData`): Instances of model\n                predictions. It includes ``priors``, and the priors can\n                be anchors or points, or the bboxes predicted by the\n                previous stage, has shape (n, 4). The bboxes predicted by\n                the current model or stage will be named ``bboxes``,\n                ``labels``, and ``scores``, the same as the ``InstanceData``\n                in other places.\n            gt_instances (:obj:`InstanceData`): Ground truth of instance\n                annotations. It usually includes ``bboxes``, with shape (k, 4),\n                and ``labels``, with shape (k, ).\n            gt_instances_ignore (:obj:`InstanceData`, optional): Instances\n                to be ignored during training. It includes ``bboxes``\n                attribute data that is ignored during training and testing.\n                Defaults to None.\n\n        Returns:\n            :obj:`AssignResult`: The assign result.\n\n        Example:\n            >>> from mmengine.structures import InstanceData\n            >>> self = MaxIoUAssigner(0.5, 0.5)\n            >>> pred_instances = InstanceData()\n            >>> pred_instances.priors = torch.Tensor([[0, 0, 10, 10],\n            ...                                      [10, 10, 20, 20]])\n            >>> gt_instances = InstanceData()\n            >>> gt_instances.bboxes = torch.Tensor([[0, 0, 10, 9]])\n            >>> gt_instances.labels = torch.Tensor([0])\n            >>> assign_result = self.assign(pred_instances, gt_instances)\n            >>> expected_gt_inds = torch.LongTensor([1, 0])\n            >>> assert torch.all(assign_result.gt_inds == expected_gt_inds)\n        \"\"\"\n        gt_bboxes = gt_instances.bboxes\n        priors = pred_instances.priors\n        gt_labels = gt_instances.labels\n        if gt_instances_ignore is not None:\n            gt_bboxes_ignore = gt_instances_ignore.bboxes\n        else:\n            gt_bboxes_ignore = None\n\n        assign_on_cpu = True if (self.gpu_assign_thr > 0) and (\n            gt_bboxes.shape[0] > self.gpu_assign_thr) else False\n        # compute overlap and assign gt on CPU when number of GT is large\n        if assign_on_cpu:\n            device = priors.device\n            priors = priors.cpu()\n            gt_bboxes = gt_bboxes.cpu()\n            gt_labels = gt_labels.cpu()\n            if gt_bboxes_ignore is not None:\n                gt_bboxes_ignore = gt_bboxes_ignore.cpu()\n\n        trans_priors = torch.cat([\n            priors[..., 1].view(-1, 1), priors[..., 0].view(-1, 1),\n            priors[..., 3].view(-1, 1), priors[..., 2].view(-1, 1)\n        ],\n                                 dim=-1)\n        overlaps = self.iou_calculator(gt_bboxes, trans_priors)\n\n        if (self.ignore_iof_thr > 0 and gt_bboxes_ignore is not None\n                and gt_bboxes_ignore.numel() > 0 and trans_priors.numel() > 0):\n            if self.ignore_wrt_candidates:\n                ignore_overlaps = self.iou_calculator(\n                    trans_priors, gt_bboxes_ignore, mode='iof')\n                ignore_max_overlaps, _ = ignore_overlaps.max(dim=1)\n            else:\n                ignore_overlaps = self.iou_calculator(\n                    gt_bboxes_ignore, trans_priors, mode='iof')\n                ignore_max_overlaps, _ = ignore_overlaps.max(dim=0)\n            overlaps[:, ignore_max_overlaps > self.ignore_iof_thr] = -1\n\n        assign_result = self.assign_wrt_overlaps(overlaps, gt_labels)\n        if assign_on_cpu:\n            assign_result.gt_inds = assign_result.gt_inds.to(device)\n            assign_result.max_overlaps = assign_result.max_overlaps.to(device)\n            if assign_result.labels is not None:\n                assign_result.labels = assign_result.labels.to(device)\n        return assign_result",
    "smell": []
}