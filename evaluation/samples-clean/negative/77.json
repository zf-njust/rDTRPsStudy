{
    "code": "def search_for(self, dependency):  # type: (Dependency) -> List[Package]\n        \"\"\"\n        Search for the specifications that match the given dependency.\n\n        The specifications in the returned list will be considered in reverse\n        order, so the latest version ought to be last.\n        \"\"\"\n        if dependency.is_root:\n            return PackageCollection(dependency, [self._package])\n\n        for constraint in self._search_for.keys():\n            if (\n                constraint.name == dependency.name\n                and constraint.constraint.intersect(dependency.constraint)\n                == dependency.constraint\n            ):\n                packages = [\n                    p\n                    for p in self._search_for[constraint]\n                    if dependency.constraint.allows(p.version)\n                ]\n\n                packages.sort(\n                    key=lambda p: (\n                        not p.is_prerelease() and not dependency.allows_prereleases(),\n                        p.version,\n                    ),\n                    reverse=True,\n                )\n\n                return PackageCollection(dependency, packages)\n\n        if dependency.is_vcs():\n            packages = self.search_for_vcs(dependency)\n        elif dependency.is_file():\n            packages = self.search_for_file(dependency)\n        elif dependency.is_directory():\n            packages = self.search_for_directory(dependency)\n        elif dependency.is_url():\n            packages = self.search_for_url(dependency)\n        else:\n            constraint = dependency.constraint\n\n            packages = self._pool.find_packages(\n                dependency.name,\n                constraint,\n                extras=dependency.extras,\n                allow_prereleases=dependency.allows_prereleases(),\n                repository=dependency.source_name,\n            )\n\n            packages.sort(\n                key=lambda p: (\n                    not p.is_prerelease() and not dependency.allows_prereleases(),\n                    p.version,\n                ),\n                reverse=True,\n            )\n\n        self._search_for[dependency] = packages\n\n        return PackageCollection(dependency, packages)",
    "smell": []
}