{
    "code": "def assign(self,\n               pred_instances: InstanceData,\n               gt_instances: InstanceData,\n               gt_instances_ignore: Optional[InstanceData] = None,\n               alpha: int = 1,\n               beta: int = 6) -> AssignResult:\n        \"\"\"Assign gt to bboxes.\n\n        The assignment is done in following steps\n\n        1. compute alignment metric between all bbox (bbox of all pyramid\n           levels) and gt\n        2. select top-k bbox as candidates for each gt\n        3. limit the positive sample's center in gt (because the anchor-free\n           detector only can predict positive distance)\n\n\n        Args:\n            pred_instances (:obj:`InstaceData`): Instances of model\n                predictions. It includes ``priors``, and the priors can\n                be anchors, points, or bboxes predicted by the model,\n                shape(n, 4).\n            gt_instances (:obj:`InstaceData`): Ground truth of instance\n                annotations. It usually includes ``bboxes`` and ``labels``\n                attributes.\n            gt_instances_ignore (:obj:`InstaceData`, optional): Instances\n                to be ignored during training. It includes ``bboxes``\n                attribute data that is ignored during training and testing.\n                Defaults to None.\n            alpha (int): Hyper-parameters related to alignment_metrics.\n                Defaults to 1.\n            beta (int): Hyper-parameters related to alignment_metrics.\n                Defaults to 6.\n\n        Returns:\n            :obj:`TaskAlignedAssignResult`: The assign result.\n        \"\"\"\n        priors = pred_instances.priors\n        decode_bboxes = pred_instances.bboxes\n        pred_scores = pred_instances.scores\n        gt_bboxes = gt_instances.bboxes\n        gt_labels = gt_instances.labels\n\n        priors = priors[:, :4]\n        num_gt, num_bboxes = gt_bboxes.size(0), priors.size(0)\n        # compute alignment metric between all bbox and gt\n        overlaps = self.iou_calculator(decode_bboxes, gt_bboxes).detach()\n        bbox_scores = pred_scores[:, gt_labels].detach()\n        # assign 0 by default\n        assigned_gt_inds = priors.new_full((num_bboxes, ), 0, dtype=torch.long)\n        assign_metrics = priors.new_zeros((num_bboxes, ))\n\n        if num_gt == 0 or num_bboxes == 0:\n            # No ground truth or boxes, return empty assignment\n            max_overlaps = priors.new_zeros((num_bboxes, ))\n            if num_gt == 0:\n                # No gt boxes, assign everything to background\n                assigned_gt_inds[:] = 0\n            assigned_labels = priors.new_full((num_bboxes, ),\n                                              -1,\n                                              dtype=torch.long)\n            assign_result = AssignResult(\n                num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n            assign_result.assign_metrics = assign_metrics\n            return assign_result\n\n        # select top-k bboxes as candidates for each gt\n        alignment_metrics = bbox_scores**alpha * overlaps**beta\n        topk = min(self.topk, alignment_metrics.size(0))\n        _, candidate_idxs = alignment_metrics.topk(topk, dim=0, largest=True)\n        candidate_metrics = alignment_metrics[candidate_idxs,\n                                              torch.arange(num_gt)]\n        is_pos = candidate_metrics > 0\n\n        # limit the positive sample's center in gt\n        priors_cx = (priors[:, 0] + priors[:, 2]) / 2.0\n        priors_cy = (priors[:, 1] + priors[:, 3]) / 2.0\n        for gt_idx in range(num_gt):\n            candidate_idxs[:, gt_idx] += gt_idx * num_bboxes\n        ep_priors_cx = priors_cx.view(1, -1).expand(\n            num_gt, num_bboxes).contiguous().view(-1)\n        ep_priors_cy = priors_cy.view(1, -1).expand(\n            num_gt, num_bboxes).contiguous().view(-1)\n        candidate_idxs = candidate_idxs.view(-1)\n\n        # calculate the left, top, right, bottom distance between positive\n        # bbox center and gt side\n        l_ = ep_priors_cx[candidate_idxs].view(-1, num_gt) - gt_bboxes[:, 0]\n        t_ = ep_priors_cy[candidate_idxs].view(-1, num_gt) - gt_bboxes[:, 1]\n        r_ = gt_bboxes[:, 2] - ep_priors_cx[candidate_idxs].view(-1, num_gt)\n        b_ = gt_bboxes[:, 3] - ep_priors_cy[candidate_idxs].view(-1, num_gt)\n        is_in_gts = torch.stack([l_, t_, r_, b_], dim=1).min(dim=1)[0] > 0.01\n        is_pos = is_pos & is_in_gts\n\n        # if an anchor box is assigned to multiple gts,\n        # the one with the highest iou will be selected.\n        overlaps_inf = torch.full_like(overlaps,\n                                       -INF).t().contiguous().view(-1)\n        index = candidate_idxs.view(-1)[is_pos.view(-1)]\n        overlaps_inf[index] = overlaps.t().contiguous().view(-1)[index]\n        overlaps_inf = overlaps_inf.view(num_gt, -1).t()\n\n        max_overlaps, argmax_overlaps = overlaps_inf.max(dim=1)\n        assigned_gt_inds[\n            max_overlaps != -INF] = argmax_overlaps[max_overlaps != -INF] + 1\n        assign_metrics[max_overlaps != -INF] = alignment_metrics[\n            max_overlaps != -INF, argmax_overlaps[max_overlaps != -INF]]\n\n        assigned_labels = assigned_gt_inds.new_full((num_bboxes, ), -1)\n        pos_inds = torch.nonzero(\n            assigned_gt_inds > 0, as_tuple=False).squeeze()\n        if pos_inds.numel() > 0:\n            assigned_labels[pos_inds] = gt_labels[assigned_gt_inds[pos_inds] -\n                                                  1]\n        assign_result = AssignResult(\n            num_gt, assigned_gt_inds, max_overlaps, labels=assigned_labels)\n        assign_result.assign_metrics = assign_metrics\n        return assign_result",
    "smell": []
}