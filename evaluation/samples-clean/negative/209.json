{
    "code": "def getRoles(self, query2=False):\n        infoMsg = \"fetching database users roles\"\n\n        rootQuery = queries[Backend.getIdentifiedDbms()].roles\n\n        if conf.user == \"CU\":\n            infoMsg += \" for current user\"\n            conf.user = self.getCurrentUser()\n\n        logger.info(infoMsg)\n\n        # Set containing the list of DBMS administrators\n        areAdmins = set()\n\n        if any(isTechniqueAvailable(_) for _ in (PAYLOAD.TECHNIQUE.UNION, PAYLOAD.TECHNIQUE.ERROR, PAYLOAD.TECHNIQUE.QUERY)) or conf.direct:\n            if query2:\n                query = rootQuery.inband.query2\n                condition = rootQuery.inband.condition2\n            else:\n                query = rootQuery.inband.query\n                condition = rootQuery.inband.condition\n\n            if conf.user:\n                users = conf.user.split(\",\")\n                query += \" WHERE \"\n                query += \" OR \".join(\"%s = '%s'\" % (condition, user) for user in sorted(users))\n\n            values = inject.getValue(query, blind=False, time=False)\n\n            if not values and not query2:\n                infoMsg = \"trying with table USER_ROLE_PRIVS\"\n                logger.info(infoMsg)\n\n                return self.getRoles(query2=True)\n\n            if not isNoneValue(values):\n                for value in values:\n                    user = None\n                    roles = set()\n\n                    for count in xrange(0, len(value)):\n                        # The first column is always the username\n                        if count == 0:\n                            user = value[count]\n\n                        # The other columns are the roles\n                        else:\n                            role = value[count]\n\n                            # In Oracle we get the list of roles as string\n                            roles.add(role)\n\n                    if user in kb.data.cachedUsersRoles:\n                        kb.data.cachedUsersRoles[user] = list(roles.union(kb.data.cachedUsersRoles[user]))\n                    else:\n                        kb.data.cachedUsersRoles[user] = list(roles)\n\n        if not kb.data.cachedUsersRoles and isInferenceAvailable() and not conf.direct:\n            if conf.user:\n                users = conf.user.split(\",\")\n            else:\n                if not len(kb.data.cachedUsers):\n                    users = self.getUsers()\n                else:\n                    users = kb.data.cachedUsers\n\n            retrievedUsers = set()\n\n            for user in users:\n                unescapedUser = None\n\n                if user in retrievedUsers:\n                    continue\n\n                infoMsg = \"fetching number of roles \"\n                infoMsg += \"for user '%s'\" % user\n                logger.info(infoMsg)\n\n                if unescapedUser:\n                    queryUser = unescapedUser\n                else:\n                    queryUser = user\n\n                if query2:\n                    query = rootQuery.blind.count2 % queryUser\n                else:\n                    query = rootQuery.blind.count % queryUser\n                count = inject.getValue(query, union=False, error=False, expected=EXPECTED.INT, charsetType=CHARSET_TYPE.DIGITS)\n\n                if not isNumPosStrValue(count):\n                    if count != 0 and not query2:\n                        infoMsg = \"trying with table USER_SYS_PRIVS\"\n                        logger.info(infoMsg)\n\n                        return self.getPrivileges(query2=True)\n\n                    warnMsg = \"unable to retrieve the number of \"\n                    warnMsg += \"roles for user '%s'\" % user\n                    logger.warn(warnMsg)\n                    continue\n\n                infoMsg = \"fetching roles for user '%s'\" % user\n                logger.info(infoMsg)\n\n                roles = set()\n\n                indexRange = getLimitRange(count, plusOne=True)\n\n                for index in indexRange:\n                    if query2:\n                        query = rootQuery.blind.query2 % (queryUser, index)\n                    else:\n                        query = rootQuery.blind.query % (queryUser, index)\n                    role = inject.getValue(query, union=False, error=False)\n\n                    # In Oracle we get the list of roles as string\n                    roles.add(role)\n\n                if roles:\n                    kb.data.cachedUsersRoles[user] = list(roles)\n                else:\n                    warnMsg = \"unable to retrieve the roles \"\n                    warnMsg += \"for user '%s'\" % user\n                    logger.warn(warnMsg)\n\n                retrievedUsers.add(user)\n\n        if not kb.data.cachedUsersRoles:\n            errMsg = \"unable to retrieve the roles \"\n            errMsg += \"for the database users\"\n            raise SqlmapNoneDataException(errMsg)\n\n        for user, privileges in kb.data.cachedUsersRoles.items():\n            if isAdminFromPrivileges(privileges):\n                areAdmins.add(user)\n\n        return kb.data.cachedUsersRoles, areAdmins",
    "smell": []
}