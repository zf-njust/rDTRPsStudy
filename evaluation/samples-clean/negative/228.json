{
    "code": "def _get_dep_statuses(self, ti: TI, session, dep_context):\n        if dep_context.ignore_depends_on_past:\n            self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n            reason = \"The context specified that the state of past DAGs could be ignored.\"\n            yield self._passing_status(reason=reason)\n            return\n\n        if not ti.task.depends_on_past:\n            self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n            yield self._passing_status(reason=\"The task did not have depends_on_past set.\")\n            return\n\n        dr = ti.get_dagrun(session=session)\n        if not dr:\n            self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n            yield self._passing_status(reason=\"This task instance does not belong to a DAG.\")\n            return\n\n        # Don't depend on the previous task instance if we are the first task.\n        catchup = ti.task.dag and ti.task.dag.catchup\n        if catchup:\n            last_dagrun = dr.get_previous_scheduled_dagrun(session)\n        else:\n            last_dagrun = dr.get_previous_dagrun(session=session)\n\n        # First ever run for this DAG.\n        if not last_dagrun:\n            self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n            yield self._passing_status(reason=\"This task instance was the first task instance for its task.\")\n            return\n\n        # There was a DAG run, but the task wasn't active back then.\n        if catchup and last_dagrun.execution_date < ti.task.start_date:\n            self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n            yield self._passing_status(reason=\"This task instance was the first task instance for its task.\")\n            return\n\n        previous_ti = last_dagrun.get_task_instance(ti.task_id, map_index=ti.map_index, session=session)\n        if not previous_ti:\n            if ti.task.ignore_first_depends_on_past:\n                has_historical_ti = (\n                    session.query(func.count(TI.dag_id))\n                    .filter(\n                        TI.dag_id == ti.dag_id,\n                        TI.task_id == ti.task_id,\n                        TI.execution_date < ti.execution_date,\n                    )\n                    .scalar()\n                    > 0\n                )\n                if not has_historical_ti:\n                    self._push_past_deps_met_xcom_if_needed(ti, dep_context)\n                    yield self._passing_status(\n                        reason=\"ignore_first_depends_on_past is true for this task \"\n                        \"and it is the first task instance for its task.\"\n                    )\n                    return\n\n            yield self._failing_status(\n                reason=\"depends_on_past is true for this task's DAG, but the previous \"\n                \"task instance has not run yet.\"\n            )\n            return\n\n        if previous_ti.state not in {State.SKIPPED, State.SUCCESS}:\n            yield self._failing_status(\n                reason=(\n                    f\"depends_on_past is true for this task, but the previous task instance {previous_ti} \"\n                    f\"is in the state '{previous_ti.state}' which is not a successful state.\"\n                )\n            )\n            return\n\n        previous_ti.task = ti.task\n        if ti.task.wait_for_downstream and not previous_ti.are_dependents_done(session=session):\n            yield self._failing_status(\n                reason=(\n                    f\"The tasks downstream of the previous task instance {previous_ti} haven't completed \"\n                    f\"(and wait_for_downstream is True).\"\n                )\n            )\n            return\n        self._push_past_deps_met_xcom_if_needed(ti, dep_context)",
    "smell": []
}