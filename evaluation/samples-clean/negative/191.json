{
    "code": "def _extend_control_events(control_signal_fns, disable_conditioning_fn,\n                           control_events, performance, control_state):\n  \"\"\"Extend a performance control sequence.\n\n  Extends `control_events` -- a sequence of control signal value tuples -- to be\n  one event longer than `performance`, so the next event of `performance` can be\n  conditionally generated.\n\n  This function is meant to be used as the `extend_control_events_callback`\n  in the `_generate_events` method of `EventSequenceRnnModel`.\n\n  Args:\n    control_signal_fns: A list of functions that map time step to desired\n        control value, or None if not using control signals.\n    disable_conditioning_fn: A function that maps time step to whether or not\n        conditioning should be disabled, or None if there is no conditioning or\n        conditioning is not optional.\n    control_events: The control sequence to extend.\n    performance: The Performance being generated.\n    control_state: A PerformanceControlState tuple containing the current\n        position in `performance`. We maintain this so as not to have to\n        recompute the total performance length (in steps) every time we want to\n        extend the control sequence.\n\n  Returns:\n    The PerformanceControlState after extending the control sequence one step\n    past the end of the generated performance.\n  \"\"\"\n  idx = control_state.current_perf_index\n  step = control_state.current_perf_step\n\n  while idx < len(performance):\n    if performance[idx].event_type == note_seq.PerformanceEvent.TIME_SHIFT:\n      step += performance[idx].event_value\n    idx += 1\n\n    control_event = tuple(f(step) for f in control_signal_fns)\n    if disable_conditioning_fn is not None:\n      control_event = (disable_conditioning_fn(step), control_event)\n    control_events.append(control_event)\n\n  return PerformanceControlState(\n      current_perf_index=idx, current_perf_step=step)",
    "smell": []
}