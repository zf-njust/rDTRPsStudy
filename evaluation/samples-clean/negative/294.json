{
    "code": "def _value_and_input_files_from_input(  # pylint: disable=too-many-return-statements\n        value: object,\n    ) -> Tuple[object, List[InputFile]]:\n        \"\"\"Converts `value` into something that we can json-dump. Returns two values:\n        1. the JSON-dumpable value. Maybe be `None` in case the value is an InputFile which must\n           not be uploaded via an attach:// URI\n        2. A list of InputFiles that should be uploaded for this value\n\n        Note that we handle files differently depending on whether attaching them via an URI of the\n        form attach://<name> is documented to be allowed or not.\n        There was some confusion whether this worked for all files, so that we stick to the\n        documented ways for now.\n        See https://github.com/tdlib/telegram-bot-api/issues/167 and\n        https://github.com/tdlib/telegram-bot-api/issues/259\n\n        This method only does some special casing for our own helper class StringEnum, but not\n        for general enums. This is because:\n        * tg.constants currently only uses IntEnum as second enum type and json dumping that\n          is no problem\n        * if a user passes a custom enum, it's unlikely that we can actually properly handle it\n          even with some special casing.\n        \"\"\"\n        if isinstance(value, datetime):\n            return to_timestamp(value), []\n        if isinstance(value, StringEnum):\n            return value.value, []\n        if isinstance(value, InputFile):\n            if value.attach_uri:\n                return value.attach_uri, [value]\n            return None, [value]\n\n        if isinstance(value, InputMedia) and isinstance(value.media, InputFile):\n            # We call to_dict and change the returned dict instead of overriding\n            # value.media in case the same value is reused for another request\n            data = value.to_dict()\n            if value.media.attach_uri:\n                data[\"media\"] = value.media.attach_uri\n            else:\n                data.pop(\"media\", None)\n\n            thumbnail = data.get(\"thumbnail\", None)\n            if isinstance(thumbnail, InputFile):\n                if thumbnail.attach_uri:\n                    data[\"thumbnail\"] = thumbnail.attach_uri\n                else:\n                    data.pop(\"thumbnail\", None)\n                return data, [value.media, thumbnail]\n\n            return data, [value.media]\n        if isinstance(value, InputSticker) and isinstance(value.sticker, InputFile):\n            # We call to_dict and change the returned dict instead of overriding\n            # value.sticker in case the same value is reused for another request\n            data = value.to_dict()\n            data[\"sticker\"] = value.sticker.attach_uri\n            return data, [value.sticker]\n\n        if isinstance(value, TelegramObject):\n            # Needs to be last, because InputMedia is a subclass of TelegramObject\n            return value.to_dict(), []\n        return value, []",
    "smell": []
}