{
  "code": "def test_tracker(self, parameter_comment, days_to_delete):\n        \"\"\"\n        @days_to_delete - configures which days in the data set we should\n        remove, used for ensuring that we still return performance messages\n        even when there is no data.\n        \"\"\"\n        # This date range covers Columbus day,\n        # however Columbus day is not a market holiday\n        #\n        #     October 2008\n        # Su Mo Tu We Th Fr Sa\n        #           1  2  3  4\n        #  5  6  7  8  9 10 11\n        # 12 13 14 15 16 17 18\n        # 19 20 21 22 23 24 25\n        # 26 27 28 29 30 31\n        start_dt = datetime(year=2008,\n                            month=10,\n                            day=9,\n                            tzinfo=pytz.utc)\n        end_dt = datetime(year=2008,\n                          month=10,\n                          day=16,\n                          tzinfo=pytz.utc)\n\n        trade_count = 6\n        sid = 133\n        price = 10.1\n        price_list = [price] * trade_count\n        volume = [100] * trade_count\n        trade_time_increment = timedelta(days=1)\n\n        sim_params = SimulationParameters(\n            period_start=start_dt,\n            period_end=end_dt,\n            env=self.env,\n        )\n\n        benchmark_events = benchmark_events_in_range(sim_params, self.env)\n\n        trade_history = factory.create_trade_history(\n            sid,\n            price_list,\n            volume,\n            trade_time_increment,\n            sim_params,\n            source_id=\"factory1\",\n            env=self.env\n        )\n\n        sid2 = 134\n        price2 = 12.12\n        price2_list = [price2] * trade_count\n        trade_history2 = factory.create_trade_history(\n            sid2,\n            price2_list,\n            volume,\n            trade_time_increment,\n            sim_params,\n            source_id=\"factory2\",\n            env=self.env\n        )\n        # 'middle' start of 3 depends on number of days == 7\n        middle = 3\n\n        # First delete from middle\n        if days_to_delete.middle:\n            del trade_history[middle:(middle + days_to_delete.middle)]\n            del trade_history2[middle:(middle + days_to_delete.middle)]\n\n        # Delete start\n        if days_to_delete.start:\n            del trade_history[:days_to_delete.start]\n            del trade_history2[:days_to_delete.start]\n\n        # Delete from end\n        if days_to_delete.end:\n            del trade_history[-days_to_delete.end:]\n            del trade_history2[-days_to_delete.end:]\n\n        sim_params.capital_base = 1000.0\n        sim_params.frame_index = [\n            'sid',\n            'volume',\n            'dt',\n            'price',\n            'changed']\n        perf_tracker = perf.PerformanceTracker(\n            sim_params, self.env\n        )\n\n        events = date_sorted_sources(trade_history, trade_history2)\n\n        events = [event for event in\n                  self.trades_with_txns(events, trade_history[0].dt)]\n\n        # Extract events with transactions to use for verification.\n        txns = [event for event in\n                events if event.type == zp.DATASOURCE_TYPE.TRANSACTION]\n\n        orders = [event for event in\n                  events if event.type == zp.DATASOURCE_TYPE.ORDER]\n\n        all_events = date_sorted_sources(events, benchmark_events)\n\n        filtered_events = [filt_event for filt_event\n                           in all_events if filt_event.dt <= end_dt]\n        filtered_events.sort(key=lambda x: x.dt)\n        grouped_events = itertools.groupby(filtered_events, lambda x: x.dt)\n        perf_messages = []\n\n        for date, group in grouped_events:\n            for event in group:\n                if event.type == zp.DATASOURCE_TYPE.TRADE:\n                    perf_tracker.process_trade(event)\n                elif event.type == zp.DATASOURCE_TYPE.ORDER:\n                    perf_tracker.process_order(event)\n                elif event.type == zp.DATASOURCE_TYPE.BENCHMARK:\n                    perf_tracker.process_benchmark(event)\n                elif event.type == zp.DATASOURCE_TYPE.TRANSACTION:\n                    perf_tracker.process_transaction(event)\n            msg = perf_tracker.handle_market_close_daily()\n            perf_messages.append(msg)\n\n        self.assertEqual(perf_tracker.txn_count, len(txns))\n        self.assertEqual(perf_tracker.txn_count, len(orders))\n\n        positions = perf_tracker.cumulative_performance.positions\n        if len(txns) == 0:\n            self.assertNotIn(sid, positions)\n        else:\n            expected_size = len(txns) / 2 * -25\n            cumulative_pos = positions[sid]\n            self.assertEqual(cumulative_pos.amount, expected_size)\n\n            self.assertEqual(len(perf_messages),\n                             sim_params.days_in_period)\n\n        check_perf_tracker_serialization(perf_tracker)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 79,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}