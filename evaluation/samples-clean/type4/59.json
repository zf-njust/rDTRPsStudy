{
  "code": "def get_console_script_specs(console: Dict[str, str]) -> List[str]:\n    \"\"\"\n    Given the mapping from entrypoint name to callable, return the relevant\n    console script specs.\n    \"\"\"\n    # Don't mutate caller's version\n    console = console.copy()\n\n    scripts_to_generate = []\n\n    # Special case pip and setuptools to generate versioned wrappers\n    #\n    # The issue is that some projects (specifically, pip and setuptools) use\n    # code in setup.py to create \"versioned\" entry points - pip2.7 on Python\n    # 2.7, pip3.3 on Python 3.3, etc. But these entry points are baked into\n    # the wheel metadata at build time, and so if the wheel is installed with\n    # a *different* version of Python the entry points will be wrong. The\n    # correct fix for this is to enhance the metadata to be able to describe\n    # such versioned entry points, but that won't happen till Metadata 2.0 is\n    # available.\n    # In the meantime, projects using versioned entry points will either have\n    # incorrect versioned entry points, or they will not be able to distribute\n    # \"universal\" wheels (i.e., they will need a wheel per Python version).\n    #\n    # Because setuptools and pip are bundled with _ensurepip and virtualenv,\n    # we need to use universal wheels. So, as a stopgap until Metadata 2.0, we\n    # override the versioned entry points in the wheel and generate the\n    # correct ones. This code is purely a short-term measure until Metadata 2.0\n    # is available.\n    #\n    # To add the level of hack in this section of code, in order to support\n    # ensurepip this code will look for an ``ENSUREPIP_OPTIONS`` environment\n    # variable which will control which version scripts get installed.\n    #\n    # ENSUREPIP_OPTIONS=altinstall\n    #   - Only pipX.Y and easy_install-X.Y will be generated and installed\n    # ENSUREPIP_OPTIONS=install\n    #   - pipX.Y, pipX, easy_install-X.Y will be generated and installed. Note\n    #     that this option is technically if ENSUREPIP_OPTIONS is set and is\n    #     not altinstall\n    # DEFAULT\n    #   - The default behavior is to install pip, pipX, pipX.Y, easy_install\n    #     and easy_install-X.Y.\n    pip_script = console.pop(\"pip\", None)\n    if pip_script:\n        if \"ENSUREPIP_OPTIONS\" not in os.environ:\n            scripts_to_generate.append(\"pip = \" + pip_script)\n\n        if os.environ.get(\"ENSUREPIP_OPTIONS\", \"\") != \"altinstall\":\n            scripts_to_generate.append(\n                \"pip{} = {}\".format(sys.version_info[0], pip_script)\n            )\n\n        scripts_to_generate.append(f\"pip{get_major_minor_version()} = {pip_script}\")\n        # Delete any other versioned pip entry points\n        pip_ep = [k for k in console if re.match(r\"pip(\\d+(\\.\\d+)?)?$\", k)]\n        for k in pip_ep:\n            del console[k]\n    easy_install_script = console.pop(\"easy_install\", None)\n    if easy_install_script:\n        if \"ENSUREPIP_OPTIONS\" not in os.environ:\n            scripts_to_generate.append(\"easy_install = \" + easy_install_script)\n\n        scripts_to_generate.append(\n            \"easy_install-{} = {}\".format(\n                get_major_minor_version(), easy_install_script\n            )\n        )\n        # Delete any other versioned easy_install entry points\n        easy_install_ep = [\n            k for k in console if re.match(r\"easy_install(-\\d+\\.\\d+)?$\", k)\n        ]\n        for k in easy_install_ep:\n            del console[k]\n\n    # Generate the console entry points specified in the wheel\n    scripts_to_generate.extend(starmap(\"{} = {}\".format, console.items()))\n\n    return scripts_to_generate",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 58,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}