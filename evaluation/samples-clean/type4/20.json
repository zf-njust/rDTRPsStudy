{
  "code": "def extendMarkdown(self, md, md_globals):\n        # type: (markdown.Markdown, Dict[str, Any]) -> None\n        del md.preprocessors['reference']\n\n        for k in ('image_link', 'image_reference', 'automail',\n                  'autolink', 'link', 'reference', 'short_reference',\n                  'escape', 'strong_em', 'emphasis', 'emphasis2',\n                  'linebreak', 'strong'):\n            del md.inlinePatterns[k]\n        try:\n            # linebreak2 was removed upstream in version 3.2.1, so\n            # don't throw an error if it is not there\n            del md.inlinePatterns['linebreak2']\n        except Exception:\n            pass\n\n        md.preprocessors.add(\"custom_text_notifications\", AlertWordsNotificationProcessor(md), \"_end\")\n\n        # Custom bold syntax: **foo** but not __foo__\n        md.inlinePatterns.add('strong',\n                              markdown.inlinepatterns.SimpleTagPattern(r'(\\*\\*)([^\\n]+?)\\2', 'strong'),\n                              '>not_strong')\n\n        # Custom strikethrough syntax: ~~foo~~\n        md.inlinePatterns.add('del',\n                              markdown.inlinepatterns.SimpleTagPattern(r'(?<!~)(\\~\\~)([^~{0}\\n]+?)\\2(?!~)', 'del'),\n                              '>strong')\n\n        # Text inside ** must start and end with a word character\n        # it need for things like \"const char *x = (char *)y\"\n        md.inlinePatterns.add(\n            'emphasis',\n            markdown.inlinepatterns.SimpleTagPattern(r'(\\*)(?!\\s+)([^\\*^\\n]+)(?<!\\s)\\*', 'em'),\n            '>strong')\n\n        for k in ('hashheader', 'setextheader', 'olist', 'ulist', 'indent'):\n            del md.parser.blockprocessors[k]\n\n        md.parser.blockprocessors.add('ulist', UListProcessor(md.parser), '>hr')\n        md.parser.blockprocessors.add('indent', ListIndentProcessor(md.parser), '<ulist')\n\n        # Note that !gravatar syntax should be deprecated long term.\n        md.inlinePatterns.add('avatar', Avatar(AVATAR_REGEX), '>backtick')\n        md.inlinePatterns.add('gravatar', Avatar(GRAVATAR_REGEX), '>backtick')\n\n        md.inlinePatterns.add('stream_subscribe_button',\n                              StreamSubscribeButton(r'!_stream_subscribe_button\\((?P<stream_name>(?:[^)\\\\]|\\\\\\)|\\\\)*)\\)'), '>backtick')\n        md.inlinePatterns.add(\n            'modal_link',\n            ModalLink(r'!modal_link\\((?P<relative_url>[^)]*), (?P<text>[^)]*)\\)'),\n            '>avatar')\n        md.inlinePatterns.add('usermention', UserMentionPattern(mention.find_mentions), '>backtick')\n        md.inlinePatterns.add('stream', StreamPattern(STREAM_LINK_REGEX), '>backtick')\n        md.inlinePatterns.add('tex', Tex(r'\\B\\$\\$(?P<body>[^ _$](\\\\\\$|[^$])*)(?! )\\$\\$\\B'), '>backtick')\n        md.inlinePatterns.add('emoji', Emoji(EMOJI_REGEX), '_end')\n        md.inlinePatterns.add('unicodeemoji', UnicodeEmoji(unicode_emoji_regex), '_end')\n        md.inlinePatterns.add('link', AtomicLinkPattern(markdown.inlinepatterns.LINK_RE, md), '>avatar')\n\n        for (pattern, format_string, id) in self.getConfig(\"realm_filters\"):\n            md.inlinePatterns.add('realm_filters/%s' % (pattern,),\n                                  RealmFilterPattern(pattern, format_string), '>link')\n\n        # A link starts at a word boundary, and ends at space, punctuation, or end-of-input.\n        #\n        # We detect a url either by the `https?://` or by building around the TLD.\n\n        # In lieu of having a recursive regex (which python doesn't support) to match\n        # arbitrary numbers of nested matching parenthesis, we manually build a regexp that\n        # can match up to six\n        # The inner_paren_contents chunk matches the innermore non-parenthesis-holding text,\n        # and the paren_group matches text with, optionally, a matching set of parens\n        inner_paren_contents = r\"[^\\s()\\\"]*\"\n        paren_group = r\"\"\"\n                        [^\\s()\\\"]*?            # Containing characters that won't end the URL\n                        (?: \\( %s \\)           # and more characters in matched parens\n                            [^\\s()\\\"]*?        # followed by more characters\n                        )*                     # zero-or-more sets of paired parens\n                       \"\"\"\n        nested_paren_chunk = paren_group\n        for i in range(6):\n            nested_paren_chunk = nested_paren_chunk % (paren_group,)\n        nested_paren_chunk = nested_paren_chunk % (inner_paren_contents,)\n        tlds = '|'.join(list_of_tlds())\n        link_regex = r\"\"\"\n            (?<![^\\s'\"\\(,:<])    # Start after whitespace or specified chars\n                                 # (Double-negative lookbehind to allow start-of-string)\n            (?P<url>             # Main group\n                (?:(?:           # Domain part\n                    https?://[\\w.:@-]+?   # If it has a protocol, anything goes.\n                   |(?:                   # Or, if not, be more strict to avoid false-positives\n                        (?:[\\w-]+\\.)+     # One or more domain components, separated by dots\n                        (?:%s)            # TLDs (filled in via format from tlds-alpha-by-domain.txt)\n                    )\n                )\n                (?:/             # A path, beginning with /\n                    %s           # zero-to-6 sets of paired parens\n                )?)              # Path is optional\n                | (?:[\\w.-]+\\@[\\w.-]+\\.[\\w]+) # Email is separate, since it can't have a path\n                %s               # File path start with file:///, enable by setting ENABLE_FILE_LINKS=True\n            )\n            (?=                            # URL must be followed by (not included in group)\n                [!:;\\?\\),\\.\\'\\\"\\>]*         # Optional punctuation characters\n                (?:\\Z|\\s)                  # followed by whitespace or end of string\n            )\n            \"\"\" % (tlds, nested_paren_chunk,\n                   r\"| (?:file://(/[^/ ]*)+/?)\" if settings.ENABLE_FILE_LINKS else r\"\")\n        md.inlinePatterns.add('autolink', AutoLink(link_regex), '>link')\n\n        md.preprocessors.add('hanging_ulists',\n                             BugdownUListPreprocessor(md),\n                             \"_begin\")\n\n        md.treeprocessors.add(\"inline_interesting_links\", InlineInterestingLinkProcessor(md, self), \"_end\")\n\n        if settings.CAMO_URI:\n            md.treeprocessors.add(\"rewrite_to_https\", InlineHttpsProcessor(md), \"_end\")\n\n        if self.getConfig(\"realm\") == ZEPHYR_MIRROR_BUGDOWN_KEY:\n            # Disable almost all inline patterns for zephyr mirror\n            # users' traffic that is mirrored.  Note that\n            # inline_interesting_links is a treeprocessor and thus is\n            # not removed\n            for k in list(md.inlinePatterns.keys()):\n                if k not in [\"autolink\"]:\n                    del md.inlinePatterns[k]\n            for k in list(md.treeprocessors.keys()):\n                if k not in [\"inline_interesting_links\", \"inline\", \"rewrite_to_https\"]:\n                    del md.treeprocessors[k]\n            for k in list(md.preprocessors.keys()):\n                if k not in [\"custom_text_notifications\"]:\n                    del md.preprocessors[k]\n            for k in list(md.parser.blockprocessors.keys()):\n                if k not in [\"paragraph\"]:\n                    del md.parser.blockprocessors[k]",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 131,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}