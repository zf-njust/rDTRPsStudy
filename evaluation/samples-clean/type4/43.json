{
  "code": "def set_index(self, keys, drop=True, append=False, inplace=False,\n                  verify_integrity=False):\n        \"\"\"\n        Set the DataFrame index (row labels) using one or more existing\n        columns. By default yields a new object.\n\n        Parameters\n        ----------\n        keys : column label or list of column labels / arrays\n        drop : boolean, default True\n            Delete columns to be used as the new index\n        append : boolean, default False\n            Whether to append columns to existing index\n        inplace : boolean, default False\n            Modify the DataFrame in place (do not create a new object)\n        verify_integrity : boolean, default False\n            Check the new index for duplicates. Otherwise defer the check until\n            necessary. Setting to False will improve the performance of this\n            method\n\n        Examples\n        --------\n        >>> indexed_df = df.set_index(['A', 'B'])\n        >>> indexed_df2 = df.set_index(['A', [0, 1, 2, 0, 1, 2]])\n        >>> indexed_df3 = df.set_index([[0, 1, 2, 0, 1, 2]])\n\n        Returns\n        -------\n        dataframe : DataFrame\n        \"\"\"\n        if not isinstance(keys, list):\n            keys = [keys]\n\n        if inplace:\n            frame = self\n        else:\n            frame = self.copy()\n\n        arrays = []\n        names = []\n        if append:\n            names = [x for x in self.index.names]\n            if isinstance(self.index, MultiIndex):\n                for i in range(self.index.nlevels):\n                    arrays.append(self.index.get_level_values(i))\n            else:\n                arrays.append(self.index)\n\n        to_remove = []\n        for col in keys:\n            if isinstance(col, MultiIndex):\n                # append all but the last column so we don't have to modify\n                # the end of this loop\n                for n in range(col.nlevels - 1):\n                    arrays.append(col.get_level_values(n))\n\n                level = col.get_level_values(col.nlevels - 1)\n                names.extend(col.names)\n            elif isinstance(col, Series):\n                level = col.values\n                names.append(col.name)\n            elif isinstance(col, Index):\n                level = col\n                names.append(col.name)\n            elif isinstance(col, (list, np.ndarray, Index)):\n                level = col\n                names.append(None)\n            else:\n                level = frame[col]._values\n                names.append(col)\n                if drop:\n                    to_remove.append(col)\n            arrays.append(level)\n\n        index = MultiIndex.from_arrays(arrays, names=names)\n\n        if verify_integrity and not index.is_unique:\n            duplicates = index.get_duplicates()\n            raise ValueError('Index has duplicate keys: %s' % duplicates)\n\n        for c in to_remove:\n            del frame[c]\n\n        # clear up memory usage\n        index._cleanup()\n\n        frame.index = index\n\n        if not inplace:\n            return frame",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 82,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}