{
  "code": "def store(self, parameter_s=''):\n        \"\"\"Lightweight persistence for python variables.\n\n        Example::\n\n          In [1]: l = ['hello',10,'world']\n          In [2]: %store l\n          In [3]: exit\n\n          (IPython session is closed and started again...)\n\n          ville@badger:~$ ipython\n          In [1]: l\n          NameError: name 'l' is not defined\n          In [2]: %store -r\n          In [3]: l\n          Out[3]: ['hello', 10, 'world']\n\n        Usage:\n\n        * ``%store``          - Show list of all variables and their current\n                                values\n        * ``%store spam``     - Store the *current* value of the variable spam\n                                to disk\n        * ``%store -d spam``  - Remove the variable and its value from storage\n        * ``%store -z``       - Remove all variables from storage\n        * ``%store -r``       - Refresh all variables from store (overwrite\n                                current vals)\n        * ``%store -r spam bar`` - Refresh specified variables from store\n                                   (delete current val)\n        * ``%store foo >a.txt``  - Store value of foo to new file a.txt\n        * ``%store foo >>a.txt`` - Append value of foo to file a.txt\n\n        It should be noted that if you change the value of a variable, you\n        need to %store it again if you want to persist the new value.\n\n        Note also that the variables will need to be pickleable; most basic\n        python types can be safely %store'd.\n\n        Also aliases can be %store'd across sessions.\n        \"\"\"\n\n        opts,argsl = self.parse_options(parameter_s,'drz',mode='string')\n        args = argsl.split(None,1)\n        ip = self.shell\n        db = ip.db\n        # delete\n        if 'd' in opts:\n            try:\n                todel = args[0]\n            except IndexError:\n                raise UsageError('You must provide the variable to forget')\n            else:\n                try:\n                    del db['autorestore/' + todel]\n                except:\n                    raise UsageError(\"Can't delete variable '%s'\" % todel)\n        # reset\n        elif 'z' in opts:\n            for k in db.keys('autorestore/*'):\n                del db[k]\n\n        elif 'r' in opts:\n            if args:\n                for arg in args:\n                    try:\n                        obj = db['autorestore/' + arg]\n                    except KeyError:\n                        print(\"no stored variable %s\" % arg)\n                    else:\n                        ip.user_ns[arg] = obj\n            else:\n                restore_data(ip)\n\n        # run without arguments -> list variables & values\n        elif not args:\n            vars = db.keys('autorestore/*')\n            vars.sort()\n            if vars:\n                size = max(map(len, vars))\n            else:\n                size = 0\n\n            print('Stored variables and their in-db values:')\n            fmt = '%-'+str(size)+'s -> %s'\n            get = db.get\n            for var in vars:\n                justkey = os.path.basename(var)\n                # print 30 first characters from every var\n                print(fmt % (justkey, repr(get(var, '<unavailable>'))[:50]))\n\n        # default action - store the variable\n        else:\n            # %store foo >file.txt or >>file.txt\n            if len(args) > 1 and args[1].startswith('>'):\n                fnam = os.path.expanduser(args[1].lstrip('>').lstrip())\n                if args[1].startswith('>>'):\n                    fil = open(fnam, 'a')\n                else:\n                    fil = open(fnam, 'w')\n                obj = ip.ev(args[0])\n                print(\"Writing '%s' (%s) to file '%s'.\" % (args[0],\n                  obj.__class__.__name__, fnam))\n\n\n                if not isinstance (obj, string_types):\n                    from pprint import pprint\n                    pprint(obj, fil)\n                else:\n                    fil.write(obj)\n                    if not obj.endswith('\\n'):\n                        fil.write('\\n')\n\n                fil.close()\n                return\n\n            # %store foo\n            try:\n                obj = ip.user_ns[args[0]]\n            except KeyError:\n                # it might be an alias\n                name = args[0]\n                try:\n                    cmd = ip.alias_manager.retrieve_alias(name)\n                except ValueError:\n                    raise UsageError(\"Unknown variable '%s'\" % name)\n                \n                staliases = db.get('stored_aliases',{})\n                staliases[name] = cmd\n                db['stored_aliases'] = staliases\n                print(\"Alias stored: %s (%s)\" % (name, cmd))\n                return\n\n            else:\n                modname = getattr(inspect.getmodule(obj), '__name__', '')\n                if modname == '__main__':\n                    print(textwrap.dedent(\"\"\"\\\n                    Warning:%s is %s\n                    Proper storage of interactively declared classes (or instances\n                    of those classes) is not possible! Only instances\n                    of classes in real modules on file system can be %%store'd.\n                    \"\"\" % (args[0], obj) ))\n                    return\n                #pickled = pickle.dumps(obj)\n                db[ 'autorestore/' + args[0] ] = obj\n                print(\"Stored '%s' (%s)\" % (args[0], obj.__class__.__name__))",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 55,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}