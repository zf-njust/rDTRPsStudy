{
  "code": "def crackline(line, reset=0):\n    \"\"\"\n    reset=-1  --- initialize\n    reset=0   --- crack the line\n    reset=1   --- final check if mismatch of blocks occured\n\n    Cracked data is saved in grouplist[0].\n    \"\"\"\n    global beginpattern, groupcounter, groupname, groupcache, grouplist\n    global filepositiontext, currentfilename, neededmodule, expectbegin\n    global skipblocksuntil, skipemptyends, previous_context, gotnextfile\n\n    if ';' in line and not (f2pyenhancementspattern[0].match(line) or\n                            multilinepattern[0].match(line)):\n        for l in line.split(';'):\n            # XXX: non-zero reset values need testing\n            assert reset == 0, repr(reset)\n            crackline(l, reset)\n        return\n    if reset < 0:\n        groupcounter = 0\n        groupname = {groupcounter: ''}\n        groupcache = {groupcounter: {}}\n        grouplist = {groupcounter: []}\n        groupcache[groupcounter]['body'] = []\n        groupcache[groupcounter]['vars'] = {}\n        groupcache[groupcounter]['block'] = ''\n        groupcache[groupcounter]['name'] = ''\n        neededmodule = -1\n        skipblocksuntil = -1\n        return\n    if reset > 0:\n        fl = 0\n        if f77modulename and neededmodule == groupcounter:\n            fl = 2\n        while groupcounter > fl:\n            outmess('crackline: groupcounter=%s groupname=%s\\n' %\n                    (repr(groupcounter), repr(groupname)))\n            outmess(\n                'crackline: Mismatch of blocks encountered. Trying to fix it by assuming \"end\" statement.\\n')\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1\n        if f77modulename and neededmodule == groupcounter:\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end interface\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end module\n            neededmodule = -1\n        return\n    if line == '':\n        return\n    flag = 0\n    for pat in [dimensionpattern, externalpattern, intentpattern, optionalpattern,\n                requiredpattern,\n                parameterpattern, datapattern, publicpattern, privatepattern,\n                intrisicpattern,\n                endifpattern, endpattern,\n                formatpattern,\n                beginpattern, functionpattern, subroutinepattern,\n                implicitpattern, typespattern, commonpattern,\n                callpattern, usepattern, containspattern,\n                entrypattern,\n                f2pyenhancementspattern,\n                multilinepattern\n                ]:\n        m = pat[0].match(line)\n        if m:\n            break\n        flag = flag + 1\n    if not m:\n        re_1 = crackline_re_1\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        if 'externals' in groupcache[groupcounter]:\n            for name in groupcache[groupcounter]['externals']:\n                if name in invbadnames:\n                    name = invbadnames[name]\n                if 'interfaced' in groupcache[groupcounter] and name in groupcache[groupcounter]['interfaced']:\n                    continue\n                m1 = re.match(\n                    r'(?P<before>[^\"]*)\\b%s\\b\\s*@\\(@(?P<args>[^@]*)@\\)@.*\\Z' % name, markouterparen(line), re.I)\n                if m1:\n                    m2 = re_1.match(m1.group('before'))\n                    a = _simplifyargs(m1.group('args'))\n                    if m2:\n                        line = 'callfun %s(%s) result (%s)' % (\n                            name, a, m2.group('result'))\n                    else:\n                        line = 'callfun %s(%s)' % (name, a)\n                    m = callfunpattern[0].match(line)\n                    if not m:\n                        outmess(\n                            'crackline: could not resolve function call for line=%s.\\n' % repr(line))\n                        return\n                    analyzeline(m, 'callfun', line)\n                    return\n        if verbose > 1 or (verbose == 1 and currentfilename.lower().endswith('.pyf')):\n            previous_context = None\n            outmess('crackline:%d: No pattern for line\\n' % (groupcounter))\n        return\n    elif pat[1] == 'end':\n        if 0 <= skipblocksuntil < groupcounter:\n            groupcounter = groupcounter - 1\n            if skipblocksuntil <= groupcounter:\n                return\n        if groupcounter <= 0:\n            raise Exception('crackline: groupcounter(=%s) is nonpositive. '\n                            'Check the blocks.'\n                            % (groupcounter))\n        m1 = beginpattern[0].match((line))\n        if (m1) and (not m1.group('this') == groupname[groupcounter]):\n            raise Exception('crackline: End group %s does not match with '\n                            'previous Begin group %s\\n\\t%s' %\n                            (repr(m1.group('this')), repr(groupname[groupcounter]),\n                             filepositiontext)\n                            )\n        if skipblocksuntil == groupcounter:\n            skipblocksuntil = -1\n        grouplist[groupcounter - 1].append(groupcache[groupcounter])\n        grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n        del grouplist[groupcounter]\n        groupcounter = groupcounter - 1\n        if not skipemptyends:\n            expectbegin = 1\n    elif pat[1] == 'begin':\n        if 0 <= skipblocksuntil <= groupcounter:\n            groupcounter = groupcounter + 1\n            return\n        gotnextfile = 0\n        analyzeline(m, pat[1], line)\n        expectbegin = 0\n    elif pat[1] == 'endif':\n        pass\n    elif pat[1] == 'contains':\n        if ignorecontains:\n            return\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        skipblocksuntil = groupcounter\n    else:\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        analyzeline(m, pat[1], line)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 52,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}