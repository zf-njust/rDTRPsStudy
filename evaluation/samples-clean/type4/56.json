{
  "code": "def reset_selective(self, parameter_s=''):\n        \"\"\"Resets the namespace by removing names defined by the user.\n\n        Input/Output history are left around in case you need them.\n\n        %reset_selective [-f] regex\n\n        No action is taken if regex is not included\n\n        Options\n          -f : force reset without asking for confirmation.\n\n        See Also\n        --------\n        reset : invoked as ``%reset``\n\n        Examples\n        --------\n\n        We first fully reset the namespace so your output looks identical to\n        this example for pedagogical reasons; in practice you do not need a\n        full reset::\n\n          In [1]: %reset -f\n\n        Now, with a clean namespace we can make a few variables and use\n        ``%reset_selective`` to only delete names that match our regexp::\n\n          In [2]: a=1; b=2; c=3; b1m=4; b2m=5; b3m=6; b4m=7; b2s=8\n\n          In [3]: who_ls\n          Out[3]: ['a', 'b', 'b1m', 'b2m', 'b2s', 'b3m', 'b4m', 'c']\n\n          In [4]: %reset_selective -f b[2-3]m\n\n          In [5]: who_ls\n          Out[5]: ['a', 'b', 'b1m', 'b2s', 'b4m', 'c']\n\n          In [6]: %reset_selective -f d\n\n          In [7]: who_ls\n          Out[7]: ['a', 'b', 'b1m', 'b2s', 'b4m', 'c']\n\n          In [8]: %reset_selective -f c\n\n          In [9]: who_ls\n          Out[9]: ['a', 'b', 'b1m', 'b2s', 'b4m']\n\n          In [10]: %reset_selective -f b\n\n          In [11]: who_ls\n          Out[11]: ['a']\n\n        Notes\n        -----\n        Calling this magic from clients that do not implement standard input,\n        such as the ipython notebook interface, will reset the namespace\n        without confirmation.\n        \"\"\"\n\n        opts, regex = self.parse_options(parameter_s,'f')\n\n        if 'f' in opts:\n            ans = True\n        else:\n            try:\n                ans = self.shell.ask_yes_no(\n                \"Once deleted, variables cannot be recovered. Proceed (y/[n])? \",\n                default='n')\n            except StdinNotImplementedError:\n                ans = True\n        if not ans:\n            print('Nothing done.')\n            return\n        user_ns = self.shell.user_ns\n        if not regex:\n            print('No regex pattern specified. Nothing done.')\n            return\n        else:\n            try:\n                m = re.compile(regex)\n            except TypeError:\n                raise TypeError('regex must be a string or compiled pattern')\n            for i in self.who_ls():\n                if m.search(i):\n                    del(user_ns[i])",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 86,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}