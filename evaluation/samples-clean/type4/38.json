{
  "code": "def run(self, tmp=None, task_vars=None):\n        if task_vars is None:\n            task_vars = dict()\n\n        result = super(ActionModule, self).run(tmp, task_vars)\n\n        if self._play_context.check_mode:\n            result['skipped'] = True\n            result['msg'] = \"skipped, this module does not support check_mode.\"\n            return result\n\n        src        = self._task.args.get('src', None)\n        dest       = self._task.args.get('dest', None)\n        delimiter  = self._task.args.get('delimiter', None)\n        remote_src = self._task.args.get('remote_src', 'yes')\n        regexp     = self._task.args.get('regexp', None)\n        follow     = self._task.args.get('follow', False)\n        ignore_hidden = self._task.args.get('ignore_hidden', False)\n\n        if src is None or dest is None:\n            result['failed'] = True\n            result['msg'] = \"src and dest are required\"\n            return result\n\n        remote_user = task_vars.get('ansible_ssh_user') or self._play_context.remote_user\n        if not tmp:\n            tmp = self._make_tmp_path(remote_user)\n            self._cleanup_remote_tmp = True\n\n        if boolean(remote_src):\n            result.update(self._execute_module(tmp=tmp, task_vars=task_vars, delete_remote_tmp=False))\n            self._remove_tmp_path(tmp)\n            return result\n        else:\n            try:\n                src = self._find_needle('files', src)\n            except AnsibleError as e:\n                result['failed'] = True\n                result['msg'] = to_native(e)\n                return result\n\n        if not os.path.isdir(src):\n            result['failed'] = True\n            result['msg'] = u\"Source (%s) is not a directory\" % src\n            return result\n\n        _re = None\n        if regexp is not None:\n            _re = re.compile(regexp)\n\n        # Does all work assembling the file\n        path = self._assemble_from_fragments(src, delimiter, _re, ignore_hidden)\n\n        path_checksum = checksum_s(path)\n        dest = self._remote_expand_user(dest)\n        dest_stat = self._execute_remote_stat(dest, all_vars=task_vars, follow=follow, tmp=tmp)\n\n        diff = {}\n\n        # setup args for running modules\n        new_module_args = self._task.args.copy()\n\n        # clean assemble specific options\n        for opt in ['remote_src', 'regexp', 'delimiter', 'ignore_hidden']:\n            if opt in new_module_args:\n                del new_module_args[opt]\n\n        new_module_args.update(\n            dict(\n                dest=dest,\n                original_basename=os.path.basename(src),\n            )\n        )\n\n        if path_checksum != dest_stat['checksum']:\n\n            if self._play_context.diff:\n                diff = self._get_diff_data(dest, path, task_vars)\n\n            remote_path = self._connection._shell.join_path(tmp, 'src')\n            xfered = self._transfer_file(path, remote_path)\n\n            # fix file permissions when the copy is done as a different user\n            self._fixup_perms2((tmp, remote_path), remote_user)\n\n            new_module_args.update( dict( src=xfered,))\n\n            res = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars, tmp=tmp, delete_remote_tmp=False)\n            if diff:\n                res['diff'] = diff\n            result.update(res)\n        else:\n            result.update(self._execute_module(module_name='file', module_args=new_module_args, task_vars=task_vars, tmp=tmp, delete_remote_tmp=False))\n\n        self._remove_tmp_path(tmp)\n\n        return result",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 66,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}