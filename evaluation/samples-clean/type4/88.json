{
  "code": "def continued_indentation(logical_line, tokens, indent_level, hang_closing,\n                          indent_char, noqa, verbose):\n    r\"\"\"Continuation lines indentation.\n\n    Continuation lines should align wrapped elements either vertically\n    using Python's implicit line joining inside parentheses, brackets\n    and braces, or using a hanging indent.\n\n    When using a hanging indent these considerations should be applied:\n    - there should be no arguments on the first line, and\n    - further indentation should be used to clearly distinguish itself as a\n      continuation line.\n\n    Okay: a = (\\n)\n    E123: a = (\\n    )\n\n    Okay: a = (\\n    42)\n    E121: a = (\\n   42)\n    E122: a = (\\n42)\n    E123: a = (\\n    42\\n    )\n    E124: a = (24,\\n     42\\n)\n    E125: if (\\n    b):\\n    pass\n    E126: a = (\\n        42)\n    E127: a = (24,\\n      42)\n    E128: a = (24,\\n    42)\n    E129: if (a or\\n    b):\\n    pass\n    E131: a = (\\n    42\\n 24)\n    \"\"\"\n    first_row = tokens[0][2][0]\n    nrows = 1 + tokens[-1][2][0] - first_row\n    if noqa or nrows == 1:\n        return\n\n    # indent_next tells us whether the next block is indented; assuming\n    # that it is indented by 4 spaces, then we should not allow 4-space\n    # indents on the final continuation line; in turn, some other\n    # indents are allowed to have an extra 4 spaces.\n    indent_next = logical_line.endswith(':')\n\n    row = depth = 0\n    valid_hangs = (4,) if indent_char != '\\t' else (4, 8)\n    # remember how many brackets were opened on each line\n    parens = [0] * nrows\n    # relative indents of physical lines\n    rel_indent = [0] * nrows\n    # for each depth, collect a list of opening rows\n    open_rows = [[0]]\n    # for each depth, memorize the hanging indentation\n    hangs = [None]\n    # visual indents\n    indent_chances = {}\n    last_indent = tokens[0][2]\n    visual_indent = None\n    last_token_multiline = False\n    # for each depth, memorize the visual indent column\n    indent = [last_indent[1]]\n    if verbose >= 3:\n        print(\">>> \" + tokens[0][4].rstrip())\n\n    for token_type, text, start, end, line in tokens:\n\n        newline = row < start[0] - first_row\n        if newline:\n            row = start[0] - first_row\n            newline = not last_token_multiline and token_type not in NEWLINE\n\n        if newline:\n            # this is the beginning of a continuation line.\n            last_indent = start\n            if verbose >= 3:\n                print(\"... \" + line.rstrip())\n\n            # record the initial indent.\n            rel_indent[row] = expand_indent(line) - indent_level\n\n            # identify closing bracket\n            close_bracket = (token_type == tokenize.OP and text in ']})')\n\n            # is the indent relative to an opening bracket line?\n            for open_row in reversed(open_rows[depth]):\n                hang = rel_indent[row] - rel_indent[open_row]\n                hanging_indent = hang in valid_hangs\n                if hanging_indent:\n                    break\n            if hangs[depth]:\n                hanging_indent = (hang == hangs[depth])\n            # is there any chance of visual indent?\n            visual_indent = (not close_bracket and hang > 0 and\n                             indent_chances.get(start[1]))\n\n            if close_bracket and indent[depth]:\n                # closing bracket for visual indent\n                if start[1] != indent[depth]:\n                    yield (start, \"E124 closing bracket does not match \"\n                           \"visual indentation\")\n            elif close_bracket and not hang:\n                # closing bracket matches indentation of opening bracket's line\n                if hang_closing:\n                    yield start, \"E133 closing bracket is missing indentation\"\n            elif indent[depth] and start[1] < indent[depth]:\n                if visual_indent is not True:\n                    # visual indent is broken\n                    yield (start, \"E128 continuation line \"\n                           \"under-indented for visual indent\")\n            elif hanging_indent or (indent_next and rel_indent[row] == 8):\n                # hanging indent is verified\n                if close_bracket and not hang_closing:\n                    yield (start, \"E123 closing bracket does not match \"\n                           \"indentation of opening bracket's line\")\n                hangs[depth] = hang\n            elif visual_indent is True:\n                # visual indent is verified\n                indent[depth] = start[1]\n            elif visual_indent in (text, str):\n                # ignore token lined up with matching one from a previous line\n                pass\n            else:\n                # indent is broken\n                if hang <= 0:\n                    error = \"E122\", \"missing indentation or outdented\"\n                elif indent[depth]:\n                    error = \"E127\", \"over-indented for visual indent\"\n                elif not close_bracket and hangs[depth]:\n                    error = \"E131\", \"unaligned for hanging indent\"\n                else:\n                    hangs[depth] = hang\n                    if hang > 4:\n                        error = \"E126\", \"over-indented for hanging indent\"\n                    else:\n                        error = \"E121\", \"under-indented for hanging indent\"\n                yield start, \"%s continuation line %s\" % error\n\n        # look for visual indenting\n        if (parens[row] and\n                token_type not in (tokenize.NL, tokenize.COMMENT) and\n                not indent[depth]):\n            indent[depth] = start[1]\n            indent_chances[start[1]] = True\n            if verbose >= 4:\n                print(\"bracket depth %s indent to %s\" % (depth, start[1]))\n        # deal with implicit string concatenation\n        elif (token_type in (tokenize.STRING, tokenize.COMMENT) or\n              text in ('u', 'ur', 'b', 'br')):\n            indent_chances[start[1]] = str\n        # special case for the \"if\" statement because len(\"if (\") == 4\n        elif not indent_chances and not row and not depth and text == 'if':\n            indent_chances[end[1] + 1] = True\n        elif text == ':' and line[end[1]:].isspace():\n            open_rows[depth].append(row)\n\n        # keep track of bracket depth\n        if token_type == tokenize.OP:\n            if text in '([{':\n                depth += 1\n                indent.append(0)\n                hangs.append(None)\n                if len(open_rows) == depth:\n                    open_rows.append([])\n                open_rows[depth].append(row)\n                parens[row] += 1\n                if verbose >= 4:\n                    print(\"bracket depth %s seen, col %s, visual min = %s\" %\n                          (depth, start[1], indent[depth]))\n            elif text in ')]}' and depth > 0:\n                # parent indents should not be more than this one\n                prev_indent = indent.pop() or last_indent[1]\n                hangs.pop()\n                for d in range(depth):\n                    if indent[d] > prev_indent:\n                        indent[d] = 0\n                for ind in list(indent_chances):\n                    if ind >= prev_indent:\n                        del indent_chances[ind]\n                del open_rows[depth + 1:]\n                depth -= 1\n                if depth:\n                    indent_chances[indent[depth]] = True\n                for idx in range(row, -1, -1):\n                    if parens[idx]:\n                        parens[idx] -= 1\n                        break\n            assert len(indent) == depth + 1\n            if start[1] not in indent_chances:\n                # allow lining up tokens\n                indent_chances[start[1]] = text\n\n        last_token_multiline = (start[0] != end[0])\n        if last_token_multiline:\n            rel_indent[end[0] - first_row] = rel_indent[row]\n\n    if indent_next and expand_indent(line) == indent_level + 4:\n        pos = (start[0], indent[0] + 4)\n        if visual_indent:\n            code = \"E129 visually indented line\"\n        else:\n            code = \"E125 continuation line\"\n        yield pos, \"%s with same indent as next logical line\" % code",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 174,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}