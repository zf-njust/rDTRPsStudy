{
  "code": "def _test_cancel(stream_req, stream_resp, draw):\n    \"\"\"\n    Test that we don't raise an exception if someone disconnects.\n    \"\"\"\n    tctx = _tctx()\n    playbook, cff = start_h2_client(tctx)\n    flow = Placeholder(HTTPFlow)\n    server = Placeholder(Server)\n\n    def maybe_stream(flow: HTTPFlow):\n        if stream_req:\n            flow.request.stream = True\n        if stream_resp and flow.response:\n            flow.response.stream = True\n\n    hook_req_headers = http.HttpRequestHeadersHook(flow)\n    hook_req = http.HttpRequestHook(flow)\n    hook_resp_headers = http.HttpResponseHeadersHook(flow)\n    hook_resp = http.HttpResponseHook(flow)\n    hook_error = http.HttpErrorHook(flow)\n    openconn = OpenConnection(server)\n    send_upstream = SendData(server, Placeholder(bytes))\n\n    data_req = DataReceived(\n        tctx.client, cff.build_headers_frame(example_request_headers).serialize()\n    )\n    data_reqbody = DataReceived(\n        tctx.client, cff.build_data_frame(b\"foo\", flags=[\"END_STREAM\"]).serialize()\n    )\n    data_resp = DataReceived(\n        server, cff.build_headers_frame(example_response_headers).serialize()\n    )\n    data_respbody = DataReceived(\n        server, cff.build_data_frame(b\"bar\", flags=[\"END_STREAM\"]).serialize()\n    )\n\n    client_disc = ConnectionClosed(tctx.client)\n    client_rst = DataReceived(tctx.client, cff.build_rst_stream_frame(1).serialize())\n    server_disc = ConnectionClosed(server)\n    server_rst = DataReceived(server, cff.build_rst_stream_frame(1).serialize())\n\n    evts: dict[str, tuple[Any, Any, Any]] = {}\n    # precondition, but-not-after-this\n    evts[\"data_req\"] = data_req, None, client_disc\n    evts[\"data_reqbody\"] = data_reqbody, data_req, client_disc\n    evts[\"reply_hook_req_headers\"] = (\n        reply(to=hook_req_headers, side_effect=maybe_stream),\n        hook_req_headers,\n        None,\n    )\n    evts[\"reply_hook_req\"] = reply(to=hook_req), hook_req, None\n    evts[\"reply_openconn\"] = (\n        reply(None, to=openconn, side_effect=make_h2),\n        openconn,\n        None,\n    )\n    evts[\"data_resp\"] = data_resp, send_upstream, server_disc\n    evts[\"data_respbody\"] = data_respbody, data_resp, server_disc\n    evts[\"reply_hook_resp_headers\"] = (\n        reply(to=hook_resp_headers, side_effect=maybe_stream),\n        hook_resp_headers,\n        None,\n    )\n    evts[\"reply_hook_resp\"] = reply(to=hook_resp), hook_resp, None\n    evts[\"reply_hook_error\"] = reply(to=hook_error), hook_error, None\n\n    evts[\"err_client_disc\"] = client_disc, None, None\n    evts[\"err_client_rst\"] = client_rst, None, client_disc\n    evts[\"err_server_disc\"] = server_disc, send_upstream, None\n    evts[\"err_server_rst\"] = server_rst, send_upstream, server_disc\n\n    def eq_maybe(a, b):\n        # _eq helpfully raises a TypeError when placeholder types don't match\n        # that is useful in (test) development, but may happen legitimately when fuzzing here.\n        try:\n            return _eq(a, b)\n        except TypeError:\n            return False\n\n    while evts:\n        candidates = []\n        for name, (evt, precon, negprecon) in evts.items():\n            precondition_ok = precon is None or any(\n                eq_maybe(x, precon) for x in playbook.actual\n            )\n            neg_precondition_ok = negprecon is None or not any(\n                eq_maybe(x, negprecon) for x in playbook.actual\n            )\n            if precondition_ok and neg_precondition_ok:\n                # crude hack to increase fuzzing efficiency: make it more likely that we progress.\n                for i in range(1 if name.startswith(\"err_\") else 3):\n                    candidates.append((name, evt))\n        if not candidates:\n            break\n\n        name, evt = draw(candidates)\n        del evts[name]\n        try:\n            assert playbook >> evt\n        except AssertionError:\n            if any(isinstance(x, _TracebackInPlaybook) for x in playbook.actual):\n                raise\n            else:\n                # add commands that the server issued.\n                playbook.expected.extend(playbook.actual[len(playbook.expected) :])",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 97,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}