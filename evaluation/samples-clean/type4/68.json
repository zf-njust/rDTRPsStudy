{
  "code": "def get_socre_A(gt_dir, pred_dict):\n    allInputs = 1\n\n    def input_reading_mod(pred_dict):\n        \"\"\"This helper reads input from txt files\"\"\"\n        det = []\n        n = len(pred_dict)\n        for i in range(n):\n            points = pred_dict[i]['points']\n            text = pred_dict[i]['texts']\n            point = \",\".join(map(str, points.reshape(-1, )))\n            det.append([point, text])\n        return det\n\n    def gt_reading_mod(gt_dict):\n        \"\"\"This helper reads groundtruths from mat files\"\"\"\n        gt = []\n        n = len(gt_dict)\n        for i in range(n):\n            points = gt_dict[i]['points'].tolist()\n            h = len(points)\n            text = gt_dict[i]['text']\n            xx = [\n                np.array(\n                    ['x:'], dtype='<U2'), 0, np.array(\n                        ['y:'], dtype='<U2'), 0, np.array(\n                            ['#'], dtype='<U1'), np.array(\n                                ['#'], dtype='<U1')\n            ]\n            t_x, t_y = [], []\n            for j in range(h):\n                t_x.append(points[j][0])\n                t_y.append(points[j][1])\n            xx[1] = np.array([t_x], dtype='int16')\n            xx[3] = np.array([t_y], dtype='int16')\n            if text != \"\":\n                xx[4] = np.array([text], dtype='U{}'.format(len(text)))\n                xx[5] = np.array(['c'], dtype='<U1')\n            gt.append(xx)\n        return gt\n\n    def detection_filtering(detections, groundtruths, threshold=0.5):\n        for gt_id, gt in enumerate(groundtruths):\n            if (gt[5] == '#') and (gt[1].shape[1] > 1):\n                gt_x = list(map(int, np.squeeze(gt[1])))\n                gt_y = list(map(int, np.squeeze(gt[3])))\n                for det_id, detection in enumerate(detections):\n                    detection_orig = detection\n                    detection = [float(x) for x in detection[0].split(',')]\n                    detection = list(map(int, detection))\n                    det_x = detection[0::2]\n                    det_y = detection[1::2]\n                    det_gt_iou = iod(det_x, det_y, gt_x, gt_y)\n                    if det_gt_iou > threshold:\n                        detections[det_id] = []\n\n                detections[:] = [item for item in detections if item != []]\n        return detections\n\n    def sigma_calculation(det_x, det_y, gt_x, gt_y):\n        \"\"\"\n        sigma = inter_area / gt_area\n        \"\"\"\n        return np.round((area_of_intersection(det_x, det_y, gt_x, gt_y) /\n                         area(gt_x, gt_y)), 2)\n\n    def tau_calculation(det_x, det_y, gt_x, gt_y):\n        if area(det_x, det_y) == 0.0:\n            return 0\n        return np.round((area_of_intersection(det_x, det_y, gt_x, gt_y) /\n                         area(det_x, det_y)), 2)\n\n    ##############################Initialization###################################\n    # global_sigma = []\n    # global_tau = []\n    # global_pred_str = []\n    # global_gt_str = []\n    ###############################################################################\n\n    for input_id in range(allInputs):\n        if (input_id != '.DS_Store') and (input_id != 'Pascal_result.txt') and (\n                input_id != 'Pascal_result_curved.txt') and (input_id != 'Pascal_result_non_curved.txt') and (\n                input_id != 'Deteval_result.txt') and (input_id != 'Deteval_result_curved.txt') \\\n                and (input_id != 'Deteval_result_non_curved.txt'):\n            detections = input_reading_mod(pred_dict)\n            groundtruths = gt_reading_mod(gt_dir)\n            detections = detection_filtering(\n                detections,\n                groundtruths)  # filters detections overlapping with DC area\n            dc_id = []\n            for i in range(len(groundtruths)):\n                if groundtruths[i][5] == '#':\n                    dc_id.append(i)\n            cnt = 0\n            for a in dc_id:\n                num = a - cnt\n                del groundtruths[num]\n                cnt += 1\n\n            local_sigma_table = np.zeros((len(groundtruths), len(detections)))\n            local_tau_table = np.zeros((len(groundtruths), len(detections)))\n            local_pred_str = {}\n            local_gt_str = {}\n\n            for gt_id, gt in enumerate(groundtruths):\n                if len(detections) > 0:\n                    for det_id, detection in enumerate(detections):\n                        detection_orig = detection\n                        detection = [float(x) for x in detection[0].split(',')]\n                        detection = list(map(int, detection))\n                        pred_seq_str = detection_orig[1].strip()\n                        det_x = detection[0::2]\n                        det_y = detection[1::2]\n                        gt_x = list(map(int, np.squeeze(gt[1])))\n                        gt_y = list(map(int, np.squeeze(gt[3])))\n                        gt_seq_str = str(gt[4].tolist()[0])\n\n                        local_sigma_table[gt_id, det_id] = sigma_calculation(\n                            det_x, det_y, gt_x, gt_y)\n                        local_tau_table[gt_id, det_id] = tau_calculation(\n                            det_x, det_y, gt_x, gt_y)\n                        local_pred_str[det_id] = pred_seq_str\n                        local_gt_str[gt_id] = gt_seq_str\n\n            global_sigma = local_sigma_table\n            global_tau = local_tau_table\n            global_pred_str = local_pred_str\n            global_gt_str = local_gt_str\n\n    single_data = {}\n    single_data['sigma'] = global_sigma\n    single_data['global_tau'] = global_tau\n    single_data['global_pred_str'] = global_pred_str\n    single_data['global_gt_str'] = global_gt_str\n    return single_data",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 97,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}