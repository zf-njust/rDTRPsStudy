{
  "code": "def __new__(meta_cls, class_name, bases, class_dict):\n        '''\n\n        '''\n        names_with_refs = set()\n        container_names = set()\n\n        # Now handle all the Override\n        overridden_defaults = {}\n        for name, prop in class_dict.items():\n            if not isinstance(prop, Override):\n                continue\n            if prop.default_overridden:\n                overridden_defaults[name] = prop.default\n\n        for name, default in overridden_defaults.items():\n            del class_dict[name]\n\n        generators = dict()\n        for name, generator in class_dict.items():\n            if isinstance(generator, PropertyDescriptorFactory):\n                generators[name] = generator\n            elif isinstance(generator, type) and issubclass(generator, PropertyDescriptorFactory):\n                # Support the user adding a property without using parens,\n                # i.e. using just the Property subclass instead of an\n                # instance of the subclass\n                generators[name] = generator.autocreate()\n\n        dataspecs = {}\n        new_class_attrs = {}\n\n        for name, generator in generators.items():\n            prop_descriptors = generator.make_descriptors(name)\n            replaced_self = False\n            for prop_descriptor in prop_descriptors:\n                if prop_descriptor.name in generators:\n                    if generators[prop_descriptor.name] is generator:\n                        # a generator can replace itself, this is the\n                        # standard case like `foo = Int()`\n                        replaced_self = True\n                        prop_descriptor.add_prop_descriptor_to_class(class_name, new_class_attrs, names_with_refs, container_names, dataspecs)\n                    else:\n                        # if a generator tries to overwrite another\n                        # generator that's been explicitly provided,\n                        # use the prop that was manually provided\n                        # and ignore this one.\n                        pass\n                else:\n                    prop_descriptor.add_prop_descriptor_to_class(class_name, new_class_attrs, names_with_refs, container_names, dataspecs)\n            # if we won't overwrite ourselves anyway, delete the generator\n            if not replaced_self:\n                del class_dict[name]\n\n        class_dict.update(new_class_attrs)\n\n        class_dict[\"__properties__\"] = set(new_class_attrs)\n        class_dict[\"__properties_with_refs__\"] = names_with_refs\n        class_dict[\"__container_props__\"] = container_names\n        if len(overridden_defaults) > 0:\n            class_dict[\"__overridden_defaults__\"] = overridden_defaults\n        if dataspecs:\n            class_dict[\"__dataspecs__\"] = dataspecs\n\n        if \"__example__\" in class_dict:\n            path = class_dict[\"__example__\"]\n\n            # running python with -OO will discard docstrings -> __doc__ is None\n            if \"__doc__\" in class_dict and class_dict[\"__doc__\"] is not None:\n                class_dict[\"__doc__\"] += _EXAMPLE_TEMPLATE % dict(path=path)\n\n        return super(MetaHasProps, meta_cls).__new__(meta_cls, class_name, bases, class_dict)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 17,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}