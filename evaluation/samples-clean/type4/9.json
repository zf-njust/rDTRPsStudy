{
  "code": "def captured_sequence(self, end_time=None):\n    \"\"\"Returns a copy of the current captured sequence.\n\n    If called before the thread terminates, `end_time` is required and any open\n    notes will have their end time set to it, any notes starting after it will\n    be removed, and any notes ending after it will be truncated. `total_time`\n    will also be set to `end_time`.\n\n    Args:\n      end_time: The float time in seconds to close any open notes and after\n          which to close or truncate notes, if the thread is still alive.\n          Otherwise, must be None.\n\n    Returns:\n      A copy of the current captured NoteSequence proto with open notes closed\n      at and later notes removed or truncated to `end_time`.\n\n    Raises:\n      MidiHubError: When the thread is alive and `end_time` is None or the\n         thread is terminated and `end_time` is not None.\n    \"\"\"\n    # Make a copy of the sequence currently being captured.\n    current_captured_sequence = music_pb2.NoteSequence()\n    with self._lock:\n      current_captured_sequence.CopyFrom(self._captured_sequence)\n\n    if self.is_alive():\n      if end_time is None:\n        raise MidiHubError(\n            '`end_time` must be provided when capture thread is still running.')\n      for i, note in enumerate(current_captured_sequence.notes):\n        if note.start_time >= end_time:\n          del current_captured_sequence.notes[i:]\n          break\n        if not note.end_time or note.end_time > end_time:\n          note.end_time = end_time\n      current_captured_sequence.total_time = end_time\n    elif end_time is not None:\n      raise MidiHubError(\n          '`end_time` must not be provided when capture is complete.')\n\n    return current_captured_sequence",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 33,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}