{
  "code": "def _strip_marker_elem(elem_name, elements):\n    \"\"\"Remove the supplied element from the marker.\n\n    This is not a comprehensive implementation, but relies on an\n    important characteristic of metadata generation: The element's\n    operand is always associated with an \"and\" operator. This means that\n    we can simply remove the operand and the \"and\" operator associated\n    with it.\n    \"\"\"\n\n    extra_indexes = []\n    preceding_operators = [\"and\"] if elem_name == \"extra\" else [\"and\", \"or\"]\n    for i, element in enumerate(elements):\n        if isinstance(element, list):\n            cancelled = _strip_marker_elem(elem_name, element)\n            if cancelled:\n                extra_indexes.append(i)\n        elif isinstance(element, tuple) and element[0].value == elem_name:\n            extra_indexes.append(i)\n    for i in reversed(extra_indexes):\n        del elements[i]\n        if i > 0 and elements[i - 1] in preceding_operators:\n            # Remove the \"and\" before it.\n            del elements[i - 1]\n        elif elements:\n            # This shouldn't ever happen, but is included for completeness.\n            # If there is not an \"and\" before this element, try to remove the\n            # operator after it.\n            del elements[0]\n    return not elements",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 24,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}