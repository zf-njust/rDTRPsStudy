{
  "code": "def reset(self, parameter_s=''):\n        \"\"\"Resets the namespace by removing all names defined by the user, if\n        called without arguments, or by removing some types of objects, such\n        as everything currently in IPython's In[] and Out[] containers (see\n        the parameters for details).\n\n        Parameters\n        ----------\n        -f : force reset without asking for confirmation.\n\n        -s : 'Soft' reset: Only clears your namespace, leaving history intact.\n            References to objects may be kept. By default (without this option),\n            we do a 'hard' reset, giving you a new session and removing all\n            references to objects from the current session.\n\n        in : reset input history\n\n        out : reset output history\n\n        dhist : reset directory history\n\n        array : reset only variables that are NumPy arrays\n\n        See Also\n        --------\n        reset_selective : invoked as ``%reset_selective``\n\n        Examples\n        --------\n        ::\n\n          In [6]: a = 1\n\n          In [7]: a\n          Out[7]: 1\n\n          In [8]: 'a' in _ip.user_ns\n          Out[8]: True\n\n          In [9]: %reset -f\n\n          In [1]: 'a' in _ip.user_ns\n          Out[1]: False\n\n          In [2]: %reset -f in\n          Flushing input history\n\n          In [3]: %reset -f dhist in\n          Flushing directory history\n          Flushing input history\n\n        Notes\n        -----\n        Calling this magic from clients that do not implement standard input,\n        such as the ipython notebook interface, will reset the namespace\n        without confirmation.\n        \"\"\"\n        opts, args = self.parse_options(parameter_s,'sf', mode='list')\n        if 'f' in opts:\n            ans = True\n        else:\n            try:\n                ans = self.shell.ask_yes_no(\n                \"Once deleted, variables cannot be recovered. Proceed (y/[n])?\",\n                default='n')\n            except StdinNotImplementedError:\n                ans = True\n        if not ans:\n            print('Nothing done.')\n            return\n\n        if 's' in opts:                     # Soft reset\n            user_ns = self.shell.user_ns\n            for i in self.who_ls():\n                del(user_ns[i])\n        elif len(args) == 0:                # Hard reset\n            self.shell.reset(new_session = False)\n\n        # reset in/out/dhist/array: previously extensinions/clearcmd.py\n        ip = self.shell\n        user_ns = self.shell.user_ns  # local lookup, heavily used\n\n        for target in args:\n            target = target.lower() # make matches case insensitive\n            if target == 'out':\n                print(\"Flushing output cache (%d entries)\" % len(user_ns['_oh']))\n                self.shell.displayhook.flush()\n\n            elif target == 'in':\n                print(\"Flushing input history\")\n                pc = self.shell.displayhook.prompt_count + 1\n                for n in range(1, pc):\n                    key = '_i'+repr(n)\n                    user_ns.pop(key,None)\n                user_ns.update(dict(_i=u'',_ii=u'',_iii=u''))\n                hm = ip.history_manager\n                # don't delete these, as %save and %macro depending on the\n                # length of these lists to be preserved\n                hm.input_hist_parsed[:] = [''] * pc\n                hm.input_hist_raw[:] = [''] * pc\n                # hm has internal machinery for _i,_ii,_iii, clear it out\n                hm._i = hm._ii = hm._iii = hm._i00 =  u''\n\n            elif target == 'array':\n                # Support cleaning up numpy arrays\n                try:\n                    from numpy import ndarray\n                    # This must be done with items and not iteritems because\n                    # we're going to modify the dict in-place.\n                    for x,val in list(user_ns.items()):\n                        if isinstance(val,ndarray):\n                            del user_ns[x]\n                except ImportError:\n                    print(\"reset array only works if Numpy is available.\")\n\n            elif target == 'dhist':\n                print(\"Flushing directory history\")\n                del user_ns['_dh'][:]\n\n            else:\n                print(\"Don't know how to reset \", end=' ')\n                print(target + \", please run `%reset?` for details\")\n\n        gc.collect()",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 75,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}