{
  "code": "def merge(self, __loc_data__=None, __conflict_solve=None, **kw):\n        \"\"\"Merge two Structs with customizable conflict resolution.\n\n        This is similar to :meth:`update`, but much more flexible. First, a\n        dict is made from data+key=value pairs. When merging this dict with\n        the Struct S, the optional dictionary 'conflict' is used to decide\n        what to do.\n\n        If conflict is not given, the default behavior is to preserve any keys\n        with their current value (the opposite of the :meth:`update` method's\n        behavior).\n\n        Parameters\n        ----------\n        __loc_data : dict, Struct\n            The data to merge into self\n        __conflict_solve : dict\n            The conflict policy dict.  The keys are binary functions used to\n            resolve the conflict and the values are lists of strings naming\n            the keys the conflict resolution function applies to.  Instead of\n            a list of strings a space separated string can be used, like\n            'a b c'.\n        kw : dict\n            Additional key, value pairs to merge in\n\n        Notes\n        -----\n\n        The `__conflict_solve` dict is a dictionary of binary functions which will be used to\n        solve key conflicts.  Here is an example::\n\n            __conflict_solve = dict(\n                func1=['a','b','c'],\n                func2=['d','e']\n            )\n\n        In this case, the function :func:`func1` will be used to resolve\n        keys 'a', 'b' and 'c' and the function :func:`func2` will be used for\n        keys 'd' and 'e'.  This could also be written as::\n\n            __conflict_solve = dict(func1='a b c',func2='d e')\n\n        These functions will be called for each key they apply to with the\n        form::\n\n            func1(self['a'], other['a'])\n\n        The return value is used as the final merged value.\n\n        As a convenience, merge() provides five (the most commonly needed)\n        pre-defined policies: preserve, update, add, add_flip and add_s. The\n        easiest explanation is their implementation::\n\n            preserve = lambda old,new: old\n            update   = lambda old,new: new\n            add      = lambda old,new: old + new\n            add_flip = lambda old,new: new + old  # note change of order!\n            add_s    = lambda old,new: old + ' ' + new  # only for str!\n\n        You can use those four words (as strings) as keys instead\n        of defining them as functions, and the merge method will substitute\n        the appropriate functions for you.\n\n        For more complicated conflict resolution policies, you still need to\n        construct your own functions.\n\n        Examples\n        --------\n\n        This show the default policy:\n\n        >>> s = Struct(a=10,b=30)\n        >>> s2 = Struct(a=20,c=40)\n        >>> s.merge(s2)\n        >>> sorted(s.items())\n        [('a', 10), ('b', 30), ('c', 40)]\n\n        Now, show how to specify a conflict dict:\n\n        >>> s = Struct(a=10,b=30)\n        >>> s2 = Struct(a=20,b=40)\n        >>> conflict = {'update':'a','add':'b'}\n        >>> s.merge(s2,conflict)\n        >>> sorted(s.items())\n        [('a', 20), ('b', 70)]\n        \"\"\"\n\n        data_dict = dict(__loc_data__,**kw)\n\n        # policies for conflict resolution: two argument functions which return\n        # the value that will go in the new struct\n        preserve = lambda old,new: old\n        update   = lambda old,new: new\n        add      = lambda old,new: old + new\n        add_flip = lambda old,new: new + old  # note change of order!\n        add_s    = lambda old,new: old + ' ' + new\n\n        # default policy is to keep current keys when there's a conflict\n        conflict_solve = dict.fromkeys(self, preserve)\n\n        # the conflict_solve dictionary is given by the user 'inverted': we\n        # need a name-function mapping, it comes as a function -> names\n        # dict. Make a local copy (b/c we'll make changes), replace user\n        # strings for the three builtin policies and invert it.\n        if __conflict_solve:\n            inv_conflict_solve_user = __conflict_solve.copy()\n            for name, func in [('preserve',preserve), ('update',update),\n                               ('add',add), ('add_flip',add_flip),\n                               ('add_s',add_s)]:\n                if name in inv_conflict_solve_user.keys():\n                    inv_conflict_solve_user[func] = inv_conflict_solve_user[name]\n                    del inv_conflict_solve_user[name]\n            conflict_solve.update(self.__dict_invert(inv_conflict_solve_user))\n        for key in data_dict:\n            if key not in self:\n                self[key] = data_dict[key]\n            else:\n                self[key] = conflict_solve[key](self[key],data_dict[key])",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 112,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}