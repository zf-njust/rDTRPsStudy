{
  "code": "def DownloadRewriter(response, request_headers):\n  \"\"\"Intercepts blob download key and rewrites response with large download.\n\n  Checks for the X-AppEngine-BlobKey header in the response.  If found, it will\n  discard the body of the request and replace it with the blob content\n  indicated.\n\n  If a valid blob is not found, it will send a 404 to the client.\n\n  If the application itself provides a content-type header, it will override\n  the content-type stored in the action blob.\n\n  If Content-Range header is provided, blob will be partially served.  The\n  application can set blobstore.BLOB_RANGE_HEADER if the size of the blob is\n  not known.  If Range is present, and not blobstore.BLOB_RANGE_HEADER, will\n  use Range instead.\n\n  Args:\n    response: Response object to be rewritten.\n    request_headers: Original request headers.  Looks for 'Range' header to copy\n      to response.\n  \"\"\"\n  blob_key = response.headers.getheader(blobstore.BLOB_KEY_HEADER)\n  if blob_key:\n    del response.headers[blobstore.BLOB_KEY_HEADER]\n\n\n    try:\n      blob_info = datastore.Get(\n          datastore.Key.from_path(blobstore.BLOB_INFO_KIND,\n                                  blob_key,\n                                  namespace=''))\n\n      content_range_header = response.headers.getheader('Content-Range')\n      blob_size = blob_info['size']\n      range_header = response.headers.getheader(blobstore.BLOB_RANGE_HEADER)\n      if range_header is not None:\n        del response.headers[blobstore.BLOB_RANGE_HEADER]\n      else:\n        range_header = request_headers.getheader('Range')\n\n      def not_satisfiable():\n        \"\"\"Short circuit response and return 416 error.\"\"\"\n        response.status_code = 416\n        response.status_message = 'Requested Range Not Satisfiable'\n        response.body = cStringIO.StringIO('')\n        response.headers['Content-Length'] = '0'\n        del response.headers['Content-Type']\n        del response.headers['Content-Range']\n\n      if range_header:\n        start, end = ParseRangeHeader(range_header)\n        if start is not None:\n          if end is None:\n            if start >= 0:\n              content_range_start = start\n            else:\n              content_range_start = blob_size + start\n            content_range = MakeContentRange(\n                content_range_start, blob_size, blob_size)\n            content_range_header = str(content_range)\n          else:\n            content_range = MakeContentRange(start, min(end, blob_size),\n                                             blob_size)\n            content_range_header = str(content_range)\n          response.headers['Content-Range'] = content_range_header\n        else:\n          not_satisfiable()\n          return\n\n      content_range_header = response.headers.getheader('Content-Range')\n      content_length = blob_size\n      start = 0\n      end = content_length\n      if content_range_header is not None:\n        content_range = ParseContentRange(content_range_header)\n        if content_range:\n          start = content_range.start\n          stop = GetContentRangeStop(content_range)\n          content_length = min(stop, blob_size) - start\n          stop = start + content_length\n          content_range = MakeContentRange(start, stop, blob_size)\n          response.headers['Content-Range'] = str(content_range)\n        else:\n          not_satisfiable()\n          return\n\n      blob_stream = GetBlobStorage().OpenBlob(blob_key)\n      blob_stream.seek(start)\n      response.body = cStringIO.StringIO(blob_stream.read(content_length))\n      response.headers['Content-Length'] = str(content_length)\n\n      content_type = response.headers.getheader('Content-Type')\n      if not content_type or content_type == AUTO_MIME_TYPE:\n        response.headers['Content-Type'] = blob_info['content_type']\n      response.large_response = True\n\n\n\n    except datastore_errors.EntityNotFoundError:\n\n      response.status_code = 500\n      response.status_message = 'Internal Error'\n      response.body = cStringIO.StringIO()\n\n      if response.headers.getheader('status'):\n        del response.headers['status']\n      if response.headers.getheader('location'):\n        del response.headers['location']\n      if response.headers.getheader('content-type'):\n        del response.headers['content-type']\n\n      logging.error('Could not find blob with key %s.', blob_key)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 38,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}