{
  "code": "def _handle_message(self, msg):\n    \"\"\"Handles a single incoming MIDI message.\n\n    -If the message is being used as a signal, notifies threads waiting on the\n     appropriate condition variable.\n    -Adds the message to any capture queues.\n    -Passes the message through to the output port, if appropriate.\n\n    Args:\n      msg: The mido.Message MIDI message to handle.\n    \"\"\"\n    # Notify any threads waiting for this message.\n    msg_str = str(msg)\n    for regex in list(self._signals):\n      if regex.match(msg_str) is not None:\n        self._signals[regex].notify_all()\n        del self._signals[regex]\n\n    # Call any callbacks waiting for this message.\n    for regex in list(self._callbacks):\n      if regex.match(msg_str) is not None:\n        for fn in self._callbacks[regex]:\n          threading.Thread(target=fn, args=(msg,)).start()\n\n        del self._callbacks[regex]\n\n    # Remove any captors that are no longer alive.\n    self._captors[:] = [t for t in self._captors if t.is_alive()]\n    # Add a different copy of the message to the receive queue of each live\n    # capture thread.\n    for t in self._captors:\n      t.receive(msg.copy())\n\n    # Update control values if this is a control change message.\n    if msg.type == 'control_change':\n      if self._control_values.get(msg.control, None) != msg.value:\n        tf.logging.debug('Control change %d: %d', msg.control, msg.value)\n      self._control_values[msg.control] = msg.value\n\n    # Pass the message through to the output port, if appropriate.\n    if not self._passthrough:\n      pass\n    elif self._texture_type == TextureType.POLYPHONIC:\n      if msg.type == 'note_on' and msg.velocity > 0:\n        self._open_notes.add(msg.note)\n      elif (msg.type == 'note_off' or\n            (msg.type == 'note_on' and msg.velocity == 0)):\n        self._open_notes.discard(msg.note)\n      self._outport.send(msg)\n    elif self._texture_type == TextureType.MONOPHONIC:\n      assert len(self._open_notes) <= 1\n      if msg.type not in ['note_on', 'note_off']:\n        self._outport.send(msg)\n      elif ((msg.type == 'note_off' or\n             msg.type == 'note_on' and msg.velocity == 0) and\n            msg.note in self._open_notes):\n        self._outport.send(msg)\n        self._open_notes.remove(msg.note)\n      elif msg.type == 'note_on' and msg.velocity > 0:\n        if self._open_notes:\n          self._outport.send(\n              mido.Message('note_off', note=self._open_notes.pop()))\n        self._outport.send(msg)\n        self._open_notes.add(msg.note)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 25,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}