{
  "code": "def _pre_render(self):\n        # split markup, words, and lines\n        # result: list of word with position and width/height\n        # during the first pass, we don't care about h/valign\n        self._cached_lines = lines = []\n        self._refs = {}\n        self._anchors = {}\n        clipped = False\n        w = h = 0\n        uw, uh = self.text_size\n        spush = self._push_style\n        spop = self._pop_style\n        options = self.options\n        options['_ref'] = None\n        options['_anchor'] = None\n        options['script'] = 'normal'\n        shorten = options['shorten']\n        # if shorten, then don't split lines to fit uw, because it will be\n        # flattened later when shortening and broken up lines if broken\n        # mid-word will have space mid-word when lines are joined\n        uw_temp = None if shorten else uw\n        xpad = options['padding_x']\n        uhh = (None if uh is not None and options['valign'] != 'top' or\n               options['shorten'] else uh)\n        options['strip'] = options['strip'] or options['halign'] == 'justify'\n        find_base_dir = Label.find_base_direction\n        base_dir = options['base_direction']\n        self._resolved_base_dir = None\n        for item in self.markup:\n            if item == '[b]':\n                spush('bold')\n                options['bold'] = True\n                self.resolve_font_name()\n            elif item == '[/b]':\n                spop('bold')\n                self.resolve_font_name()\n            elif item == '[i]':\n                spush('italic')\n                options['italic'] = True\n                self.resolve_font_name()\n            elif item == '[/i]':\n                spop('italic')\n                self.resolve_font_name()\n            elif item == '[u]':\n                spush('underline')\n                options['underline'] = True\n                self.resolve_font_name()\n            elif item == '[/u]':\n                spop('underline')\n                self.resolve_font_name()\n            elif item == '[s]':\n                spush('strikethrough')\n                options['strikethrough'] = True\n                self.resolve_font_name()\n            elif item == '[/s]':\n                spop('strikethrough')\n                self.resolve_font_name()\n            elif item[:6] == '[size=':\n                item = item[6:-1]\n                try:\n                    if item[-2:] in ('px', 'pt', 'in', 'cm', 'mm', 'dp', 'sp'):\n                        size = dpi2px(item[:-2], item[-2:])\n                    else:\n                        size = int(item)\n                except ValueError:\n                    raise\n                    size = options['font_size']\n                spush('font_size')\n                options['font_size'] = size\n            elif item == '[/size]':\n                spop('font_size')\n            elif item[:7] == '[color=':\n                color = parse_color(item[7:-1])\n                spush('color')\n                options['color'] = color\n            elif item == '[/color]':\n                spop('color')\n            elif item[:6] == '[font=':\n                fontname = item[6:-1]\n                spush('font_name')\n                options['font_name'] = fontname\n                self.resolve_font_name()\n            elif item == '[/font]':\n                spop('font_name')\n                self.resolve_font_name()\n            elif item[:13] == '[font_family=':\n                spush('font_family')\n                options['font_family'] = item[13:-1]\n            elif item == '[/font_family]':\n                spop('font_family')\n            elif item[:14] == '[font_context=':\n                fctx = item[14:-1]\n                if not fctx or fctx.lower() == 'none':\n                    fctx = None\n                spush('font_context')\n                options['font_context'] = fctx\n            elif item == '[/font_context]':\n                spop('font_context')\n            elif item[:15] == '[font_features=':\n                spush('font_features')\n                options['font_features'] = item[15:-1]\n            elif item == '[/font_features]':\n                spop('font_features')\n            elif item[:15] == '[text_language=':\n                lang = item[15:-1]\n                if not lang or lang.lower() == 'none':\n                    lang = None\n                spush('text_language')\n                options['text_language'] = lang\n            elif item == '[/text_language]':\n                spop('text_language')\n            elif item[:5] == '[sub]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'subscript'\n            elif item == '[/sub]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[sup]':\n                spush('font_size')\n                spush('script')\n                options['font_size'] = options['font_size'] * .5\n                options['script'] = 'superscript'\n            elif item == '[/sup]':\n                spop('font_size')\n                spop('script')\n            elif item[:5] == '[ref=':\n                ref = item[5:-1]\n                spush('_ref')\n                options['_ref'] = ref\n            elif item == '[/ref]':\n                spop('_ref')\n            elif not clipped and item[:8] == '[anchor=':\n                options['_anchor'] = item[8:-1]\n            elif not clipped:\n                item = item.replace('&bl;', '[').replace(\n                    '&br;', ']').replace('&amp;', '&')\n                if not base_dir:\n                    base_dir = self._resolved_base_dir = find_base_dir(item)\n                opts = copy(options)\n                extents = self.get_cached_extents()\n                opts['space_width'] = extents(' ')[0]\n                w, h, clipped = layout_text(\n                    item, lines, (w, h), (uw_temp, uhh),\n                    opts, extents,\n                    append_down=True,\n                    complete=False\n                )\n\n        if len(lines):  # remove any trailing spaces from the last line\n            old_opts = self.options\n            self.options = copy(opts)\n            w, h, clipped = layout_text(\n                '', lines, (w, h), (uw_temp, uhh),\n                self.options, self.get_cached_extents(),\n                append_down=True,\n                complete=True\n            )\n            self.options = old_opts\n\n        self.is_shortened = False\n        if shorten:\n            options['_ref'] = None  # no refs for you!\n            options['_anchor'] = None\n            w, h, lines = self.shorten_post(lines, w, h)\n            self._cached_lines = lines\n        # when valign is not top, for markup we layout everything (text_size[1]\n        # is temporarily set to None) and after layout cut to size if too tall\n        elif uh != uhh and h > uh and len(lines) > 1:\n            if options['valign'] == 'bottom':\n                i = 0\n                while i < len(lines) - 1 and h > uh:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n            else:  # middle\n                i = 0\n                top = int(h / 2. + uh / 2.)  # remove extra top portion\n                while i < len(lines) - 1 and h > top:\n                    h -= lines[i].h\n                    i += 1\n                del lines[:i]\n                i = len(lines) - 1  # remove remaining bottom portion\n                while i and h > uh:\n                    h -= lines[i].h\n                    i -= 1\n                del lines[i + 1:]\n\n        # now justify the text\n        if options['halign'] == 'justify' and uw is not None:\n            # XXX: update refs to justified pos\n            # when justify, each line should've been stripped already\n            split = partial(re.split, re.compile('( +)'))\n            uww = uw - 2 * xpad\n            chr = type(self.text)\n            space = chr(' ')\n            empty = chr('')\n\n            for i in range(len(lines)):\n                line = lines[i]\n                words = line.words\n                # if there's nothing to justify, we're done\n                if (not line.w or int(uww - line.w) <= 0 or not len(words) or\n                        line.is_last_line):\n                    continue\n\n                done = False\n                parts = [None, ] * len(words)  # contains words split by space\n                idxs = [None, ] * len(words)  # indices of the space in parts\n                # break each word into spaces and add spaces until it's full\n                # do first round of split in case we don't need to split all\n                for w in range(len(words)):\n                    word = words[w]\n                    sw = word.options['space_width']\n                    p = parts[w] = split(word.text)\n                    idxs[w] = [v for v in range(len(p)) if\n                               p[v].startswith(' ')]\n                    # now we have the indices of the spaces in split list\n                    for k in idxs[w]:\n                        # try to add single space at each space\n                        if line.w + sw > uww:\n                            done = True\n                            break\n                        line.w += sw\n                        word.lw += sw\n                        p[k] += space\n                    if done:\n                        break\n\n                # there's not a single space in the line?\n                if not any(idxs):\n                    continue\n\n                # now keep adding spaces to already split words until done\n                while not done:\n                    for w in range(len(words)):\n                        if not idxs[w]:\n                            continue\n                        word = words[w]\n                        sw = word.options['space_width']\n                        p = parts[w]\n                        for k in idxs[w]:\n                            # try to add single space at each space\n                            if line.w + sw > uww:\n                                done = True\n                                break\n                            line.w += sw\n                            word.lw += sw\n                            p[k] += space\n                        if done:\n                            break\n\n                # if not completely full, push last words to right edge\n                diff = int(uww - line.w)\n                if diff > 0:\n                    # find the last word that had a space\n                    for w in range(len(words) - 1, -1, -1):\n                        if not idxs[w]:\n                            continue\n                        break\n                    old_opts = self.options\n                    self.options = word.options\n                    word = words[w]\n                    # split that word into left/right and push right till uww\n                    l_text = empty.join(parts[w][:idxs[w][-1]])\n                    r_text = empty.join(parts[w][idxs[w][-1]:])\n                    left = LayoutWord(\n                        word.options,\n                        self.get_extents(l_text)[0],\n                        word.lh,\n                        l_text\n                    )\n                    right = LayoutWord(\n                        word.options,\n                        self.get_extents(r_text)[0],\n                        word.lh,\n                        r_text\n                    )\n                    left.lw = max(left.lw, word.lw + diff - right.lw)\n                    self.options = old_opts\n\n                    # now put words back together with right/left inserted\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                    words[w] = right\n                    words.insert(w, left)\n                else:\n                    for k in range(len(words)):\n                        if idxs[k]:\n                            words[k].text = empty.join(parts[k])\n                line.w = uww\n                w = max(w, uww)\n\n        self._internal_size = w, h\n        if uw:\n            w = uw\n        if uh:\n            h = uh\n        if h > 1 and w < 2:\n            w = 2\n        if w < 1:\n            w = 1\n        if h < 1:\n            h = 1\n        return int(w), int(h)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 176,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}