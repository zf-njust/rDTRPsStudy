{
  "code": "def update_intermediates(base, keys, bound, s, fn, args, instance, value):\n    ''' Function that is called when an intermediate property is updated\n    and `rebind` of that property is True. In that case, we unbind\n    all bound funcs that were bound to attrs of the old value of the\n    property and rebind to the new value of the property.\n\n    For example, if the rule is `self.a.b.c.d`, then when b is changed, we\n    unbind from `b`, `c` and `d`, if they were bound before (they were not\n    None and `rebind` of the respective properties was True) and we rebind\n    to the new values of the attrs `b`, `c``, `d` that are not None and\n    `rebind` is True.\n\n    :Parameters:\n        `base`\n            A (proxied) ref to the base widget, `self` in the example\n            above.\n        `keys`\n            A list of the name off the attrs of `base` being watched. In\n            the example above it'd be `['a', 'b', 'c', 'd']`.\n        `bound`\n            A list 4-tuples, each tuple being (widget, attr, callback, uid)\n            representing callback functions bound to the attributed `attr`\n            of `widget`. `uid` is returned by `fbind` when binding.\n            The callback may be None, in which case the attr\n            was not bound, but is there to be able to walk the attr tree.\n            E.g. in the example above, if `b` was not an eventdispatcher,\n            `(_b_ref_, `c`, None)` would be added to the list so we can get\n            to `c` and `d`, which may be eventdispatchers and their attrs.\n        `s`\n            The index in `keys` of the of the attr that needs to be\n            updated. That is all the keys from `s` and further will be\n            rebound, since the `s` key was changed. In bound, the\n            corresponding index is `s - 1`. If `s` is None, we start from\n            1 (first attr).\n        `fn`\n            The function to be called args, `args` on bound callback.\n    '''\n    # first remove all the old bound functions from `s` and down.\n    for f, k, fun, uid in bound[s:]:\n        if fun is None:\n            continue\n        try:\n            f.unbind_uid(k, uid)\n        except ReferenceError:\n            pass\n    del bound[s:]\n\n    # find the first attr from which we need to start rebinding.\n    f = getattr(*bound[-1][:2])\n    if f is None:\n        fn(args, None, None)\n        return\n    s += 1\n    append = bound.append\n\n    # bind all attrs, except last to update_intermediates\n    for val in keys[s:-1]:\n        # if we need to dynamically rebind, bindm otherwise just\n        # add the attr to the list\n        if isinstance(f, (EventDispatcher, Observable)):\n            prop = f.property(val, True)\n            if prop is not None and getattr(prop, 'rebind', False):\n                # fbind should not dispatch, otherwise\n                # update_intermediates might be called in the middle\n                # here messing things up\n                uid = f.fbind(\n                    val, update_intermediates, base, keys, bound, s, fn, args)\n                append([f.proxy_ref, val, update_intermediates, uid])\n            else:\n                append([f.proxy_ref, val, None, None])\n        else:\n            append([getattr(f, 'proxy_ref', f), val, None, None])\n\n        f = getattr(f, val, None)\n        if f is None:\n            break\n        s += 1\n\n    # for the last attr we bind directly to the setting function,\n    # because that attr sets the value of the rule.\n    if isinstance(f, (EventDispatcher, Observable)):\n        uid = f.fbind(keys[-1], fn, args)\n        if uid:\n            append([f.proxy_ref, keys[-1], fn, uid])\n    # when we rebind we have to update the\n    # rule with the most recent value, otherwise, the value might be wrong\n    # and wouldn't be updated since we might not have tracked it before.\n    # This only happens for a callback when rebind was True for the prop.\n    fn(args, None, None)",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 46,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}