{
  "code": "def freeze(\n    requirement: Optional[List[str]] = None,\n    local_only: bool = False,\n    user_only: bool = False,\n    paths: Optional[List[str]] = None,\n    isolated: bool = False,\n    exclude_editable: bool = False,\n    skip: Container[str] = (),\n) -> Generator[str, None, None]:\n    installations: Dict[str, FrozenRequirement] = {}\n\n    dists = get_environment(paths).iter_installed_distributions(\n        local_only=local_only,\n        skip=(),\n        user_only=user_only,\n    )\n    for dist in dists:\n        req = FrozenRequirement.from_dist(dist)\n        if exclude_editable and req.editable:\n            continue\n        installations[req.canonical_name] = req\n\n    if requirement:\n        # the options that don't get turned into an InstallRequirement\n        # should only be emitted once, even if the same option is in multiple\n        # requirements files, so we need to keep track of what has been emitted\n        # so that we don't emit it again if it's seen again\n        emitted_options: Set[str] = set()\n        # keep track of which files a requirement is in so that we can\n        # give an accurate warning if a requirement appears multiple times.\n        req_files: Dict[str, List[str]] = collections.defaultdict(list)\n        for req_file_path in requirement:\n            with open(req_file_path) as req_file:\n                for line in req_file:\n                    if (\n                        not line.strip()\n                        or line.strip().startswith(\"#\")\n                        or line.startswith(\n                            (\n                                \"-r\",\n                                \"--requirement\",\n                                \"-f\",\n                                \"--find-links\",\n                                \"-i\",\n                                \"--index-url\",\n                                \"--pre\",\n                                \"--trusted-host\",\n                                \"--process-dependency-links\",\n                                \"--extra-index-url\",\n                                \"--use-feature\",\n                            )\n                        )\n                    ):\n                        line = line.rstrip()\n                        if line not in emitted_options:\n                            emitted_options.add(line)\n                            yield line\n                        continue\n\n                    if line.startswith(\"-e\") or line.startswith(\"--editable\"):\n                        if line.startswith(\"-e\"):\n                            line = line[2:].strip()\n                        else:\n                            line = line[len(\"--editable\") :].strip().lstrip(\"=\")\n                        line_req = install_req_from_editable(\n                            line,\n                            isolated=isolated,\n                        )\n                    else:\n                        line_req = install_req_from_line(\n                            COMMENT_RE.sub(\"\", line).strip(),\n                            isolated=isolated,\n                        )\n\n                    if not line_req.name:\n                        logger.info(\n                            \"Skipping line in requirement file [%s] because \"\n                            \"it's not clear what it would install: %s\",\n                            req_file_path,\n                            line.strip(),\n                        )\n                        logger.info(\n                            \"  (add #egg=PackageName to the URL to avoid\"\n                            \" this warning)\"\n                        )\n                    else:\n                        line_req_canonical_name = canonicalize_name(line_req.name)\n                        if line_req_canonical_name not in installations:\n                            # either it's not installed, or it is installed\n                            # but has been processed already\n                            if not req_files[line_req.name]:\n                                logger.warning(\n                                    \"Requirement file [%s] contains %s, but \"\n                                    \"package %r is not installed\",\n                                    req_file_path,\n                                    COMMENT_RE.sub(\"\", line).strip(),\n                                    line_req.name,\n                                )\n                            else:\n                                req_files[line_req.name].append(req_file_path)\n                        else:\n                            yield str(installations[line_req_canonical_name]).rstrip()\n                            del installations[line_req_canonical_name]\n                            req_files[line_req.name].append(req_file_path)\n\n        # Warn about requirements that were included multiple times (in a\n        # single requirements file or in different requirements files).\n        for name, files in req_files.items():\n            if len(files) > 1:\n                logger.warning(\n                    \"Requirement %s included multiple times [%s]\",\n                    name,\n                    \", \".join(sorted(set(files))),\n                )\n\n        yield (\"## The following requirements were added by pip freeze:\")\n    for installation in sorted(installations.values(), key=lambda x: x.name.lower()):\n        if installation.canonical_name not in skip:\n            yield str(installation).rstrip()",
  "smell": [
    {
      "smell_id": 4,
      "line_no": 103,
      "description": "The element is deleted from a container by a dynamically determined index."
    }
  ]
}