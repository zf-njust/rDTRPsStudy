{
  "code": "def write_data(data_fname, data_dict, use_json=False, compression=None):\n  \"\"\"Write data in HD5F format.\n\n  Args:\n    data_fname: The filename of teh file in which to write the data.\n    data_dict:  The dictionary of data to write. The keys are strings\n      and the values are numpy arrays.\n    use_json (optional): human readable format for simple items\n    compression (optional): The compression to use for h5py (disabled by\n      default because the library borks on scalars, otherwise try 'gzip').\n  \"\"\"\n\n  dir_name = os.path.dirname(data_fname)\n  if not os.path.exists(dir_name):\n    os.makedirs(dir_name)\n\n  if use_json:\n    the_file = open(data_fname,'wb')\n    json.dump(data_dict, the_file)\n    the_file.close()\n  else:\n    try:\n      with h5py.File(data_fname, 'w') as hf:\n        for k, v in data_dict.items():\n          clean_k = k.replace('/', '_')\n          if clean_k is not k:\n            print('Warning: saving variable with name: ', k, ' as ', clean_k)\n          else:\n            print('Saving variable with name: ', clean_k)\n          hf.create_dataset(clean_k, data=v, compression=compression)\n    except IOError:\n      print(\"Cannot open %s for writing.\", data_fname)\n      raise\ndef dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,\n        allow_nan=True, cls=None, indent=None, separators=None,\n        default=None, sort_keys=False, **kw):\n    \"\"\"Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n    ``.write()``-supporting file-like object).\n\n    If ``skipkeys`` is true then ``dict`` keys that are not basic types\n    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\n    instead of raising a ``TypeError``.\n\n    If ``ensure_ascii`` is false, then the strings written to ``fp`` can\n    contain non-ASCII characters if they appear in strings contained in\n    ``obj``. Otherwise, all such characters are escaped in JSON strings.\n\n    If ``check_circular`` is false, then the circular reference check\n    for container types will be skipped and a circular reference will\n    result in an ``OverflowError`` (or worse).\n\n    If ``allow_nan`` is false, then it will be a ``ValueError`` to\n    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\n    in strict compliance of the JSON specification, instead of using the\n    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\n    If ``indent`` is a non-negative integer, then JSON array elements and\n    object members will be pretty-printed with that indent level. An indent\n    level of 0 will only insert newlines. ``None`` is the most compact\n    representation.\n\n    If specified, ``separators`` should be an ``(item_separator, key_separator)``\n    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,\n    you should specify ``(',', ':')`` to eliminate whitespace.\n\n    ``default(obj)`` is a function that should return a serializable version\n    of obj or raise TypeError. The default simply raises TypeError.\n\n    If *sort_keys* is true (default: ``False``), then the output of\n    dictionaries will be sorted by key.\n\n    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n    ``.default()`` method to serialize additional types), specify it with\n    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.\n\n    \"\"\"\n    # cached encoder\n    if (not skipkeys and ensure_ascii and\n        check_circular and allow_nan and\n        cls is None and indent is None and separators is None and\n        default is None and not sort_keys and not kw):\n        iterable = _default_encoder.iterencode(obj)\n    else:\n        if cls is None:\n            cls = JSONEncoder\n        iterable = cls(skipkeys=skipkeys, ensure_ascii=ensure_ascii,\n            check_circular=check_circular, allow_nan=allow_nan, indent=indent,\n            separators=separators,\n            default=default, sort_keys=sort_keys, **kw).iterencode(obj)\n    # could accelerate with writelines in some versions of Python, at\n    # a debuggability cost\n    for chunk in iterable:\n        fp.write(chunk)",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 19,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}