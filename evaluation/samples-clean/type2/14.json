{
  "code": "    def _run(self):\n        # Track each tunnel that gets opened during our lifetime\n        tunnels = []\n\n        # Set up OS-level listener socket on forwarded port\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # TODO: why do we want REUSEADDR exactly? and is it portable?\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # NOTE: choosing to deal with nonblocking semantics and a fast loop,\n        # versus an older approach which blocks & expects outer scope to cause\n        # a socket exception by close()ing the socket.\n        sock.setblocking(0)\n        sock.bind(self.local_address)\n        sock.listen(1)\n\n        while not self.finished.is_set():\n            # Main loop-wait: accept connections on the local listener\n            # NOTE: EAGAIN means \"you're nonblocking and nobody happened to\n            # connect at this point in time\"\n            try:\n                tun_sock, local_addr = sock.accept()\n                # Set TCP_NODELAY to match OpenSSH's forwarding socket behavior\n                tun_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n            except socket.error as e:\n                if e.errno is errno.EAGAIN:\n                    # TODO: make configurable\n                    time.sleep(0.01)\n                    continue\n                raise\n\n            # Set up direct-tcpip channel on server end\n            # TODO: refactor w/ what's used for gateways\n            channel = self.transport.open_channel(\n                \"direct-tcpip\", self.remote_address, local_addr\n            )\n\n            # Set up 'worker' thread for this specific connection to our\n            # tunnel, plus its dedicated signal event (which will appear as a\n            # public attr, no need to track both independently).\n            finished = Event()\n            tunnel = Tunnel(channel=channel, sock=tun_sock, finished=finished)\n            tunnel.start()\n            tunnels.append(tunnel)\n\n        exceptions = []\n        # Propogate shutdown signal to all tunnels & wait for closure\n        # TODO: would be nice to have some output or at least logging here,\n        # especially for \"sets up a handful of tunnels\" use cases like\n        # forwarding nontrivial HTTP traffic.\n        for tunnel in tunnels:\n            tunnel.finished.set()\n            tunnel.join()\n            wrapper = tunnel.exception()\n            if wrapper:\n                exceptions.append(wrapper)\n        # Handle exceptions\n        if exceptions:\n            raise ThreadException(exceptions)\n\n        # All we have left to close is our own sock.\n        # TODO: use try/finally?\n        sock.close()",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 12,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}