{
  "code": "def prepare_panoptic_annotations(dataset_dir: str):\n    dataset_dir = Path(dataset_dir)\n\n    for name, dirname in [('train', 'training'), ('val', 'validation')]:\n        image_dir = dataset_dir / 'images' / dirname\n        semantic_dir = dataset_dir / 'annotations' / dirname\n        instance_dir = dataset_dir / 'annotations_instance' / dirname\n\n        # folder to store panoptic PNGs\n        out_folder = dataset_dir / f'ade20k_panoptic_{name}'\n        # json with segmentations information\n        out_file = dataset_dir / f'ade20k_panoptic_{name}.json'\n\n        mkdir_or_exist(out_folder)\n\n        # catid mapping\n        neworder_categories = []\n        all_classes = ORIGINAL_CATEGORIES\n        thing_classes = ADE20KPanopticDataset.METAINFO['thing_classes']\n        stuff_classes = ADE20KPanopticDataset.METAINFO['stuff_classes']\n        palette = ADE20KPanopticDataset.METAINFO['palette']\n\n        old_2_new_mapping = {}\n        new_2_old_mapping = {}\n        for i, t in enumerate(thing_classes):\n            j = list(all_classes).index(t)\n            old_2_new_mapping[j] = i\n            new_2_old_mapping[i] = j\n\n        for i, t in enumerate(stuff_classes):\n            j = list(all_classes).index(t)\n            old_2_new_mapping[j] = i + len(thing_classes)\n            new_2_old_mapping[i + len(thing_classes)] = j\n\n        for old, new in old_2_new_mapping.items():\n            neworder_categories.append({\n                'id': new,\n                'name': all_classes[old],\n                'isthing': int(new < len(thing_classes)),\n                'color': palette[new]\n            })\n        categories_dict = {cat['id']: cat for cat in neworder_categories}\n\n        panoptic_json_categories = neworder_categories[:]\n        panoptic_json_images = []\n        panoptic_json_annotations = []\n\n        filenames = sorted(list(image_dir.iterdir()))\n        progressbar = ProgressBar(len(filenames))\n        for filename in filenames:\n            panoptic_json_image = {}\n\n            image_id = filename.stem\n\n            panoptic_json_image['id'] = image_id\n            panoptic_json_image['file_name'] = filename.name\n\n            original_format = np.array(Image.open(filename))\n            panoptic_json_image['height'] = original_format.shape[0]\n            panoptic_json_image['width'] = original_format.shape[1]\n\n            pan_seg = np.zeros(\n                (original_format.shape[0], original_format.shape[1], 3),\n                dtype=np.uint8)\n            id_generator = IdGenerator(categories_dict)\n\n            filename_semantic = semantic_dir / f'{image_id}.png'\n            filename_instance = instance_dir / f'{image_id}.png'\n\n            sem_seg = np.array(Image.open(filename_semantic))\n            ins_seg = np.array(Image.open(filename_instance))\n\n            assert sem_seg.dtype == np.uint8\n            assert ins_seg.dtype == np.uint8\n\n            semantic_cat_ids = sem_seg - 1\n            instance_cat_ids = ins_seg[..., 0] - 1\n            # instance id starts from 1!\n            # because 0 is reserved as VOID label\n            instance_ins_ids = ins_seg[..., 1]\n\n            segm_info = []\n\n            # process stuffs\n            for semantic_cat_id in np.unique(semantic_cat_ids):\n                if semantic_cat_id == 255:\n                    continue\n                if categories_dict[old_2_new_mapping[int(\n                        semantic_cat_id)]]['isthing'] == 1:\n                    continue\n                mask = semantic_cat_ids == semantic_cat_id\n                # should not have any overlap\n                assert pan_seg[mask].sum() == 0\n\n                segment_id, color = id_generator.get_id_and_color(\n                    old_2_new_mapping[int(semantic_cat_id)])\n                pan_seg[mask] = color\n\n                area = np.sum(mask)\n                # bbox computation for a segment\n                hor = np.sum(mask, axis=0)\n                hor_idx = np.nonzero(hor)[0]\n                x = hor_idx[0]\n                width = hor_idx[-1] - x + 1\n                vert = np.sum(mask, axis=1)\n                vert_idx = np.nonzero(vert)[0]\n                y = vert_idx[0]\n                height = vert_idx[-1] - y + 1\n                bbox = [int(x), int(y), int(width), int(height)]\n\n                segm_info.append({\n                    'id':\n                    int(segment_id),\n                    'category_id':\n                    old_2_new_mapping[int(semantic_cat_id)],\n                    'area':\n                    int(area),\n                    'bbox':\n                    bbox,\n                    'iscrowd':\n                    0\n                })\n\n            # process things\n            for thing_id in np.unique(instance_ins_ids):\n                if thing_id == 0:\n                    continue\n                mask = instance_ins_ids == thing_id\n\n                instance_cat_id = np.unique(instance_cat_ids[mask])\n                assert len(instance_cat_id) == 1\n\n                segment_id, color = id_generator.get_id_and_color(\n                    instance_cat_id[0])\n                pan_seg[mask] = color\n\n                area = np.sum(mask)\n                # bbox computation for a segment\n                hor = np.sum(mask, axis=0)\n                hor_idx = np.nonzero(hor)[0]\n                x = hor_idx[-1] - x + 1\n                width = hor_idx[-1] - x + 1\n                vert = np.sum(mask, axis=1)\n                vert_idx = np.nonzero(vert)[0]\n                y = vert_idx[0]\n                height = vert_idx[-1] - y + 1\n                bbox = [int(x), int(y), int(width), int(height)]\n\n                segm_info.append({\n                    'id': int(segment_id),\n                    'category_id': int(instance_cat_id[0]),\n                    'area': int(area),\n                    'bbox': bbox,\n                    'iscrowd': 0\n                })\n\n            panoptic_json_annotation = {\n                'image_id': image_id,\n                'file_name': image_id + '.png',\n                'segments_info': segm_info\n            }\n\n            Image.fromarray(pan_seg).save(out_folder / f'{image_id}.png')\n\n            panoptic_json_images.append(panoptic_json_image)\n            panoptic_json_annotations.append(panoptic_json_annotation)\n\n            progressbar.update()\n\n        panoptic_json = {\n            'images': panoptic_json_images,\n            'annotations': panoptic_json_annotations,\n            'categories': panoptic_json_categories\n        }\n        save_json(panoptic_json, out_file)\n    def index(self, *args, **kwargs): # real signature unknown\n        \"\"\"\n        Return first index of value.\n        \n        Raises ValueError if the value is not present.\n        \"\"\"\n        pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 26,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}