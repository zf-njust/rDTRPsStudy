{
  "code": "def test_sparse_prior():\n    from mmdet.models.task_modules.prior_generators import MlvlPointGenerator\n    mlvl_points = MlvlPointGenerator(strides=[4, 10], offset=0)\n    prior_indexs = torch.Tensor([0, 2, 4, 5, 6, 9]).long()\n\n    featmap_sizes = [(3, 5), (6, 4)]\n    grid_anchors = mlvl_points.grid_priors(\n        featmap_sizes=featmap_sizes, with_stride=False, device='cpu')\n    sparse_prior = mlvl_points.sparse_priors(\n        prior_idxs=prior_indexs,\n        featmap_size=featmap_sizes[0],\n        level_idx=0,\n        device='cpu')\n\n    assert not sparse_prior.is_cuda\n    assert (sparse_prior == grid_anchors[0][prior_indexs]).all()\n    sparse_prior = mlvl_points.sparse_priors(\n        prior_idxs=prior_indexs,\n        featmap_size=featmap_sizes[1],\n        level_idx=1,\n        device='cpu')\n    assert (sparse_prior == grid_anchors[1][prior_indexs]).all()\n\n    from mmdet.models.task_modules.prior_generators import AnchorGenerator\n    mlvl_anchors = AnchorGenerator(\n        strides=[16, 32], ratios=[1.], scales=[1.], base_sizes=[4, 8])\n    prior_indexs = torch.Tensor([0, 2, 4, 5, 6, 9]).long()\n\n    featmap_sizes = [(3, 5), (6, 4)]\n    grid_anchors = mlvl_anchors.grid_priors(\n        featmap_sizes=featmap_sizes, device='cpu')\n    sparse_prior = mlvl_anchors.sparse_priors(\n        prior_idxs=prior_indexs,\n        featmap_size=featmap_sizes[0],\n        level_idx=0,\n        device='cpu')\n    assert (sparse_prior == grid_anchors[0][prior_indexs]).all()\n    sparse_prior = mlvl_anchors.sparse_priors(\n        prior_idxs=prior_indexs,\n        featmap_size=featmap_sizes[1],\n        level_idx=1,\n        device='cpu')\n    assert (sparse_prior == grid_anchors[1][prior_indexs]).all()\n\n    # for ssd\n    from mmdet.models.task_modules.prior_generators import SSDAnchorGenerator\n    featmap_sizes = [(38, 38), (19, 19), (10, 10)]\n    anchor_generator = SSDAnchorGenerator(\n        scale_major=False,\n        input_size=300,\n        basesize_ratio_range=(0.15, 0.9),\n        strides=[8, 16, 32],\n        ratios=[[2], [2, 3], [2, 3]])\n    ssd_anchors = anchor_generator.grid_anchors(featmap_sizes, device='cpu')\n    for i in range(len(featmap_sizes)):\n        sparse_ssd_anchors = anchor_generator.sparse_priors(\n            prior_idxs=prior_indexs,\n            level_idx=i,\n            featmap_size=featmap_sizes[i],\n            device='cpu')\n        assert (sparse_ssd_anchors == ssd_anchors[i][prior_indexs]).all()\n\n    # for yolo\n    from mmdet.models.task_modules.prior_generators import YOLOAnchorGenerator\n    featmap_sizes = [(38, 38), (19, 19), (10, 10)]\n    anchor_generator = YOLOAnchorGenerator(\n        strides=[32, 16, 8],\n        base_sizes=[\n            [(116, 90), (156, 198), (373, 326)],\n            [(30, 61), (62, 45), (59, 119)],\n            [(10, 13), (16, 30), (33, 23)],\n        ])\n    yolo_anchors = anchor_generator.grid_anchors(featmap_sizes, device='cpu')\n    for i in range(len(featmap_sizes)):\n        sparse_yolo_anchors = anchor_generator.sparse_priors(\n            prior_idxs=prior_indexs,\n            level_idx=i,\n            featmap_size=featmap_sizes[i],\n            device='cpu')\n        assert (sparse_yolo_anchors == yolo_anchors[i][prior_indexs]).all()\n\n    if torch.cuda.is_available():\n        mlvl_points = MlvlPointGenerator(strides=[4, 10], offset=0)\n        prior_indexs = torch.Tensor([0, 3, 4, 5, 6, 7, 1, 2, 4, 5, 6,\n                                     9]).long().cuda()\n\n        featmap_sizes = [(6, 8), (6, 4)]\n        grid_anchors = mlvl_points.grid_priors(\n            featmap_sizes=featmap_sizes, with_stride=False, device='cuda')\n        sparse_prior = mlvl_points.sparse_priors(\n            prior_idxs=prior_indexs,\n            featmap_size=featmap_sizes[0],\n            level_idx=0,\n            device='cuda')\n        assert (sparse_prior == grid_anchors[0][prior_indexs]).all()\n        sparse_prior = mlvl_points.sparse_priors(\n            prior_idxs=prior_indexs,\n            featmap_size=featmap_sizes[1],\n            level_idx=1,\n            device='cuda')\n        assert (sparse_prior == grid_anchors[1][prior_indexs]).all()\n        assert sparse_prior.is_cuda\n        mlvl_anchors = AnchorGenerator(\n            strides=[16, 32],\n            ratios=[1., 2.5],\n            scales=[1., 5.],\n            base_sizes=[4, 8])\n        prior_indexs = torch.Tensor([4, 5, 6, 7, 0, 2, 50, 4, 5, 6,\n                                     9]).long().cuda()\n\n        featmap_sizes = [(13, 5), (16, 4)]\n        grid_anchors = mlvl_anchors.grid_priors(\n            featmap_sizes=featmap_sizes, device='cuda')\n        sparse_prior = mlvl_anchors.sparse_priors(\n            prior_idxs=prior_indexs,\n            featmap_size=featmap_sizes[0],\n            level_idx=0,\n            device='cuda')\n        assert (sparse_prior == grid_anchors[0][prior_indexs]).all()\n        sparse_prior = mlvl_anchors.sparse_priors(\n            prior_idxs=prior_indexs,\n            featmap_size=featmap_sizes[1],\n            level_idx=1,\n            device='cuda')\n        assert (sparse_prior == grid_anchors[1][prior_indexs]).all()\n\n        # for ssd\n        from mmdet.models.task_modules.prior_generators import \\\n            SSDAnchorGenerator\n        featmap_sizes = [(38, 38), (19, 19), (10, 10)]\n        anchor_generator = SSDAnchorGenerator(\n            scale_major=False,\n            input_size=300,\n            basesize_ratio_range=(0.15, 0.9),\n            strides=[8, 16, 32],\n            ratios=[[2], [2, 3], [2, 3]])\n        ssd_anchors = anchor_generator.grid_anchors(\n            featmap_sizes, device='cuda')\n        for i in range(len(featmap_sizes)):\n            sparse_ssd_anchors = anchor_generator.sparse_priors(\n                prior_idxs=prior_indexs,\n                level_idx=i,\n                featmap_size=featmap_sizes[i],\n                device='cuda')\n            assert (sparse_ssd_anchors == ssd_anchors[i][prior_indexs]).all()\n\n        # for yolo\n        from mmdet.models.task_modules.prior_generators import \\\n            YOLOAnchorGenerator\n        featmap_sizes = [(38, 38), (19, 19), (10, 10)]\n        anchor_generator = YOLOAnchorGenerator(\n            strides=[32, 16, 8],\n            base_sizes=[\n                [(116, 90), (156, 198), (373, 326)],\n                [(30, 61), (62, 45), (59, 119)],\n                [(10, 13), (16, 30), (33, 23)],\n            ])\n        yolo_anchors = anchor_generator.grid_anchors(\n            featmap_sizes, device='cuda')\n        for i in range(len(featmap_sizes)):\n            sparse_yolo_anchors = anchor_generator.sparse_priors(\n                prior_idxs=prior_indexs,\n                level_idx=i,\n                featmap_size=featmap_sizes[i],\n                device='cuda')\n            assert (sparse_yolo_anchors == yolo_anchors[i][prior_indexs]).all()\n    def sparse_priors(self,\n                      prior_idxs: Tensor,\n                      featmap_size: Tuple[int, int],\n                      level_idx: int,\n                      dtype: torch.dtype = torch.float32,\n                      device: DeviceType = 'cuda') -> Tensor:\n        \"\"\"Generate sparse anchors according to the ``prior_idxs``.\n\n        Args:\n            prior_idxs (Tensor): The index of corresponding anchors\n                in the feature map.\n            featmap_size (tuple[int, int]): feature map size arrange as (h, w).\n            level_idx (int): The level index of corresponding feature\n                map.\n            dtype (obj:`torch.dtype`): Date type of points.Defaults to\n                ``torch.float32``.\n            device (str | torch.device): The device where the points is\n                located.\n        Returns:\n            Tensor: Anchor with shape (N, 4), N should be equal to\n                the length of ``prior_idxs``.\n        \"\"\"\n\n        height, width = featmap_size\n        num_base_anchors = self.num_base_anchors[level_idx]\n        base_anchor_id = prior_idxs % num_base_anchors\n        x = (prior_idxs //\n             num_base_anchors) % width * self.strides[level_idx][0]\n        y = (prior_idxs // width //\n             num_base_anchors) % height * self.strides[level_idx][1]\n        priors = torch.stack([x, y, x, y], 1).to(dtype).to(device) + \\\n            self.base_anchors[level_idx][base_anchor_id, :].to(device)\n\n        return priors",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 11,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}