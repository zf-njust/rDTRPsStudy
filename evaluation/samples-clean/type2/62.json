{
  "code": "def do_GET(self):\n        xlog.info('PAC from:%s %s %s ', self.address_string(), self.command, self.path)\n\n        path = urlparse.urlparse(self.path).path # '/proxy.pac'\n        filename = os.path.normpath('./' + path) # proxy.pac\n\n        if self.path.startswith(('http://', 'https://')):\n            data = b'HTTP/1.1 200\\r\\nCache-Control: max-age=86400\\r\\nExpires:Oct, 01 Aug 2100 00:00:00 GMT\\r\\nConnection: close\\r\\n'\n            if filename.endswith(('.jpg', '.gif', '.jpeg', '.bmp')):\n                data += b'Content-Type: image/gif\\r\\n\\r\\n' + self.onepixel\n            else:\n                data += b'\\r\\n This is the Pac server, not proxy port, use 8087 as proxy port.'\n            self.wfile.write(data)\n            xlog.info('%s \"%s %s HTTP/1.1\" 200 -', self.address_string(), self.command, self.path)\n            return\n\n        # check for '..', which will leak file\n        if re.search(r'(\\.{2})', self.path) is not None:\n            self.wfile.write(b'HTTP/1.1 404\\r\\n\\r\\n')\n            xlog.warn('%s %s %s haking', self.address_string(), self.command, self.path )\n            return\n\n\n        if filename != 'proxy.pac':\n            xlog.warn(\"pac_server GET %s fail\", filename)\n            self.wfile.write(b'HTTP/1.1 404\\r\\n\\r\\n')\n            return\n\n        mimetype = 'text/plain'\n        if self.path.endswith('.pac?flush') or time.time() - os.path.getmtime(get_serving_pacfile()) > config.PAC_EXPIRED:\n            thread.start_new_thread(PacUtil.update_pacfile, (user_pacfile,))\n\n        pac_filename = get_serving_pacfile()\n        with open(pac_filename, 'rb') as fp:\n            data = fp.read()\n\n        host = self.headers.getheader('Host')\n        host, _, port = host.rpartition(\":\")\n        gae_proxy_proxy = host + \":\" + str(config.LISTEN_PORT)\n        pac_proxy = host + \":\" + str(config.PAC_PORT)\n        data = data.replace(gae_proxy_listen, gae_proxy_proxy)\n        data = data.replace(pac_listen, pac_proxy)\n        self.wfile.write(('HTTP/1.1 200\\r\\nContent-Type: %s\\r\\nContent-Length: %s\\r\\n\\r\\n' % (mimetype, len(data))).encode())\n        self.wfile.write(data)\n    def replace(self, *args, **kwargs): # real signature unknown\n        \"\"\"\n        Return a copy with all occurrences of substring old replaced by new.\n        \n          count\n            Maximum number of occurrences to replace.\n            -1 (the default value) means replace all occurrences.\n        \n        If the optional argument count is given, only the first count occurrences are\n        replaced.\n        \"\"\"\n        pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 41,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}