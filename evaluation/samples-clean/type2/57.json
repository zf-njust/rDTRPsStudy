{
  "code": "def get_tk_face(self, frame_index, face_index, face):\n        \"\"\" Obtain the :class:`TKFace` object for the given face from the cache. If the face does\n        not exist in the cache, then it is generated and added prior to returning.\n\n        Parameters\n        ----------\n        frame_index: int\n            The frame index to obtain the face for\n        face_index: int\n            The face index of the face within the requested frame\n        face: :class:`~lib.align.DetectedFace`\n            The detected face object, containing the thumbnail jpg\n\n        Returns\n        -------\n        :class:`TKFace`\n            An object for displaying in the faces viewer canvas populated with the aligned mesh\n            landmarks and face thumbnail\n        \"\"\"\n        is_active = frame_index == self._active_frame.frame_index\n        key = \"_\".join([str(frame_index), str(face_index)])\n        if key not in self._tk_faces or is_active:\n            logger.trace(\"creating new tk_face: (key: %s, is_active: %s)\", key, is_active)\n            if is_active:\n                image = AlignedFace(face.landmarks_xy,\n                                    image=self._active_frame.current_frame,\n                                    centering=self._centering,\n                                    size=self.face_size).face\n            else:\n                image = AlignedFace(face.landmarks_xy,\n                                    image=cv2.imdecode(face.thumbnail, cv2.IMREAD_UNCHANGED),\n                                    centering=self._centering,\n                                    size=self.face_size,\n                                    is_aligned=True).face\n            tk_face = self._get_tk_face_object(face, image, is_active)\n            self._tk_faces[key] = tk_face\n        else:\n            logger.trace(\"tk_face exists: %s\", key)\n            tk_face = self._tk_faces[key]\n        return tk_face\n    def __init__(self,\n                 landmarks: np.ndarray,\n                 image: np.ndarray | None = None,\n                 centering: CenteringType = \"face\",\n                 size: int = 64,\n                 coverage_ratio: float = 1.0,\n                 dtype: str | None = None,\n                 is_aligned: bool = False,\n                 is_legacy: bool = False) -> None:\n        logger.trace(\"Initializing: %s (image shape: %s, centering: '%s', \"  # type: ignore\n                     \"size: %s, coverage_ratio: %s, dtype: %s, is_aligned: %s, is_legacy: %s)\",\n                     self.__class__.__name__, image if image is None else image.shape,\n                     centering, size, coverage_ratio, dtype, is_aligned, is_legacy)\n        self._frame_landmarks = landmarks\n        self._centering = centering\n        self._size = size\n        self._coverage_ratio = coverage_ratio\n        self._dtype = dtype\n        self._is_aligned = is_aligned\n        self._source_centering: CenteringType = \"legacy\" if is_legacy and is_aligned else \"head\"\n        self._matrices = {\"legacy\": _umeyama(landmarks[17:], _MEAN_FACE, True)[0:2],\n                          \"face\": np.array([]),\n                          \"head\": np.array([])}\n        self._padding = self._padding_from_coverage(size, coverage_ratio)\n\n        self._cache = _FaceCache()\n\n        self._face = self.extract_face(image)\n        logger.trace(\"Initialized: %s (matrix: %s, padding: %s, face shape: %s)\",  # type: ignore\n                     self.__class__.__name__, self._matrices[\"legacy\"], self._padding,\n                     self._face if self._face is None else self._face.shape)",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 27,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}