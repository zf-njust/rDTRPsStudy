{
  "code": "    def format_date(self, date, gmt_offset=0, relative=True, shorter=False,\n                    full_format=False):\n        \"\"\"Formats the given date (which should be GMT).\n\n        By default, we return a relative time (e.g., \"2 minutes ago\"). You\n        can return an absolute date string with ``relative=False``.\n\n        You can force a full format date (\"July 10, 1980\") with\n        ``full_format=True``.\n\n        This method is primarily intended for dates in the past.\n        For dates in the future, we fall back to full format.\n        \"\"\"\n        if isinstance(date, numbers.Real):\n            date = datetime.datetime.utcfromtimestamp(date)\n        now = datetime.datetime.utcnow()\n        if date > now:\n            if relative and (date - now).seconds < 60:\n                # Due to click skew, things are some things slightly\n                # in the future. Round timestamps in the immediate\n                # future down to now in relative mode.\n                date = now\n            else:\n                # Otherwise, future dates always use the full format.\n                full_format = True\n        local_date = date - datetime.timedelta(minutes=gmt_offset)\n        local_now = now - datetime.timedelta(minutes=gmt_offset)\n        local_yesterday = local_now - datetime.timedelta(hours=24)\n        difference = now - date\n        seconds = difference.seconds\n        days = difference.days\n\n        _ = self.translate\n        format = None\n        if not full_format:\n            if relative and days == 0:\n                if seconds < 50:\n                    return _(\"1 second ago\", \"%(seconds)d seconds ago\",\n                             seconds) % {\"seconds\": seconds}\n\n                if seconds < 50 * 60:\n                    minutes = round(seconds / 60.0)\n                    return _(\"1 minute ago\", \"%(minutes)d minutes ago\",\n                             minutes) % {\"minutes\": minutes}\n\n                hours = round(seconds / (60.0 * 60))\n                return _(\"1 hour ago\", \"%(hours)d hours ago\",\n                         hours) % {\"hours\": hours}\n\n            if days == 0:\n                format = _(\"%(time)s\")\n            elif days == 1 and local_date.day == local_yesterday.day and \\\n                    relative:\n                format = _(\"yesterday\") if shorter else \\\n                    _(\"yesterday at %(time)s\")\n            elif days < 5:\n                format = _(\"%(weekday)s\") if shorter else \\\n                    _(\"%(weekday)s at %(time)s\")\n            elif days < 334:  # 11mo, since confusing for same month last year\n                format = _(\"%(month_name)s %(day)s\") if shorter else \\\n                    _(\"%(month_name)s %(day)s at %(time)s\")\n\n        if format is None:\n            format = _(\"%(month_name)s %(day)s, %(year)s\") if shorter else \\\n                _(\"%(month_name)s %(day)s, %(year)s at %(time)s\")\n\n        tfhour_clock = self.code not in (\"en\", \"en_US\", \"zh_CN\")\n        if tfhour_clock:\n            str_time = \"%d:%02d\" % (local_date.hour, local_date.minute)\n        elif self.code == \"zh_CN\":\n            str_time = \"%s%d:%02d\" % (\n                (u'\\u4e0a\\u5348', u'\\u4e0b\\u5348')[local_date.hour >= 12],\n                local_date.hour % 12 or 12, local_date.minute)\n        else:\n            str_time = \"%d:%02d %s\" % (\n                local_date.hour % 12 or 12, local_date.minute,\n                (\"am\", \"pm\")[local_date.hour >= 12])\n\n        return format % {\n            \"month_name\": self._months[local_date.month - 1],\n            \"weekday\": self._weekdays[local_date.weekday()],\n            \"day\": str(local_date.day),\n            \"year\": str(local_date.year),\n            \"time\": str_time",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 15,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}