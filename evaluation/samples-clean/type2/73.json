{
  "code": "def convert_to_terminated_truncated_step_api(\n    step_returns: Union[DoneStepType, TerminatedTruncatedStepType], is_vector_env=False\n) -> TerminatedTruncatedStepType:\n    \"\"\"Function to transform step returns to new step API irrespective of input API.\n\n    Args:\n        step_returns (tuple): Items returned by step(). Can be (obs, rew, done, info) or (obs, rew, terminated, truncated, info)\n        is_vector_env (bool): Whether the step_returns are from a vector environment\n    \"\"\"\n    if len(step_returns) == 5:\n        return step_returns\n    else:\n        assert len(step_returns) == 4\n        observations, rewards, dones, infos = step_returns\n\n        # Cases to handle - info single env /  info vector env (list) / info vector env (dict)\n        if is_vector_env is False:\n            truncated = infos.pop(\"TimeLimit.truncated\", False)\n            return (\n                observations,\n                rewards,\n                dones and not truncated,\n                dones and truncated,\n                infos,\n            )\n        elif isinstance(infos, list):\n            truncated = np.array(\n                [info.pop(\"TimeLimit.truncated\", False) for info in infos]\n            )\n            return (\n                observations,\n                rewards,\n                np.logical_and(dones, np.logical_not(truncated)),\n                np.logical_and(dones, truncated),\n                infos,\n            )\n        elif isinstance(infos, dict):\n            num_envs = len(dones)\n            truncated = infos.pop(\"TimeLimit.truncated\", np.zeros(num_envs, dtype=bool))\n            return (\n                observations,\n                rewards,\n                np.logical_and(dones, np.logical_not(truncated)),\n                np.logical_and(dones, truncated),\n                infos,\n            )\n        else:\n            raise TypeError(\n                f\"Unexpected value of infos, as is_vector_envs=False, expects `info` to be a list or dict, actual type: {type(infos)}\"\n            )\n    def pop(self, last=True):\n        if not self:\n            raise KeyError('set is empty')\n        key = self.end[1][0] if last else self.end[2][0]\n        self.discard(key)\n        return key",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 18,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}