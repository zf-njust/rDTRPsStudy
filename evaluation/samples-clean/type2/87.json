{
  "code": "def buildmodule(m, um):\n    \"\"\"\n    Return\n    \"\"\"\n    global f2py_version, options\n    outmess('\\tBuilding module \"%s\"...\\n' % (m['name']))\n    ret = {}\n    mod_rules = defmod_rules[:]\n    vrd = capi_maps.modsign2map(m)\n    rd = dictappend({'f2py_version': f2py_version}, vrd)\n    funcwrappers = []\n    funcwrappers2 = []  # F90 codes\n    for n in m['interfaced']:\n        nb = None\n        for bi in m['body']:\n            if not bi['block'] == 'interface':\n                errmess('buildmodule: Expected interface block. Skipping.\\n')\n                continue\n            for b in bi['body']:\n                if b['name'] == n:\n                    nb = b\n                    break\n\n        if not nb:\n            errmess(\n                'buildmodule: Could not found the body of interfaced routine \"%s\". Skipping.\\n' % (n))\n            continue\n        nb_list = [nb]\n        if 'entry' in nb:\n            for k, a in nb['entry'].items():\n                nb1 = copy.deepcopy(nb)\n                del nb1['entry']\n                nb1['name'] = k\n                nb1['args'] = a\n                nb_list.append(nb1)\n        for nb in nb_list:\n            api, wrap = buildapi(nb)\n            if wrap:\n                if ismoduleroutine(nb):\n                    funcwrappers2.append(wrap)\n                else:\n                    funcwrappers.append(wrap)\n            ar = applyrules(api, vrd)\n            rd = dictappend(rd, ar)\n\n    # Construct COMMON block support\n    cr, wrap = common_rules.buildhooks(m)\n    if wrap:\n        funcwrappers.append(wrap)\n    ar = applyrules(cr, vrd)\n    rd = dictappend(rd, ar)\n\n    # Construct F90 module support\n    mr, wrap = f90mod_rules.buildhooks(m)\n    if wrap:\n        funcwrappers2.append(wrap)\n    ar = applyrules(mr, vrd)\n    rd = dictappend(rd, ar)\n\n    for u in um:\n        ar = use_rules.buildusevars(u, m['use'][u['name']])\n        rd = dictappend(rd, ar)\n\n    needs = cfuncs.get_needs()\n    code = {}\n    for n in needs.keys():\n        code[n] = []\n        for k in needs[n]:\n            c = ''\n            if k in cfuncs.includes0:\n                c = cfuncs.includes0[k]\n            elif k in cfuncs.includes:\n                c = cfuncs.includes[k]\n            elif k in cfuncs.userincludes:\n                c = cfuncs.userincludes[k]\n            elif k in cfuncs.typedefs:\n                c = cfuncs.typedefs[k]\n            elif k in cfuncs.typedefs_generated:\n                c = cfuncs.typedefs_generated[k]\n            elif k in cfuncs.cppmacros:\n                c = cfuncs.cppmacros[k]\n            elif k in cfuncs.cfuncs:\n                c = cfuncs.cfuncs[k]\n            elif k in cfuncs.callbacks:\n                c = cfuncs.callbacks[k]\n            elif k in cfuncs.f90modhooks:\n                c = cfuncs.f90modhooks[k]\n            elif k in cfuncs.commonhooks:\n                c = cfuncs.commonhooks[k]\n            else:\n                errmess('buildmodule: unknown need %s.\\n' % (repr(k)))\n                continue\n            code[n].append(c)\n    mod_rules.append(code)\n    for r in mod_rules:\n        if ('_check' in r and r['_check'](m)) or ('_check' not in r):\n            ar = applyrules(r, vrd, m)\n            rd = dictappend(rd, ar)\n    ar = applyrules(module_rules, rd)\n\n    fn = os.path.join(options['buildpath'], vrd['coutput'])\n    ret['csrc'] = fn\n    f = open(fn, 'w')\n    f.write(ar['modulebody'].replace('\\t', 2 * ' '))\n    f.close()\n    outmess('\\tWrote C/API module \"%s\" to file \"%s\"\\n' % (m['name'], fn))\n\n    if options['dorestdoc']:\n        fn = os.path.join(\n            options['buildpath'], vrd['modulename'] + 'module.rest')\n        f = open(fn, 'w')\n        f.write('.. -*- rest -*-\\n')\n        f.write('\\n'.join(ar['restdoc']))\n        f.close()\n        outmess('\\tReST Documentation is saved to file \"%s/%smodule.rest\"\\n' %\n                (options['buildpath'], vrd['modulename']))\n    if options['dolatexdoc']:\n        fn = os.path.join(\n            options['buildpath'], vrd['modulename'] + 'module.tex')\n        ret['ltx'] = fn\n        f = open(fn, 'w')\n        f.write(\n            '%% This file is auto-generated with f2py (version:%s)\\n' % (f2py_version))\n        if 'shortlatex' not in options:\n            f.write(\n                '\\\\documentclass{article}\\n\\\\usepackage{a4wide}\\n\\\\begin{document}\\n\\\\tableofcontents\\n\\n')\n        f.write('\\n'.join(ar['latexdoc']))\n        if 'shortlatex' not in options:\n            f.write('\\\\end{document}')\n        f.close()\n        outmess('\\tDocumentation is saved to file \"%s/%smodule.tex\"\\n' %\n                (options['buildpath'], vrd['modulename']))\n    if funcwrappers:\n        wn = os.path.join(options['buildpath'], vrd['f2py_wrapper_output'])\n        ret['fsrc'] = wn\n        f = open(wn, 'w')\n        f.write('C     -*- fortran -*-\\n')\n        f.write(\n            'C     This file is autogenerated with f2py (version:%s)\\n' % (f2py_version))\n        f.write(\n            'C     It contains Fortran 77 wrappers to fortran functions.\\n')\n        lines = []\n        for l in ('\\n\\n'.join(funcwrappers) + '\\n').split('\\n'):\n            if l and l[0] == ' ':\n                while len(l) >= 66:\n                    lines.append(l[:66] + '\\n     &')\n                    l = l[66:]\n                lines.append(l + '\\n')\n            else:\n                lines.append(l + '\\n')\n        lines = ''.join(lines).replace('\\n     &\\n', '\\n')\n        f.write(lines)\n        f.close()\n        outmess('\\tFortran 77 wrappers are saved to \"%s\"\\n' % (wn))\n    if funcwrappers2:\n        wn = os.path.join(\n            options['buildpath'], '%s-f2pywrappers2.f90' % (vrd['modulename']))\n        ret['fsrc'] = wn\n        f = open(wn, 'w')\n        f.write('!     -*- f90 -*-\\n')\n        f.write(\n            '!     This file is autogenerated with f2py (version:%s)\\n' % (f2py_version))\n        f.write(\n            '!     It contains Fortran 90 wrappers to fortran functions.\\n')\n        lines = []\n        for l in ('\\n\\n'.join(funcwrappers2) + '\\n').split('\\n'):\n            if len(l) > 72 and l[0] == ' ':\n                lines.append(l[:72] + '&\\n     &')\n                l = l[72:]\n                while len(l) > 66:\n                    lines.append(l[:66] + '&\\n     &')\n                    l = l[66:]\n                lines.append(l + '\\n')\n            else:\n                lines.append(l + '\\n')\n        lines = ''.join(lines).replace('\\n     &\\n', '\\n')\n        f.write(lines)\n        f.close()\n        outmess('\\tFortran 90 wrappers are saved to \"%s\"\\n' % (wn))\n    return ret\n    def write(self, s: AnyStr) -> int:\n        pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 152,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}