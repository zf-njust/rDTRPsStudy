{
  "code": "def load_translations(directory, encoding=None):\n    \"\"\"Loads translations from CSV files in a directory.\n\n    Translations are strings with optional Python-style named placeholders\n    (e.g., ``My name is %(name)s``) and their associated translations.\n\n    The directory should have translation files of the form ``LOCALE.csv``,\n    e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,\n    translation, and an optional plural indicator. Plural indicators should\n    be one of \"plural\" or \"singular\". A given string can have both singular\n    and plural forms. For example ``%(name)s liked this`` may have a\n    different verb conjugation depending on whether %(name)s is one\n    name or a list of names. There should be two rows in the CSV file for\n    that string, one with plural indicator \"singular\", and one \"plural\".\n    For strings with no verbs that would change on translation, simply\n    use \"unknown\" or the empty string (or don't include the column at all).\n\n    The file is read using the `csv` module in the default \"excel\" dialect.\n    In this format there should not be spaces after the commas.\n\n    If no ``encoding`` parameter is given, the encoding will be\n    detected automatically (among UTF-8 and UTF-16) if the file\n    contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM\n    is present.\n\n    Example translation ``es_LA.csv``::\n\n        \"I love you\",\"Te amo\"\n        \"%(name)s liked this\",\"A %(name)s les gust贸 esto\",\"plural\"\n        \"%(name)s liked this\",\"A %(name)s le gust贸 esto\",\"singular\"\n\n    .. versionchanged:: 4.3\n       Added ``encoding`` parameter. Added support for BOM-based encoding\n       detection, UTF-16, and UTF-8-with-BOM.\n    \"\"\"\n    global _translations\n    global _supported_locales\n    _translations = {}\n    for path in os.listdir(directory):\n        if not path.endswith(\".csv\"):\n            continue\n        locale, extension = path.split(\".\")\n        if not re.match(\"[a-z]+(_[A-Z]+)?$\", locale):\n            gen_log.error(\"Unrecognized locale %r (path: %s)\", locale,\n                          os.path.join(directory, path))\n            continue\n        full_path = os.path.join(directory, path)\n        if encoding is None:\n            # Try to autodetect encoding based on the BOM.\n            with open(full_path, 'rb') as f:\n                data = f.read(len(codecs.BOM_UTF16_LE))\n            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):\n                encoding = 'utf-16'\n            else:\n                # utf-8-sig is \"utf-8 with optional BOM\". It's discouraged\n                # in most cases but is common with CSV files because Excel\n                # cannot read utf-8 files without a BOM.\n                encoding = 'utf-8-sig'\n        if PY3:\n            # python 3: csv.reader requires a file open in text mode.\n            # Force utf8 to avoid dependence on $LANG environment variable.\n            f = open(full_path, \"r\", encoding=encoding)\n        else:\n            # python 2: csv can only handle byte strings (in ascii-compatible\n            # encodings), which we decode below. Transcode everything into\n            # utf8 before passing it to csv.reader.\n            f = BytesIO()\n            with codecs.open(full_path, \"r\", encoding=encoding) as infile:\n                f.write(escape.utf8(infile.read()))\n            f.seek(0)\n        _translations[locale] = {}\n        for i, row in enumerate(csv.reader(f)):\n            if not row or len(row) < 2:\n                continue\n            row = [escape.to_unicode(c).strip() for c in row]\n            english, translation = row[:2]\n            if len(row) > 2:\n                plural = row[2] or \"unknown\"\n            else:\n                plural = \"unknown\"\n            if plural not in (\"plural\", \"singular\", \"unknown\"):\n                gen_log.error(\"Unrecognized plural indicator %r in %s line %d\",\n                              plural, path, i + 1)\n                continue\n            _translations[locale].setdefault(plural, {})[english] = translation\n        f.close()\n    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])\n    gen_log.debug(\"Supported locales: %s\", sorted(_supported_locales))",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 72,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}