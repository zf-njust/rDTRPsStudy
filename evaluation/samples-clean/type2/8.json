{
  "code": "def modify_module(module_name, module_path, module_args, task_vars=dict(), module_compression='ZIP_STORED'):\n    \"\"\"\n    Used to insert chunks of code into modules before transfer rather than\n    doing regular python imports.  This allows for more efficient transfer in\n    a non-bootstrapping scenario by not moving extra files over the wire and\n    also takes care of embedding arguments in the transferred modules.\n\n    This version is done in such a way that local imports can still be\n    used in the module code, so IDEs don't have to be aware of what is going on.\n\n    Example:\n\n    from ansible.module_utils.basic import *\n\n       ... will result in the insertion of basic.py into the module\n       from the module_utils/ directory in the source tree.\n\n    For powershell, there's equivalent conventions like this:\n\n    # POWERSHELL_COMMON\n\n    which results in the inclusion of the common code from powershell.ps1\n\n    \"\"\"\n    with open(module_path, 'rb') as f:\n\n        # read in the module source\n        module_data = f.read()\n\n    (module_data, module_style, shebang) = _find_snippet_imports(module_name, module_data, module_path, module_args, task_vars, module_compression)\n\n    if module_style == 'binary':\n        return (module_data, module_style, to_text(shebang, nonstring='passthru'))\n    elif shebang is None:\n        lines = module_data.split(b\"\\n\", 1)\n        if lines[0].startswith(b\"#!\"):\n            shebang = lines[0].strip()\n            args = shlex.split(str(shebang[2:]))\n            interpreter = args[0]\n            interpreter = to_bytes(interpreter)\n\n            new_shebang = to_bytes(_get_shebang(interpreter, task_vars, args[1:])[0], errors='surrogate_or_strict', nonstring='passthru')\n            if new_shebang:\n                lines[0] = shebang = new_shebang\n\n            if os.path.basename(interpreter).startswith(b'python'):\n                lines.insert(1, to_bytes(ENCODING_STRING))\n        else:\n            # No shebang, assume a binary module?\n            pass\n\n        module_data = b\"\\n\".join(lines)\n    else:\n        shebang = to_bytes(shebang, errors='surrogate_or_strict')\n\n    return (module_data, module_style, to_text(shebang, nonstring='passthru'))",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 46,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}