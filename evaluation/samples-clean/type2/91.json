{
  "code": "def create(cls, cwd):  # type: (Path) -> Poetry\n        poetry_file = cls.locate(cwd)\n\n        local_config = TomlFile(poetry_file.as_posix()).read()\n        if \"tool\" not in local_config or \"poetry\" not in local_config[\"tool\"]:\n            raise RuntimeError(\n                \"[tool.poetry] section not found in {}\".format(poetry_file.name)\n            )\n        local_config = local_config[\"tool\"][\"poetry\"]\n\n        # Checking validity\n        check_result = cls.check(local_config)\n        if check_result[\"errors\"]:\n            message = \"\"\n            for error in check_result[\"errors\"]:\n                message += \"  - {}\\n\".format(error)\n\n            raise RuntimeError(\"The Poetry configuration is invalid:\\n\" + message)\n\n        # Load package\n        name = local_config[\"name\"]\n        version = local_config[\"version\"]\n        package = ProjectPackage(name, version, version)\n        package.root_dir = poetry_file.parent\n\n        for author in local_config[\"authors\"]:\n            package.authors.append(author)\n\n        for maintainer in local_config.get(\"maintainers\", []):\n            package.maintainers.append(maintainer)\n\n        package.description = local_config.get(\"description\", \"\")\n        package.homepage = local_config.get(\"homepage\")\n        package.repository_url = local_config.get(\"repository\")\n        package.documentation_url = local_config.get(\"documentation\")\n        try:\n            license_ = license_by_id(local_config.get(\"license\", \"\"))\n        except ValueError:\n            license_ = None\n\n        package.license = license_\n        package.keywords = local_config.get(\"keywords\", [])\n        package.classifiers = local_config.get(\"classifiers\", [])\n\n        if \"readme\" in local_config:\n            package.readme = Path(poetry_file.parent) / local_config[\"readme\"]\n\n        if \"platform\" in local_config:\n            package.platform = local_config[\"platform\"]\n\n        if \"dependencies\" in local_config:\n            for name, constraint in local_config[\"dependencies\"].items():\n                if name.lower() == \"python\":\n                    package.python_versions = constraint\n                    continue\n\n                if isinstance(constraint, list):\n                    for _constraint in constraint:\n                        package.add_dependency(name, _constraint)\n\n                    continue\n\n                package.add_dependency(name, constraint)\n\n        if \"dev-dependencies\" in local_config:\n            for name, constraint in local_config[\"dev-dependencies\"].items():\n                if isinstance(constraint, list):\n                    for _constraint in constraint:\n                        package.add_dependency(name, _constraint, category=\"dev\")\n\n                    continue\n\n                package.add_dependency(name, constraint, category=\"dev\")\n\n        extras = local_config.get(\"extras\", {})\n        for extra_name, requirements in extras.items():\n            package.extras[extra_name] = []\n\n            # Checking for dependency\n            for req in requirements:\n                req = Dependency(req, \"*\")\n\n                for dep in package.requires:\n                    if dep.name == req.name:\n                        dep.in_extras.append(extra_name)\n                        package.extras[extra_name].append(dep)\n\n                        break\n\n        if \"build\" in local_config:\n            package.build = local_config[\"build\"]\n\n        if \"include\" in local_config:\n            package.include = local_config[\"include\"]\n\n        if \"exclude\" in local_config:\n            package.exclude = local_config[\"exclude\"]\n\n        if \"packages\" in local_config:\n            package.packages = local_config[\"packages\"]\n\n        # Custom urls\n        if \"urls\" in local_config:\n            package.custom_urls = local_config[\"urls\"]\n\n        # Moving lock if necessary (pyproject.lock -> poetry.lock)\n        lock = poetry_file.parent / \"poetry.lock\"\n        if not lock.exists():\n            # Checking for pyproject.lock\n            old_lock = poetry_file.with_suffix(\".lock\")\n            if old_lock.exists():\n                shutil.move(str(old_lock), str(lock))\n\n        locker = Locker(poetry_file.parent / \"poetry.lock\", local_config)\n\n        config = Config()\n        # Load global config\n        config_file = TomlFile(Path(CONFIG_DIR) / \"config.toml\")\n        if config_file.exists():\n            config.merge(config_file.read())\n\n        local_config_file = TomlFile(poetry_file.parent / \"poetry.toml\")\n        if local_config_file.exists():\n            config.merge(local_config_file.read())\n\n        # Load global auth config\n        auth_config_file = TomlFile(Path(CONFIG_DIR) / \"auth.toml\")\n        if auth_config_file.exists():\n            config.merge(auth_config_file.read())\n\n        return cls(poetry_file, local_config, package, locker, config)\n    def __init__(\n        self,\n        file,  # type: Path\n        local_config,  # type: dict\n        package,  # type: Package\n        locker,  # type: Locker\n        config,  # type: Config\n    ):\n        self._file = TomlFile(file)\n        self._package = package\n        self._local_config = local_config\n        self._locker = locker\n        self._config = config\n\n        # Configure sources\n        self._pool = Pool()\n        for source in self._local_config.get(\"source\", []):\n            repository = self.create_legacy_repository(source)\n            self._pool.add_repository(\n                repository,\n                source.get(\"default\", False),\n                secondary=source.get(\"secondary\", False),\n            )\n\n        # Always put PyPI last to prefer private repositories\n        # but only if we have no other default source\n        if not self._pool.has_default():\n            self._pool.add_repository(PyPiRepository(), True)",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 131,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}