{
  "code": "def register(self, app, options):\n        \"\"\"\n        Register the blueprint to the sanic app.\n\n        :param app: Instance of :class:`sanic.app.Sanic` class\n        :param options: Options to be used while registering the\n            blueprint into the app.\n            *url_prefix* - URL Prefix to override the blueprint prefix\n        \"\"\"\n\n        self._apps.add(app)\n        url_prefix = options.get(\"url_prefix\", self.url_prefix)\n        opt_version = options.get(\"version\", None)\n        opt_strict_slashes = options.get(\"strict_slashes\", None)\n        opt_version_prefix = options.get(\"version_prefix\", self.version_prefix)\n        opt_name_prefix = options.get(\"name_prefix\", None)\n        error_format = options.get(\n            \"error_format\", app.config.FALLBACK_ERROR_FORMAT\n        )\n\n        routes = []\n        middleware = []\n        exception_handlers = []\n        listeners = defaultdict(list)\n        registered = set()\n\n        # Routes\n        for future in self._future_routes:\n            # Prepend the blueprint URI prefix if available\n            uri = self._setup_uri(future.uri, url_prefix)\n\n            version_prefix = self.version_prefix\n            for prefix in (\n                future.version_prefix,\n                opt_version_prefix,\n            ):\n                if prefix and prefix != \"/v\":\n                    version_prefix = prefix\n                    break\n\n            version = self._extract_value(\n                future.version, opt_version, self.version\n            )\n            strict_slashes = self._extract_value(\n                future.strict_slashes, opt_strict_slashes, self.strict_slashes\n            )\n\n            name = future.name\n            if opt_name_prefix:\n                name = f\"{opt_name_prefix}_{future.name}\"\n            name = app._generate_name(name)\n            host = future.host or self.host\n            if isinstance(host, list):\n                host = tuple(host)\n\n            apply_route = FutureRoute(\n                future.handler,\n                uri,\n                future.methods,\n                host,\n                strict_slashes,\n                future.stream,\n                version,\n                name,\n                future.ignore_body,\n                future.websocket,\n                future.subprotocols,\n                future.unquote,\n                future.static,\n                version_prefix,\n                error_format,\n                future.route_context,\n            )\n\n            if (self, apply_route) in app._future_registry:\n                continue\n\n            registered.add(apply_route)\n            route = app._apply_route(\n                apply_route, overwrite=self._allow_route_overwrite\n            )\n\n            # If it is a copied BP, then make sure all of the names of routes\n            # matchup with the new BP name\n            if self.copied_from:\n                for r in route:\n                    r.name = r.name.replace(self.copied_from, self.name)\n                    r.extra.ident = r.extra.ident.replace(\n                        self.copied_from, self.name\n                    )\n\n            operation = (\n                routes.extend if isinstance(route, list) else routes.append\n            )\n            operation(route)\n\n        # Static Files\n        for future in self._future_statics:\n            # Prepend the blueprint URI prefix if available\n            uri = self._setup_uri(future.uri, url_prefix)\n            apply_route = FutureStatic(uri, *future[1:])\n\n            if (self, apply_route) in app._future_registry:\n                continue\n\n            registered.add(apply_route)\n            route = app._apply_static(apply_route)\n            routes.append(route)\n\n        route_names = [route.name for route in routes if route]\n\n        if route_names:\n            # Middleware\n            for future in self._future_middleware:\n                if (self, future) in app._future_registry:\n                    continue\n                middleware.append(app._apply_middleware(future, route_names))\n\n            # Exceptions\n            for future in self._future_exceptions:\n                if (self, future) in app._future_registry:\n                    continue\n                exception_handlers.append(\n                    app._apply_exception_handler(future, route_names)\n                )\n\n        # Event listeners\n        for future in self._future_listeners:\n            if (self, future) in app._future_registry:\n                continue\n            listeners[future.event].append(app._apply_listener(future))\n\n        # Signals\n        for future in self._future_signals:\n            if (self, future) in app._future_registry:\n                continue\n            future.condition.update({\"__blueprint__\": self.name})\n            # Force exclusive to be False\n            app._apply_signal(tuple((*future[:-1], False)))\n\n        self.routes += [route for route in routes if isinstance(route, Route)]\n        self.websocket_routes += [\n            route for route in self.routes if route.extra.websocket\n        ]\n        self.middlewares += middleware\n        self.exceptions += exception_handlers\n        self.listeners.update(dict(listeners))\n\n        if self.registered:\n            self.register_futures(\n                self.apps,\n                self,\n                chain(\n                    registered,\n                    self._future_middleware,\n                    self._future_exceptions,\n                    self._future_listeners,\n                    self._future_signals,\n                ),\n            )\n def __new__(*args, **kwargs):\n        if not args:\n            raise TypeError('NamedTuple.__new__(): not enough arguments')\n        cls, *args = args  # allow the \"cls\" keyword be passed\n        if args:\n            typename, *args = args # allow the \"typename\" keyword be passed\n        elif 'typename' in kwargs:\n            typename = kwargs.pop('typename')\n            import warnings\n            warnings.warn(\"Passing 'typename' as keyword argument is deprecated\",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            raise TypeError(\"NamedTuple.__new__() missing 1 required positional \"\n                            \"argument: 'typename'\")\n        if args:\n            try:\n                fields, = args # allow the \"fields\" keyword be passed\n            except ValueError:\n                raise TypeError(f'NamedTuple.__new__() takes from 2 to 3 '\n                                f'positional arguments but {len(args) + 2} '\n                                f'were given') from None\n        elif 'fields' in kwargs and len(kwargs) == 1:\n            fields = kwargs.pop('fields')\n            import warnings\n            warnings.warn(\"Passing 'fields' as keyword argument is deprecated\",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            fields = None\n\n        if fields is None:\n            fields = kwargs.items()\n        elif kwargs:\n            raise TypeError(\"Either list of fields or keywords\"\n                            \" can be provided to NamedTuple, not both\")\n        return _make_nmtuple(typename, fields)\n    __new__.__text_signature__ = '($cls, typename, fields=None, /, **kwargs)'",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 101,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}