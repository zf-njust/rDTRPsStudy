{
  "code": "def update_local_uin(core, msg):\n    '''\n        content contains uins and StatusNotifyUserName contains username\n        they are in same order, so what I do is to pair them together\n\n        I caught an exception in this method while not knowing why\n        but don't worry, it won't cause any problem\n    '''\n    uins = re.search('<username>([^<]*?)<', msg['Content'])\n    usernameChangedList = []\n    r = {\n        'Type': 'System',\n        'Text': usernameChangedList,\n        'SystemInfo': 'uins', }\n    if uins:\n        uins = uins.group(1).split(',')\n        usernames = msg['StatusNotifyUserName'].split(',')\n        if 0 < len(uins) == len(usernames):\n            for uin, username in zip(uins, usernames):\n                if not '@' in username: continue\n                fullContact = core.memberList + core.chatroomList + core.mpList\n                userDicts = utils.search_dict_list(fullContact,\n                    'UserName', username)\n                if userDicts:\n                    if userDicts.get('Uin', 0) == 0:\n                        userDicts['Uin'] = uin\n                        usernameChangedList.append(username)\n                        logger.debug('Uin fetched: %s, %s' % (username, uin))\n                    else:\n                        if userDicts['Uin'] != uin:\n                            logger.debug('Uin changed: %s, %s' % (\n                                userDicts['Uin'], uin))\n                else:\n                    if '@@' in username:\n                        core.storageClass.updateLock.release()\n                        update_chatroom(core, username)\n                        core.storageClass.updateLock.acquire()\n                        newChatroomDict = utils.search_dict_list(\n                            core.chatroomList, 'UserName', username)\n                        if newChatroomDict is None:\n                            newChatroomDict = utils.struct_friend_info({\n                                'UserName': username,\n                                'Uin': uin, \n                                'Self': copy.deepcopy(core.loginInfo['User'])})\n                            core.chatroomList.append(newChatroomDict)\n                        else:\n                            newChatroomDict['Uin'] = uin\n                    elif '@' in username:\n                        core.storageClass.updateLock.release()\n                        update_friend(core, username)\n                        core.storageClass.updateLock.acquire()\n                        newFriendDict = utils.search_dict_list(\n                            core.memberList, 'UserName', username)\n                        if newFriendDict is None:\n                            newFriendDict = utils.struct_friend_info({\n                                'UserName': username,\n                                'Uin': uin, })\n                            core.memberList.append(newFriendDict)\n                        else:\n                            newFriendDict['Uin'] = uin\n                    usernameChangedList.append(username)\n                    logger.debug('Uin fetched: %s, %s' % (username, uin))\n        else:\n            logger.debug('Wrong length of uins & usernames: %s, %s' % (\n                len(uins), len(usernames)))\n    else:\n        logger.debug('No uins in 51 message')\n        logger.debug(msg['Content'])\n    return r\ndef len(*args, **kwargs): # real signature unknown\n    \"\"\" Return the number of items in a container. \"\"\"\n    pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 18,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}