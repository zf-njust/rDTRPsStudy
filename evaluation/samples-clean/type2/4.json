{
  "code": "    def __init__(self, fmt=DEFAULT_FORMAT, datefmt=DEFAULT_DATE_FORMAT,\n                 style='%', color=True, colors=DEFAULT_COLORS):\n        r\"\"\"\n        :arg bool color: Enables color support.\n        :arg str fmt: Log message format.\n          It will be applied to the attributes dict of log records. The\n          text between ``%(color)s`` and ``%(end_color)s`` will be colored\n          depending on the level if color support is on.\n        :arg dict colors: color mappings from logging level to terminal color\n          code\n        :arg str datefmt: Datetime format.\n          Used for formatting ``(asctime)`` placeholder in ``prefix_fmt``.\n\n        .. versionchanged:: 3.2\n\n           Added ``fmt`` and ``datefmt`` arguments.\n        \"\"\"\n        logging.Formatter.__init__(self, datefmt=datefmt)\n        self._fmt = fmt\n\n        self._colors = {}\n        if color and _stderr_supports_color():\n            if curses is not None:\n                # The curses module has some str/bytes confusion in\n                # python3.  Until version 3.2.3, most methods return\n                # bytes, but only accept strings.  In addition, we want to\n                # output these strings with the logging module, which\n                # works with unicode strings.  The explicit calls to\n                # unicode() below are harmless in python2 but will do the\n                # right conversion in python 3.\n                fg_color = (curses.tigetstr(\"setaf\") or\n                            curses.tigetstr(\"setf\") or \"\")\n                if (3, 0) < sys.version_info < (3, 2, 3):\n                    fg_color = unicode_type(fg_color, \"ascii\")\n\n                for levelno, code in colors.items():\n                    self._colors[levelno] = unicode_type(curses.tparm(fg_color, code), \"ascii\")\n                self._normal = unicode_type(curses.tigetstr(\"sgr0\"), \"ascii\")\n            else:\n                # If curses is not present (currently we'll only get here for\n                # colorama on windows), assume hard-coded ANSI color codes.\n                for levelno, code in colors.items():\n                    self._colors[levelno] = '\\033[2;3%dm' % code\n                self._normal = '\\033[0m'\n        else:\n            self._normal = ''",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 37,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}