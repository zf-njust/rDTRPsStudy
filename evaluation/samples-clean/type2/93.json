{
  "code": "def __init__(self,\n                 num_classes: int,\n                 in_channels: int,\n                 point_feat_channels: int = 256,\n                 num_points: int = 9,\n                 gradient_mul: float = 0.1,\n                 point_strides: Sequence[int] = [8, 16, 32, 64, 128],\n                 point_base_scale: int = 4,\n                 loss_cls: ConfigType = dict(\n                     type='FocalLoss',\n                     use_sigmoid=True,\n                     gamma=2.0,\n                     alpha=0.25,\n                     loss_weight=1.0),\n                 loss_bbox_init: ConfigType = dict(\n                     type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=0.5),\n                 loss_bbox_refine: ConfigType = dict(\n                     type='SmoothL1Loss', beta=1.0 / 9.0, loss_weight=1.0),\n                 use_grid_points: bool = False,\n                 center_init: bool = True,\n                 transform_method: str = 'moment',\n                 moment_mul: float = 0.01,\n                 init_cfg: MultiConfig = dict(\n                     type='Normal',\n                     layer='Conv2d',\n                     std=0.01,\n                     override=dict(\n                         type='Normal',\n                         name='reppoints_cls_out',\n                         std=0.01,\n                         bias_prob=0.01)),\n                 **kwargs) -> None:\n        self.num_points = num_points\n        self.point_feat_channels = point_feat_channels\n        self.use_grid_points = use_grid_points\n        self.center_init = center_init\n\n        # we use deform conv to extract points features\n        self.dcn_kernel = int(np.sqrt(num_points))\n        self.dcn_pad = int((self.dcn_kernel - 1) / 2)\n        assert self.dcn_kernel * self.dcn_kernel == num_points, \\\n            'The points number should be a square number.'\n        assert self.dcn_kernel % 2 == 1, \\\n            'The points number should be an odd square number.'\n        dcn_base = np.arange(-self.dcn_pad,\n                             self.dcn_pad + 1).astype(np.float64)\n        dcn_base_y = np.repeat(dcn_base, self.dcn_kernel)\n        dcn_base_x = np.tile(dcn_base, self.dcn_kernel)\n        dcn_base_offset = np.stack([dcn_base_y, dcn_base_x], axis=1).reshape(\n            (-1))\n        self.dcn_base_offset = torch.tensor(dcn_base_offset).view(1, -1, 1, 1)\n\n        super().__init__(\n            num_classes=num_classes,\n            in_channels=in_channels,\n            loss_cls=loss_cls,\n            init_cfg=init_cfg,\n            **kwargs)\n\n        self.gradient_mul = gradient_mul\n        self.point_base_scale = point_base_scale\n        self.point_strides = point_strides\n        self.prior_generator = MlvlPointGenerator(\n            self.point_strides, offset=0.)\n\n        if self.train_cfg:\n            self.init_assigner = TASK_UTILS.build(\n                self.train_cfg['init']['assigner'])\n            self.refine_assigner = TASK_UTILS.build(\n                self.train_cfg['refine']['assigner'])\n\n            if self.train_cfg.get('sampler', None) is not None:\n                self.sampler = TASK_UTILS.build(\n                    self.train_cfg['sampler'], default_args=dict(context=self))\n            else:\n                self.sampler = PseudoSampler(context=self)\n\n        self.transform_method = transform_method\n        if self.transform_method == 'moment':\n            self.moment_transfer = nn.Parameter(\n                data=torch.zeros(2), requires_grad=True)\n            self.moment_mul = moment_mul\n\n        self.use_sigmoid_cls = loss_cls.get('use_sigmoid', False)\n        if self.use_sigmoid_cls:\n            self.cls_out_channels = self.num_classes\n        else:\n            self.cls_out_channels = self.num_classes + 1\n        self.loss_bbox_init = MODELS.build(loss_bbox_init)\n        self.loss_bbox_refine = MODELS.build(loss_bbox_refine)\n    def __init__(self,\n                 strides: Union[List[int], List[Tuple[int, int]]],\n                 offset: float = 0.5) -> None:\n        self.strides = [_pair(stride) for stride in strides]\n        self.offset = offset",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 64,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}