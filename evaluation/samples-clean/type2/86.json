{
  "code": "def check_funcs_once(self, funcs,\n                   headers=None, include_dirs=None,\n                   libraries=None, library_dirs=None,\n                   decl=False, call=False, call_args=None):\n        \"\"\"Check a list of functions at once.\n\n        This is useful to speed up things, since all the functions in the funcs\n        list will be put in one compilation unit.\n\n        Arguments\n        ---------\n        funcs : seq\n            list of functions to test\n        include_dirs : seq\n            list of header paths\n        libraries : seq\n            list of libraries to link the code snippet to\n        libraru_dirs : seq\n            list of library paths\n        decl : dict\n            for every (key, value), the declaration in the value will be\n            used for function in key. If a function is not in the\n            dictionay, no declaration will be used.\n        call : dict\n            for every item (f, value), if the value is True, a call will be\n            done to the function f.\n        \"\"\"\n        self._check_compiler()\n        body = []\n        if decl:\n            for f, v in decl.items():\n                if v:\n                    body.append(\"int %s (void);\" % f)\n\n        # Handle MS intrinsics. See check_func for more info.\n        body.append(\"#ifdef _MSC_VER\")\n        for func in funcs:\n            body.append(\"#pragma function(%s)\" % func)\n        body.append(\"#endif\")\n\n        body.append(\"int main (void) {\")\n        if call:\n            for f in funcs:\n                if f in call and call[f]:\n                    if not (call_args and f in call_args and call_args[f]):\n                        args = ''\n                    else:\n                        args = call_args[f]\n                    body.append(\"  %s(%s);\" % (f, args))\n                else:\n                    body.append(\"  %s;\" % f)\n        else:\n            for f in funcs:\n                body.append(\"  %s;\" % f)\n        body.append(\"  return 0;\")\n        body.append(\"}\")\n        body = '\\n'.join(body) + \"\\n\"\n\n        return self.try_link(body, headers, include_dirs,\n                             libraries, library_dirs)\n    def try_link(self, body, headers=None, include_dirs=None, libraries=None,\n                 library_dirs=None, lang=\"c\"):\n        \"\"\"Try to compile and link a source file, built from 'body' and\n        'headers', to executable form.  Return true on success, false\n        otherwise.\n        \"\"\"\n        from distutils.ccompiler import CompileError, LinkError\n        self._check_compiler()\n        try:\n            self._link(body, headers, include_dirs,\n                       libraries, library_dirs, lang)\n            ok = True\n        except (CompileError, LinkError):\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 59,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}