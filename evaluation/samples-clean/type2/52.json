{
  "code": "def get_ca_certs(self):\n        # tries to find a valid CA cert in one of the\n        # standard locations for the current distribution\n\n        ca_certs = []\n        paths_checked = []\n\n        system = platform.system()\n        # build a list of paths to check for .crt/.pem files\n        # based on the platform type\n        paths_checked.append('/etc/ssl/certs')\n        if system == 'Linux':\n            paths_checked.append('/etc/pki/ca-trust/extracted/pem')\n            paths_checked.append('/etc/pki/tls/certs')\n            paths_checked.append('/usr/share/ca-certificates/cacert.org')\n        elif system == 'FreeBSD':\n            paths_checked.append('/usr/local/share/certs')\n        elif system == 'OpenBSD':\n            paths_checked.append('/etc/ssl')\n        elif system == 'NetBSD':\n            ca_certs.append('/etc/openssl/certs')\n        elif system == 'SunOS':\n            paths_checked.append('/opt/local/etc/openssl/certs')\n\n        # fall back to a user-deployed cert in a standard\n        # location if the OS platform one is not available\n        paths_checked.append('/etc/ansible')\n\n        tmp_fd, tmp_path = tempfile.mkstemp()\n\n        # Write the dummy ca cert if we are running on Mac OS X\n        if system == 'Darwin':\n            os.write(tmp_fd, DUMMY_CA_CERT)\n            # Default Homebrew path for OpenSSL certs\n            paths_checked.append('/usr/local/etc/openssl')\n\n        # for all of the paths, find any  .crt or .pem files\n        # and compile them into single temp file for use\n        # in the ssl check to speed up the test\n        for path in paths_checked:\n            if os.path.exists(path) and os.path.isdir(path):\n                dir_contents = os.listdir(path)\n                for f in dir_contents:\n                    full_path = os.path.join(path, f)\n                    if os.path.isfile(full_path) and os.path.splitext(f)[1] in ('.crt','.pem'):\n                        try:\n                            cert_file = open(full_path, 'rb')\n                            os.write(tmp_fd, cert_file.read())\n                            os.write(tmp_fd, b('\\n'))\n                            cert_file.close()\n                        except (OSError, IOError):\n                            pass\n\n        return (tmp_path, paths_checked)\ndef write(*args, **kwargs): # real signature unknown\n    \"\"\" Write a bytes object to a file descriptor. \"\"\"\n    pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 33,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}