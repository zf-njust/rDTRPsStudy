{
  "code": "def create_classification_export_module(\n    params: cfg.ExperimentConfig,\n    input_type: str,\n    batch_size: int,\n    input_image_size: List[int],\n    num_channels: int = 3,\n    input_name: Optional[str] = None) -> ExportModule:\n  \"\"\"Creates classification export module.\"\"\"\n  input_signature = export_utils.get_image_input_signatures(\n      input_type, batch_size, input_image_size, num_channels, input_name)\n  input_specs = tf.keras.layers.InputSpec(shape=[batch_size] +\n                                          input_image_size + [num_channels])\n\n  model = factory.build_classification_model(\n      input_specs=input_specs,\n      model_config=params.task.model,\n      l2_regularizer=None)\n\n  def preprocess_fn(inputs):\n    image_tensor = export_utils.parse_image(inputs, input_type,\n                                            input_image_size, num_channels)\n    # If input_type is `tflite`, do not apply image preprocessing.\n    if input_type == 'tflite':\n      return image_tensor\n\n    def preprocess_image_fn(inputs):\n      return classification_input.Parser.inference_fn(inputs, input_image_size,\n                                                      num_channels)\n\n    images = tf.map_fn(\n        preprocess_image_fn,\n        elems=image_tensor,\n        fn_output_signature=tf.TensorSpec(\n            shape=input_image_size + [num_channels], dtype=tf.float32))\n\n    return images\n\n  def postprocess_fn(logits):\n    probs = tf.nn.softmax(logits)\n    return {'logits': logits, 'probs': probs}\n\n  export_module = ExportModule(\n      params,\n      model=model,\n      input_signature=input_signature,\n      preprocessor=preprocess_fn,\n      postprocessor=postprocess_fn)\n  return export_module\ndef build_classification_model(\n    input_specs: tf.keras.layers.InputSpec,\n    model_config: classification_cfg.ImageClassificationModel,\n    l2_regularizer: Optional[tf.keras.regularizers.Regularizer] = None,\n    skip_logits_layer: bool = False,\n    backbone: Optional[tf.keras.Model] = None) -> tf.keras.Model:\n  \"\"\"Builds the classification model.\"\"\"\n  norm_activation_config = model_config.norm_activation\n  if not backbone:\n    backbone = backbones.factory.build_backbone(\n        input_specs=input_specs,\n        backbone_config=model_config.backbone,\n        norm_activation_config=norm_activation_config,\n        l2_regularizer=l2_regularizer)\n\n  model = classification_model.ClassificationModel(\n      backbone=backbone,\n      num_classes=model_config.num_classes,\n      input_specs=input_specs,\n      dropout_rate=model_config.dropout_rate,\n      kernel_initializer=model_config.kernel_initializer,\n      kernel_regularizer=l2_regularizer,\n      add_head_batch_norm=model_config.add_head_batch_norm,\n      use_sync_bn=norm_activation_config.use_sync_bn,\n      norm_momentum=norm_activation_config.norm_momentum,\n      norm_epsilon=norm_activation_config.norm_epsilon,\n      skip_logits_layer=skip_logits_layer)\n  return model",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 16,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}