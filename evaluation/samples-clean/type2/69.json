{
  "code": "def _read_old_header(self, first_char):\n        self.format_version = struct.unpack('b', first_char)[0]\n        if self.format_version not in [104, 105, 108, 113, 114, 115]:\n            raise ValueError(_version_error)\n        self.byteorder = struct.unpack('b', self.path_or_buf.read(1))[0] == 0x1 and '>' or '<'\n        self.filetype = struct.unpack('b', self.path_or_buf.read(1))[0]\n        self.path_or_buf.read(1)  # unused\n\n        self.nvar = struct.unpack(self.byteorder + 'H',\n                                  self.path_or_buf.read(2))[0]\n        self.nobs = self._get_nobs()\n\n        self.data_label = self._get_data_label()\n\n        self.time_stamp = self._get_time_stamp()\n\n        # descriptors\n        if self.format_version > 108:\n            typlist = [ord(self.path_or_buf.read(1))\n                       for i in range(self.nvar)]\n        else:\n            typlist = [\n                self.OLD_TYPE_MAPPING[\n                    self._decode_bytes(self.path_or_buf.read(1))\n                ] for i in range(self.nvar)\n            ]\n\n        try:\n            self.typlist = [self.TYPE_MAP[typ] for typ in typlist]\n        except:\n            raise ValueError(\"cannot convert stata types [{0}]\"\n                             .format(','.join(typlist)))\n        try:\n            self.dtyplist = [self.DTYPE_MAP[typ] for typ in typlist]\n        except:\n            raise ValueError(\"cannot convert stata dtypes [{0}]\"\n                             .format(','.join(typlist)))\n\n        if self.format_version > 108:\n            self.varlist = [self._null_terminate(self.path_or_buf.read(33))\n                            for i in range(self.nvar)]\n        else:\n            self.varlist = [self._null_terminate(self.path_or_buf.read(9))\n                            for i in range(self.nvar)]\n        self.srtlist = struct.unpack(\n            self.byteorder + ('h' * (self.nvar + 1)),\n            self.path_or_buf.read(2 * (self.nvar + 1))\n        )[:-1]\n\n        self.fmtlist = self._get_fmtlist()\n\n        self.lbllist = self._get_lbllist()\n\n        self.vlblist = self._get_vlblist()\n\n        # ignore expansion fields (Format 105 and later)\n        # When reading, read five bytes; the last four bytes now tell you\n        # the size of the next read, which you discard.  You then continue\n        # like this until you read 5 bytes of zeros.\n\n        if self.format_version > 104:\n            while True:\n                data_type = struct.unpack(self.byteorder + 'b',\n                                          self.path_or_buf.read(1))[0]\n                if self.format_version > 108:\n                    data_len = struct.unpack(self.byteorder + 'i',\n                                             self.path_or_buf.read(4))[0]\n                else:\n                    data_len = struct.unpack(self.byteorder + 'h',\n                                             self.path_or_buf.read(2))[0]\n                if data_type == 0:\n                    break\n                self.path_or_buf.read(data_len)\n\n        # necessary data to continue parsing\n        self.data_location = self.path_or_buf.tell()\n    def join(self, ab=None, pq=None, rs=None): # real signature unknown; restored from __doc__\n        \"\"\"\n        Concatenate any number of strings.\n        \n        The string whose method is called is inserted in between each given string.\n        The result is returned as a new string.\n        \n        Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'\n        \"\"\"\n        pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 32,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}