{
  "code": "def check_types(config_cmd, ext, build_dir):\n    private_defines = []\n    public_defines = []\n\n    # Expected size (in number of bytes) for each type. This is an\n    # optimization: those are only hints, and an exhaustive search for the size\n    # is done if the hints are wrong.\n    expected = {}\n    expected['short'] = [2]\n    expected['int'] = [4]\n    expected['long'] = [8, 4]\n    expected['float'] = [4]\n    expected['double'] = [8]\n    expected['long double'] = [16, 12, 8]\n    expected['Py_intptr_t'] = [8, 4]\n    expected['PY_LONG_LONG'] = [8]\n    expected['long long'] = [8]\n    expected['off_t'] = [8, 4]\n\n    # Check we have the python header (-dev* packages on Linux)\n    result = config_cmd.check_header('Python.h')\n    if not result:\n        raise SystemError(\n                \"Cannot compile 'Python.h'. Perhaps you need to \"\n                \"install python-dev|python-devel.\")\n    res = config_cmd.check_header(\"endian.h\")\n    if res:\n        private_defines.append(('HAVE_ENDIAN_H', 1))\n        public_defines.append(('NPY_HAVE_ENDIAN_H', 1))\n\n    # Check basic types sizes\n    for type in ('short', 'int', 'long'):\n        res = config_cmd.check_decl(\"SIZEOF_%s\" % sym2def(type), headers=[\"Python.h\"])\n        if res:\n            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type), \"SIZEOF_%s\" % sym2def(type)))\n        else:\n            res = config_cmd.check_type_size(type, expected=expected[type])\n            if res >= 0:\n                public_defines.append(('NPY_SIZEOF_%s' % sym2def(type), '%d' % res))\n            else:\n                raise SystemError(\"Checking sizeof (%s) failed !\" % type)\n\n    for type in ('float', 'double', 'long double'):\n        already_declared = config_cmd.check_decl(\"SIZEOF_%s\" % sym2def(type),\n                                                 headers=[\"Python.h\"])\n        res = config_cmd.check_type_size(type, expected=expected[type])\n        if res >= 0:\n            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type), '%d' % res))\n            if not already_declared and not type == 'long double':\n                private_defines.append(('SIZEOF_%s' % sym2def(type), '%d' % res))\n        else:\n            raise SystemError(\"Checking sizeof (%s) failed !\" % type)\n\n        # Compute size of corresponding complex type: used to check that our\n        # definition is binary compatible with C99 complex type (check done at\n        # build time in npy_common.h)\n        complex_def = \"struct {%s __x; %s __y;}\" % (type, type)\n        res = config_cmd.check_type_size(complex_def,\n                                         expected=[2 * x for x in expected[type]])\n        if res >= 0:\n            public_defines.append(('NPY_SIZEOF_COMPLEX_%s' % sym2def(type), '%d' % res))\n        else:\n            raise SystemError(\"Checking sizeof (%s) failed !\" % complex_def)\n\n    for type in ('Py_intptr_t', 'off_t'):\n        res = config_cmd.check_type_size(type, headers=[\"Python.h\"],\n                library_dirs=[pythonlib_dir()],\n                expected=expected[type])\n\n        if res >= 0:\n            private_defines.append(('SIZEOF_%s' % sym2def(type), '%d' % res))\n            public_defines.append(('NPY_SIZEOF_%s' % sym2def(type), '%d' % res))\n        else:\n            raise SystemError(\"Checking sizeof (%s) failed !\" % type)\n\n    # We check declaration AND type because that's how distutils does it.\n    if config_cmd.check_decl('PY_LONG_LONG', headers=['Python.h']):\n        res = config_cmd.check_type_size('PY_LONG_LONG',  headers=['Python.h'],\n                library_dirs=[pythonlib_dir()],\n                expected=expected['PY_LONG_LONG'])\n        if res >= 0:\n            private_defines.append(('SIZEOF_%s' % sym2def('PY_LONG_LONG'), '%d' % res))\n            public_defines.append(('NPY_SIZEOF_%s' % sym2def('PY_LONG_LONG'), '%d' % res))\n        else:\n            raise SystemError(\"Checking sizeof (%s) failed !\" % 'PY_LONG_LONG')\n\n        res = config_cmd.check_type_size('long long',\n                expected=expected['long long'])\n        if res >= 0:\n            #private_defines.append(('SIZEOF_%s' % sym2def('long long'), '%d' % res))\n            public_defines.append(('NPY_SIZEOF_%s' % sym2def('long long'), '%d' % res))\n        else:\n            raise SystemError(\"Checking sizeof (%s) failed !\" % 'long long')\n\n    if not config_cmd.check_decl('CHAR_BIT', headers=['Python.h']):\n        raise RuntimeError(\n            \"Config wo CHAR_BIT is not supported\"\n            \", please contact the maintainers\")\n\n    return private_defines, public_defines\n    def append(self, *args, **kwargs): # real signature unknown\n        \"\"\" Append object to the end of the list. \"\"\"\n        pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 50,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}