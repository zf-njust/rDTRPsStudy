{
  "code": "def tblr2bboxes(priors: Tensor,\n                tblr: Tensor,\n                normalizer: Union[Sequence[float], float] = 4.0,\n                normalize_by_wh: bool = True,\n                max_shape: Optional[Union[Sequence[int], Tensor,\n                                          Sequence[Sequence[int]]]] = None,\n                clip_border: bool = True) -> Tensor:\n    \"\"\"Decode tblr outputs to prediction boxes.\n\n    The process includes 3 steps: 1) De-normalize tblr coordinates by\n    multiplying it with `normalizer`; 2) De-normalize tblr coordinates by the\n    prior bbox width and height if `normalize_by_wh` is `True`; 3) Convert\n    tblr (top, bottom, left, right) pair relative to the center of priors back\n    to (xmin, ymin, xmax, ymax) coordinate.\n\n    Args:\n        priors (Tensor): Prior boxes in point form (x0, y0, x1, y1)\n          Shape: (N,4) or (B, N, 4).\n        tblr (Tensor): Coords of network output in tblr form\n          Shape: (N, 4) or (B, N, 4).\n        normalizer (Sequence[float] | float): Normalization parameter of\n          encoded boxes. By list, it represents the normalization factors at\n          tblr dims. By float, it is the unified normalization factor at all\n          dims. Default: 4.0\n        normalize_by_wh (bool): Whether the tblr coordinates have been\n          normalized by the side length (wh) of prior bboxes.\n        max_shape (Sequence[int] or torch.Tensor or Sequence[\n            Sequence[int]],optional): Maximum bounds for boxes, specifies\n            (H, W, C) or (H, W). If priors shape is (B, N, 4), then\n            the max_shape should be a Sequence[Sequence[int]]\n            and the length of max_shape should also be B.\n        clip_border (bool, optional): Whether clip the objects outside the\n            border of the image. Defaults to True.\n\n    Return:\n        encoded boxes (Tensor): Boxes with shape (N, 4) or (B, N, 4)\n    \"\"\"\n    if not isinstance(normalizer, float):\n        normalizer = torch.tensor(normalizer, device=priors.device)\n        assert len(normalizer) == 4, 'Normalizer must have length = 4'\n    assert priors.size(0) == tblr.size(0)\n    if priors.ndim == 3:\n        assert priors.size(1) == tblr.size(1)\n\n    loc_decode = tblr * normalizer\n    prior_centers = (priors[..., 0:2] + priors[..., 2:4]) / 2\n    if normalize_by_wh:\n        wh = priors[..., 2:4] - priors[..., 0:2]\n        w, h = torch.split(wh, 1, dim=-1)\n        # Inplace operation with slice would failed for exporting to ONNX\n        th = h * loc_decode[..., :2]  # tb\n        tw = w * loc_decode[..., 2:]  # lr\n        loc_decode = torch.cat([th, tw], dim=-1)\n    # Cannot be exported using onnx when loc_decode.split(1, dim=-1)\n    top, bottom, left, right = loc_decode.split((1, 1, 1, 1), dim=-1)\n    xmin = prior_centers[..., 0].unsqueeze(-1) - left\n    xmax = prior_centers[..., 0].unsqueeze(-1) + right\n    ymin = prior_centers[..., 1].unsqueeze(-1) - top\n    ymax = prior_centers[..., 1].unsqueeze(-1) + bottom\n\n    bboxes = torch.cat((xmin, ymin, xmax, ymax), dim=-1)\n\n    if clip_border and max_shape is not None:\n        # clip bboxes with dynamic `min` and `max` for onnx\n        if torch.onnx.is_in_onnx_export():\n            from mmdet.core.export import dynamic_clip_for_onnx\n            xmin, ymin, xmax, ymax = dynamic_clip_for_onnx(\n                xmin, ymin, xmax, ymax, max_shape)\n            bboxes = torch.cat([xmin, ymin, xmax, ymax], dim=-1)\n            return bboxes\n        if not isinstance(max_shape, torch.Tensor):\n            max_shape = priors.new_tensor(max_shape)\n        max_shape = max_shape[..., :2].type_as(priors)\n        if max_shape.ndim == 2:\n            assert bboxes.ndim == 3\n            assert max_shape.size(0) == bboxes.size(0)\n\n        min_xy = priors.new_tensor(0)\n        max_xy = torch.cat([max_shape, max_shape],\n                           dim=-1).flip(-1).unsqueeze(-2)\n        bboxes = torch.where(bboxes < min_xy, min_xy, bboxes)\n        bboxes = torch.where(bboxes > max_xy, max_xy, bboxes)\n\n    return bboxes\ndef len(*args, **kwargs): # real signature unknown\n    \"\"\" Return the number of items in a container. \"\"\"\n    pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 40,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}