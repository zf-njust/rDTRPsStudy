{
  "code": "def getargs(co):\n    \"\"\"Get information about the arguments accepted by a code object.\n\n    Three things are returned: (args, varargs, varkw), where 'args' is\n    a list of argument names (possibly containing nested lists), and\n    'varargs' and 'varkw' are the names of the * and ** arguments or None.\"\"\"\n    if not iscode(co):\n        raise TypeError('{!r} is not a code object'.format(co))\n\n    nargs = co.co_argcount\n    names = co.co_varnames\n    args = list(names[:nargs])\n    step = 0\n\n    # The following acrobatics are for anonymous (tuple) arguments.\n    for i in range(nargs):\n        if args[i][:1] in ('', '.'):\n            stack, remain, count = [], [], []\n            while step < len(co.co_code):\n                op = ord(co.co_code[step])\n                step = step + 1\n                if op >= dis.HAVE_ARGUMENT:\n                    opname = dis.opname[op]\n                    value = ord(co.co_code[step]) + ord(co.co_code[step+1])*256\n                    step = step + 2\n                    if opname in ('UNPACK_TUPLE', 'UNPACK_SEQUENCE'):\n                        remain.append(value)\n                        count.append(value)\n                    elif opname in ('STORE_FAST', 'STORE_DEREF'):\n                        if op in dis.haslocal:\n                            stack.append(co.co_varnames[value])\n                        elif op in dis.hasfree:\n                            stack.append((co.co_cellvars + co.co_freevars)[value])\n                        # Special case for sublists of length 1: def foo((bar))\n                        # doesn't generate the UNPACK_TUPLE bytecode, so if\n                        # `remain` is empty here, we have such a sublist.\n                        if not remain:\n                            stack[0] = [stack[0]]\n                            break\n                        else:\n                            remain[-1] = remain[-1] - 1\n                            while remain[-1] == 0:\n                                remain.pop()\n                                size = count.pop()\n                                stack[-size:] = [stack[-size:]]\n                                if not remain: break\n                                remain[-1] = remain[-1] - 1\n                            if not remain: break\n            args[i] = stack[0]\n\n    varargs = None\n    if co.co_flags & inspect.CO_VARARGS:\n        varargs = co.co_varnames[nargs]\n        nargs = nargs + 1\n    varkw = None\n    if co.co_flags & inspect.CO_VARKEYWORDS:\n        varkw = co.co_varnames[nargs]\n    return inspect.Arguments(args, varargs, varkw)\ndef ord(*args, **kwargs): # real signature unknown\n    \"\"\" Return the Unicode code point for a one-character string. \"\"\"\n    pass",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 20,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}