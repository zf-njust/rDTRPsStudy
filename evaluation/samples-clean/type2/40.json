{
  "code": "def generate_outputs(\n      self,\n      raw_scores: Dict[str, tf.Tensor],\n      raw_boxes: Dict[str, tf.Tensor],\n      raw_attributes: Dict[str, Dict[str, tf.Tensor]],\n      image_shape: Optional[tf.Tensor] = None,\n      anchor_boxes: Optional[Mapping[str, tf.Tensor]] = None,\n      generate_detections: bool = False) -> Mapping[str, Any]:\n    if not raw_attributes:\n      raise ValueError('PointPillars model needs attribute heads.')\n    # Clap heading to [-pi, pi]\n    if 'heading' in raw_attributes:\n      raw_attributes['heading'] = utils.clip_heading(raw_attributes['heading'])\n\n    outputs = {\n        'cls_outputs': raw_scores,\n        'box_outputs': raw_boxes,\n        'attribute_outputs': raw_attributes,\n    }\n    # Cast raw prediction to float32 for loss calculation.\n    outputs = tf.nest.map_structure(lambda x: tf.cast(x, tf.float32), outputs)\n    if not generate_detections:\n      return outputs\n\n    if image_shape is None:\n      raise ValueError('Image_shape should not be None for evaluation.')\n    if anchor_boxes is None:\n      # Generate anchors if needed.\n      anchor_boxes = utils.generate_anchors(\n          self._min_level,\n          self._max_level,\n          self._image_size,\n          self._anchor_sizes,\n      )\n      for l in anchor_boxes:\n        anchor_boxes[l] = tf.tile(\n            tf.expand_dims(anchor_boxes[l], axis=0),\n            [tf.shape(image_shape)[0], 1, 1, 1])\n\n    # Generate detected boxes.\n    if not self._detection_generator.get_config()['apply_nms']:\n      raise ValueError('An NMS algorithm is required for detection generator')\n    detections = self._detection_generator(raw_boxes, raw_scores,\n                                           anchor_boxes, image_shape,\n                                           raw_attributes)\n    outputs.update({\n        'boxes': detections['detection_boxes'],\n        'scores': detections['detection_scores'],\n        'classes': detections['detection_classes'],\n        'num_detections': detections['num_detections'],\n        'attributes': detections['detection_attributes'],\n    })\n    return outputs\ndef generate_anchors(min_level: int, max_level: int, image_size: Tuple[int],\n                     anchor_sizes: List[Tuple[float]]) -> Mapping[str, Any]:\n  \"\"\"Generate anchor boxes without scale to level stride.\n\n  Args:\n    min_level: integer number of minimum level of the output.\n    max_level: integer number of maximum level of the output.\n    image_size: a tuple (image_height, image_width).\n    anchor_sizes: a list of tuples, each tuple is (anchor_length, anchor_width).\n\n  Returns:\n    boxes_all: a {level: boxes_i} dict, each boxes_i is a [h_i, w_i, 4] tensor\n      for boxes at level i, each box is (ymin, xmin, ymax, xmax).\n\n  Notations:\n    k: length of anchor_sizes, the number of indicated anchors.\n    w: the image width at a specific level.\n    h: the image height at a specifc level.\n  \"\"\"\n  # Prepare k anchors' lengths and widths\n  k = len(anchor_sizes)\n  # (k,)\n  anchor_lengths = []\n  anchor_widths = []\n  for anchor_size in anchor_sizes:\n    anchor_lengths.append(anchor_size[0])\n    anchor_widths.append(anchor_size[1])\n  anchor_lengths = tf.convert_to_tensor(anchor_lengths, dtype=tf.float32)\n  anchor_widths = tf.convert_to_tensor(anchor_widths, dtype=tf.float32)\n  # (1, 1, k)\n  half_anchor_lengths = tf.reshape(0.5 * anchor_lengths, [1, 1, k])\n  half_anchor_widths = tf.reshape(0.5 * anchor_widths, [1, 1, k])\n\n  boxes_all = collections.OrderedDict()\n  for level in range(min_level, max_level + 1):\n    # Generate anchor boxes for this level with stride.\n    boxes_i = []\n    stride = 2 ** level\n    # (w,)\n    x = tf.range(stride / 2, image_size[1], stride, dtype=tf.float32)\n    # (h,)\n    y = tf.range(stride / 2, image_size[0], stride, dtype=tf.float32)\n    # (h, w)\n    xv, yv = tf.meshgrid(x, y)\n    # (h, w, 1)\n    xv = tf.expand_dims(xv, axis=-1)\n    yv = tf.expand_dims(yv, axis=-1)\n    # (h, w, k, 1)\n    y_min = tf.expand_dims(yv - half_anchor_widths, axis=-1)\n    y_max = tf.expand_dims(yv + half_anchor_widths, axis=-1)\n    x_min = tf.expand_dims(xv - half_anchor_lengths, axis=-1)\n    x_max = tf.expand_dims(xv + half_anchor_lengths, axis=-1)\n    # (h, w, k, 4)\n    boxes_i = tf.concat([y_min, x_min, y_max, x_max], axis=-1)\n    # [h, w, k * 4]\n    shape = boxes_i.shape.as_list()\n    boxes_i = tf.reshape(boxes_i, [shape[0], shape[1], shape[2] * shape[3]])\n\n    boxes_all[str(level)] = boxes_i\n  return boxes_all",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 32,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}