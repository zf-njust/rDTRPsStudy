{
  "code": "def http_request(self, req):\n        tmp_ca_cert_path, paths_checked = self.get_ca_certs()\n        https_proxy = os.environ.get('https_proxy')\n        context = None\n        if HAS_SSLCONTEXT:\n            context = self._make_context(tmp_ca_cert_path)\n\n        # Detect if 'no_proxy' environment variable is set and if our URL is included\n        use_proxy = self.detect_no_proxy(req.get_full_url())\n\n        if not use_proxy:\n            # ignore proxy settings for this host request\n            return req\n\n        try:\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            if https_proxy:\n                proxy_parts = generic_urlparse(urlparse(https_proxy))\n                port = proxy_parts.get('port') or 443\n                s.connect((proxy_parts.get('hostname'), port))\n                if proxy_parts.get('scheme') == 'http':\n                    s.sendall(self.CONNECT_COMMAND % (self.hostname, self.port))\n                    if proxy_parts.get('username'):\n                        credentials = \"%s:%s\" % (proxy_parts.get('username',''), proxy_parts.get('password',''))\n                        s.sendall(b('Proxy-Authorization: Basic %s\\r\\n') % base64.b64encode(to_bytes(credentials, errors='surrogate_or_strict')).strip())\n                    s.sendall(b('\\r\\n'))\n                    connect_result = b(\"\")\n                    while connect_result.find(b(\"\\r\\n\\r\\n\")) <= 0:\n                        connect_result += s.recv(4096)\n                        # 128 kilobytes of headers should be enough for everyone.\n                        if len(connect_result) > 131072:\n                            raise ProxyError('Proxy sent too verbose headers. Only 128KiB allowed.')\n                    self.validate_proxy_response(connect_result)\n                    if context:\n                        ssl_s = context.wrap_socket(s, server_hostname=self.hostname)\n                    elif HAS_URLLIB3_SNI_SUPPORT:\n                        ssl_s = ssl_wrap_socket(s, ca_certs=tmp_ca_cert_path, cert_reqs=ssl.CERT_REQUIRED, ssl_version=PROTOCOL, server_hostname=self.hostname)\n                    else:\n                        ssl_s = ssl.wrap_socket(s, ca_certs=tmp_ca_cert_path, cert_reqs=ssl.CERT_REQUIRED, ssl_version=PROTOCOL)\n                        match_hostname(ssl_s.getpeercert(), self.hostname)\n                else:\n                    raise ProxyError('Unsupported proxy scheme: %s. Currently ansible only supports HTTP proxies.' % proxy_parts.get('scheme'))\n            else:\n                s.connect((self.hostname, self.port))\n                if context:\n                    ssl_s = context.wrap_socket(s, server_hostname=self.hostname)\n                elif HAS_URLLIB3_SNI_SUPPORT:\n                    ssl_s = ssl_wrap_socket(s, ca_certs=tmp_ca_cert_path, cert_reqs=ssl.CERT_REQUIRED, ssl_version=PROTOCOL, server_hostname=self.hostname)\n                else:\n                    ssl_s = ssl.wrap_socket(s, ca_certs=tmp_ca_cert_path, cert_reqs=ssl.CERT_REQUIRED, ssl_version=PROTOCOL)\n                    match_hostname(ssl_s.getpeercert(), self.hostname)\n            # close the ssl connection\n            #ssl_s.unwrap()\n            s.close()\n        except (ssl.SSLError, socket.error):\n            e = get_exception()\n            # fail if we tried all of the certs but none worked\n            if 'connection refused' in str(e).lower():\n                raise ConnectionError('Failed to connect to %s:%s.' % (self.hostname, self.port))\n            else:\n                build_ssl_validation_error(self.hostname, self.port, paths_checked)\n        except CertificateError:\n            build_ssl_validation_error(self.hostname, self.port, paths_checked)\n\n        try:\n            # cleanup the temp file created, don't worry\n            # if it fails for some reason\n            os.remove(tmp_ca_cert_path)\n        except:\n            pass\n\n        return req\ndef sendall(self, __data: ReadableBuffer, __flags: int = ...) -> None: ...",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 22,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}