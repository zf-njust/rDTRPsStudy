{
  "code": "def _GenerateMIMEMessage(self,\n                           form,\n                           boundary=None,\n                           max_bytes_per_blob=None,\n                           max_bytes_total=None):\n    \"\"\"Generate a new post from original form.\n\n    Also responsible for storing blobs in the datastore.\n\n    Args:\n      form: Instance of cgi.FieldStorage representing the whole form\n        derived from original post data.\n      boundary: Boundary to use for resulting form.  Used only in tests so\n        that the boundary is always consistent.\n      max_bytes_per_blob: The maximum size in bytes that any single blob\n        in the form is allowed to be.\n      max_bytes_total: The maximum size in bytes that the total of all blobs\n        in the form is allowed to be.\n\n    Returns:\n      A MIMEMultipart instance representing the new HTTP post which should be\n      forwarded to the developers actual CGI handler. DO NOT use the return\n      value of this method to generate a string unless you know what you're\n      doing and properly handle folding whitespace (from rfc822) properly.\n\n    Raises:\n      UploadEntityTooLargeError: The upload exceeds either the\n        max_bytes_per_blob or max_bytes_total limits.\n    \"\"\"\n    message = multipart.MIMEMultipart('form-data', boundary)\n    for name, value in form.headers.items():\n      if name.lower() not in STRIPPED_HEADERS:\n        message.add_header(name, value)\n\n    def IterateForm():\n      \"\"\"Flattens form in to single sequence of cgi.FieldStorage instances.\n\n      The resulting cgi.FieldStorage objects are a little bit irregular in\n      their structure.  A single name can have mulitple sub-items.  In this\n      case, the root FieldStorage object has a list associated with that field\n      name.  Otherwise, the root FieldStorage object just refers to a single\n      nested instance.\n\n      Lists of FieldStorage instances occur when a form has multiple values\n      for the same name.\n\n      Yields:\n        cgi.FieldStorage irrespective of their nesting level.\n      \"\"\"\n\n\n      for key in sorted(form):\n        form_item = form[key]\n        if isinstance(form_item, list):\n          for list_item in form_item:\n            yield list_item\n        else:\n          yield form_item\n\n    creation = self.__now_func()\n    total_bytes_uploaded = 0\n    created_blobs = []\n    upload_too_large = False\n\n    for form_item in IterateForm():\n\n\n\n\n\n\n\n\n      disposition_parameters = {'name': form_item.name}\n\n      if form_item.filename is None:\n\n        variable = base.MIMEBase('text', 'plain')\n        variable.set_payload(form_item.value)\n      else:\n\n\n\n        if not form_item.filename:\n          continue\n\n        disposition_parameters['filename'] = form_item.filename\n\n        main_type, sub_type = _SplitMIMEType(form_item.type)\n\n\n        form_item.file.seek(0, 2)\n        content_length = form_item.file.tell()\n        form_item.file.seek(0)\n\n        total_bytes_uploaded += content_length\n\n        if max_bytes_per_blob is not None:\n          if max_bytes_per_blob < content_length:\n            upload_too_large = True\n            break\n        if max_bytes_total is not None:\n          if max_bytes_total < total_bytes_uploaded:\n            upload_too_large = True\n            break\n\n\n        blob_entity = self.StoreBlob(form_item, creation)\n\n\n        created_blobs.append(blob_entity)\n\n        variable = base.MIMEBase('message',\n                                 'external-body',\n                                 access_type=blobstore.BLOB_KEY_HEADER,\n                                 blob_key=blob_entity.key().name())\n\n\n        form_item.file.seek(0)\n        digester = hashlib.md5()\n        while True:\n          block = form_item.file.read(1 << 20)\n          if not block:\n            break\n          digester.update(block)\n\n        blob_key = base64.urlsafe_b64encode(digester.hexdigest())\n        form_item.file.seek(0)\n\n        external = base.MIMEBase(main_type,\n                                 sub_type,\n                                 **form_item.type_options)\n        headers = dict(form_item.headers)\n        headers['Content-Length'] = str(content_length)\n        headers[blobstore.UPLOAD_INFO_CREATION_HEADER] = (\n            blobstore._format_creation(creation))\n        headers['Content-MD5'] = blob_key\n        for key, value in headers.iteritems():\n          external.add_header(key, value)\n\n\n        external_disposition_parameters = dict(disposition_parameters)\n\n\n        external_disposition_parameters['filename'] = form_item.filename\n        if not external.get('Content-Disposition'):\n          external.add_header('Content-Disposition',\n                              'form-data',\n                              **external_disposition_parameters)\n        variable.set_payload([external])\n\n\n      variable.add_header('Content-Disposition',\n                          'form-data',\n                          **disposition_parameters)\n      message.attach(variable)\n\n    if upload_too_large:\n      for blob in created_blobs:\n        datastore.Delete(blob)\n      raise UploadEntityTooLargeError()\n\n    return message\ndef urlsafe_b64encode(s):\n    \"\"\"Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n\n    Argument s is a bytes-like object to encode.  The result is returned as a\n    bytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n    '/'.\n    \"\"\"\n    return b64encode(s).translate(_urlsafe_encode_translation)",
  "smell": [
    {
      "smell_id": 2,
      "line_no": 127,
      "description": "The values of an argument hold inconsistent types in different function calls."
    }
  ]
}