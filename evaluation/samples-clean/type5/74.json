{
  "code": "def command(\\n    name: t.Union[str, t.Callable[..., t.Any], None] = None,\\n    cls: t.Optional[t.Type[Command]] = None,\\n    **attrs: t.Any,\\n) -> t.Union[Command, t.Callable[..., Command]]:\\n    r\"\"\"Creates a new :class:`Command` and uses the decorated function as\\n    callback.  This will also automatically attach all decorated\\n    :func:`option`\\\\s and :func:`argument`\\\\s as parameters to the command.\\n\\n    The name of the command defaults to the name of the function with\\n    underscores replaced by dashes.  If you want to change that, you can\\n    pass the intended name as the first argument.\\n\\n    All keyword arguments are forwarded to the underlying command class.\\n    For the ``params`` argument, any decorated params are appended to\\n    the end of the list.\\n\\n    Once decorated the function turns into a :class:`Command` instance\\n    that can be invoked as a command line utility or be attached to a\\n    command :class:`Group`.\\n\\n    :param name: the name of the command.  This defaults to the function\\n                 name with underscores replaced by dashes.\\n    :param cls: the command class to instantiate.  This defaults to\\n                :class:`Command`.\\n\\n    .. versionchanged:: 8.1\\n        This decorator can be applied without parentheses.\\n\\n    .. versionchanged:: 8.1\\n        The ``params`` argument can be used. Decorated params are\\n        appended to the end of the list.\\n    \"\"\"\\n\\n    func: t.Optional[t.Callable[..., t.Any]] = None\\n\\n    if callable(name):\\n        func = name\\n        name = None\\n        assert cls is None, \"Use 'command(cls=cls)(callable)' to specify a class.\"\\n        assert not attrs, \"Use 'command(**kwargs)(callable)' to provide arguments.\"\\n\\n    if cls is None:\\n        cls = Command\\n\\n    def decorator(f: t.Callable[..., t.Any]) -> Command:\\n        if isinstance(f, Command):\\n            raise TypeError(\"Attempted to convert a callback into a command twice.\")\\n\\n        attr_params = attrs.pop(\"params\", None)\\n        params = attr_params if attr_params is not None else []\\n\\n        try:\\n            decorator_params = f.__click_params__  # type: ignore\\n        except AttributeError:\\n            pass\\n        else:\\n            del f.__click_params__  # type: ignore\\n            params.extend(reversed(decorator_params))\\n\\n        if attrs.get(\"help\") is None:\\n            attrs[\"help\"] = f.__doc__\\n\\n        cmd = cls(  # type: ignore[misc]\\n            name=name or f.__name__.lower().replace(\"_\", \"-\"),  # type: ignore[arg-type]\\n            callback=f,\\n            params=params,\\n            **attrs,\\n        )\\n        cmd.__doc__ = f.__doc__\\n        return cmd\\n\\n    if func is not None:\\n        return decorator(func)\\n\\n    return decorator",
  "smell": [
    {
      "smell_id": 5,
      "line_no": 58,
      "description": "The attribute is deleted from an object through a dynamically determined name."
    }
  ]
}