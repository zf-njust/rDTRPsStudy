{
  "code": "def _bbox_post_process(self,\\n                           results: InstanceData,\\n                           cfg: ConfigDict,\\n                           rescale: bool = False,\\n                           with_nms: bool = True,\\n                           img_meta: Optional[dict] = None) -> InstanceData:\\n        \"\"\"bbox post-processing method.\\n\\n        The boxes would be rescaled to the original image scale and do\\n        the nms operation.\\n\\n        Args:\\n            results (:obj:`InstaceData`): Detection instance results,\\n                each item has shape (num_bboxes, ).\\n            cfg (ConfigDict): Test / postprocessing configuration.\\n            rescale (bool): If True, return boxes in original image space.\\n                Defaults to False.\\n            with_nms (bool): If True, do nms before return boxes.\\n                Default to True.\\n            img_meta (dict, optional): Image meta info. Defaults to None.\\n\\n        Returns:\\n            :obj:`InstanceData`: Detection results of each image\\n            after the post process.\\n            Each item usually contains following keys.\\n\\n                - scores (Tensor): Classification scores, has a shape\\n                  (num_instance, )\\n                - labels (Tensor): Labels of bboxes, has a shape\\n                  (num_instances, ).\\n                - bboxes (Tensor): Has a shape (num_instances, 4),\\n                  the last dimension 4 arrange as (x1, y1, x2, y2).\\n        \"\"\"\\n        assert with_nms, '`with_nms` must be True in RPNHead'\\n        if rescale:\\n            assert img_meta.get('scale_factor') is not None\\n            scale_factor = [1 / s for s in img_meta['scale_factor']]\\n            results.bboxes = scale_boxes(results.bboxes, scale_factor)\\n\\n        # filter small size bboxes\\n        if cfg.get('min_bbox_size', -1) >= 0:\\n            w, h = get_box_wh(results.bboxes)\\n            valid_mask = (w > cfg.min_bbox_size) & (h > cfg.min_bbox_size)\\n            if not valid_mask.all():\\n                results = results[valid_mask]\\n\\n        if results.bboxes.numel() > 0:\\n            bboxes = get_box_tensor(results.bboxes)\\n            det_bboxes, keep_idxs = batched_nms(bboxes, results.scores,\\n                                                results.level_ids, cfg.nms)\\n            results = results[keep_idxs]\\n            # some nms would reweight the score, such as softnms\\n            results.scores = det_bboxes[:, -1]\\n            results = results[:cfg.max_per_img]\\n            # TODO: This would unreasonably show the 0th class label\\n            #  in visualization\\n            results.labels = results.scores.new_zeros(\\n                len(results), dtype=torch.long)\\n            del results.level_ids\\n        else:\\n            # To avoid some potential error\\n            results_ = InstanceData()\\n            results_.bboxes = empty_box_as(results.bboxes)\\n            results_.scores = results.scores.new_zeros(0)\\n            results_.labels = results.scores.new_zeros(0)\\n            results = results_\\n        return results",
  "smell": [
    {
      "smell_id": 5,
      "line_no": 59,
      "description": "The attribute is deleted from an object through a dynamically determined name."
    }
  ]
}