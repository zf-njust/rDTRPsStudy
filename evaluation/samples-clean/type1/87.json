{
  "code": "def CCompiler_compile(self, sources, output_dir=None, macros=None,\n                      include_dirs=None, debug=0, extra_preargs=None,\n                      extra_postargs=None, depends=None):\n    \"\"\"\n    Compile one or more source files.\n\n    Please refer to the Python distutils API reference for more details.\n\n    Parameters\n    ----------\n    sources : list of str\n        A list of filenames\n    output_dir : str, optional\n        Path to the output directory.\n    macros : list of tuples\n        A list of macro definitions.\n    include_dirs : list of str, optional\n        The directories to add to the default include file search path for\n        this compilation only.\n    debug : bool, optional\n        Whether or not to output debug symbols in or alongside the object\n        file(s).\n    extra_preargs, extra_postargs : ?\n        Extra pre- and post-arguments.\n    depends : list of str, optional\n        A list of file names that all targets depend on.\n\n    Returns\n    -------\n    objects : list of str\n        A list of object file names, one per source file `sources`.\n\n    Raises\n    ------\n    CompileError\n        If compilation fails.\n\n    \"\"\"\n    # This method is effective only with Python >=2.3 distutils.\n    # Any changes here should be applied also to fcompiler.compile\n    # method to support pre Python 2.3 distutils.\n    if not sources:\n        return []\n    # FIXME:RELATIVE_IMPORT\n    if sys.version_info[0] < 3:\n        from .fcompiler import FCompiler, is_f_file, has_f90_header\n    else:\n        from numpy.distutils.fcompiler import (FCompiler, is_f_file,\n                                               has_f90_header)\n    if isinstance(self, FCompiler):\n        display = []\n        for fc in ['f77', 'f90', 'fix']:\n            fcomp = getattr(self, 'compiler_'+fc)\n            if fcomp is None:\n                continue\n            display.append(\"Fortran %s compiler: %s\" % (fc, ' '.join(fcomp)))\n        display = '\\n'.join(display)\n    else:\n        ccomp = self.compiler_so\n        display = \"C compiler: %s\\n\" % (' '.join(ccomp),)\n    log.info(display)\n    macros, objects, extra_postargs, pp_opts, build = \\\n            self._setup_compile(output_dir, macros, include_dirs, sources,\n                                depends, extra_postargs)\n    cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)\n    display = \"compile options: '%s'\" % (' '.join(cc_args))\n    if extra_postargs:\n        display += \"\\nextra options: '%s'\" % (' '.join(extra_postargs))\n    log.info(display)\n\n    def single_compile(args):\n        obj, (src, ext) = args\n        self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n\n    if isinstance(self, FCompiler):\n        objects_to_build = list(build.keys())\n        f77_objects, other_objects = [], []\n        for obj in objects:\n            if obj in objects_to_build:\n                src, ext = build[obj]\n                if self.compiler_type=='absoft':\n                    obj = cyg2win32(obj)\n                    src = cyg2win32(src)\n                if is_f_file(src) and not has_f90_header(src):\n                    f77_objects.append((obj, (src, ext)))\n                else:\n                    other_objects.append((obj, (src, ext)))\n\n        # f77 objects can be built in parallel\n        build_items = f77_objects\n        # build f90 modules serial, module files are generated during\n        # compilation and may be used by files later in the list so the\n        # ordering is important\n        for o in other_objects:\n            single_compile(o)\n    else:\n        build_items = build.items()\n\n    jobs = get_num_build_jobs()\n    if len(build) > 1 and jobs > 1:\n        # build parallel\n        import multiprocessing.pool\n        pool = multiprocessing.pool.ThreadPool(jobs)\n        pool.map(single_compile, build_items)\n        pool.close()\n    else:\n        # build serial\n        for o in build_items:\n            single_compile(o)\n\n    # Return *all* object filenames, not just the ones we just built.\n    return objects",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 60,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}