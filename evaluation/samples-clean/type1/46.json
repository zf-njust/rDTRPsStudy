{
  "code": "def connect(\n        self,\n        hostkey=None,\n        username=\"\",\n        password=None,\n        pkey=None,\n        gss_host=None,\n        gss_auth=False,\n        gss_kex=False,\n        gss_deleg_creds=True,\n        gss_trust_dns=True,\n    ):\n        \"\"\"\n        Negotiate an SSH2 session, and optionally verify the server's host key\n        and authenticate using a password or private key.  This is a shortcut\n        for `start_client`, `get_remote_server_key`, and\n        `Transport.auth_password` or `Transport.auth_publickey`.  Use those\n        methods if you want more control.\n\n        You can use this method immediately after creating a Transport to\n        negotiate encryption with a server.  If it fails, an exception will be\n        thrown.  On success, the method will return cleanly, and an encrypted\n        session exists.  You may immediately call `open_channel` or\n        `open_session` to get a `.Channel` object, which is used for data\n        transfer.\n\n        .. note::\n            If you fail to supply a password or private key, this method may\n            succeed, but a subsequent `open_channel` or `open_session` call may\n            fail because you haven't authenticated yet.\n\n        :param .PKey hostkey:\n            the host key expected from the server, or ``None`` if you don't\n            want to do host key verification.\n        :param str username: the username to authenticate as.\n        :param str password:\n            a password to use for authentication, if you want to use password\n            authentication; otherwise ``None``.\n        :param .PKey pkey:\n            a private key to use for authentication, if you want to use private\n            key authentication; otherwise ``None``.\n        :param str gss_host:\n            The target's name in the kerberos database. Default: hostname\n        :param bool gss_auth:\n            ``True`` if you want to use GSS-API authentication.\n        :param bool gss_kex:\n            Perform GSS-API Key Exchange and user authentication.\n        :param bool gss_deleg_creds:\n            Whether to delegate GSS-API client credentials.\n        :param gss_trust_dns:\n            Indicates whether or not the DNS is trusted to securely\n            canonicalize the name of the host being connected to (default\n            ``True``).\n\n        :raises: `.SSHException` -- if the SSH2 negotiation fails, the host key\n            supplied by the server is incorrect, or authentication fails.\n\n        .. versionchanged:: 2.3\n            Added the ``gss_trust_dns`` argument.\n        \"\"\"\n        if hostkey is not None:\n            # TODO: a more robust implementation would be to ask each key class\n            # for its nameS plural, and just use that.\n            # TODO: that could be used in a bunch of other spots too\n            if isinstance(hostkey, RSAKey):\n                self._preferred_keys = [\n                    \"rsa-sha2-512\",\n                    \"rsa-sha2-256\",\n                    \"ssh-rsa\",\n                ]\n            else:\n                self._preferred_keys = [hostkey.get_name()]\n\n        self.set_gss_host(\n            gss_host=gss_host,\n            trust_dns=gss_trust_dns,\n            gssapi_requested=gss_kex or gss_auth,\n        )\n\n        self.start_client()\n\n        # check host key if we were given one\n        # If GSS-API Key Exchange was performed, we are not required to check\n        # the host key.\n        if (hostkey is not None) and not gss_kex:\n            key = self.get_remote_server_key()\n            if (\n                key.get_name() != hostkey.get_name()\n                or key.asbytes() != hostkey.asbytes()\n            ):\n                self._log(DEBUG, \"Bad host key from server\")\n                self._log(\n                    DEBUG,\n                    \"Expected: {}: {}\".format(\n                        hostkey.get_name(), repr(hostkey.asbytes())\n                    ),\n                )\n                self._log(\n                    DEBUG,\n                    \"Got     : {}: {}\".format(\n                        key.get_name(), repr(key.asbytes())\n                    ),\n                )\n                raise SSHException(\"Bad host key from server\")\n            self._log(\n                DEBUG, \"Host key verified ({})\".format(hostkey.get_name())\n            )\n\n        if (pkey is not None) or (password is not None) or gss_auth or gss_kex:\n            if gss_auth:\n                self._log(\n                    DEBUG, \"Attempting GSS-API auth... (gssapi-with-mic)\"\n                )  # noqa\n                self.auth_gssapi_with_mic(\n                    username, self.gss_host, gss_deleg_creds\n                )\n            elif gss_kex:\n                self._log(DEBUG, \"Attempting GSS-API auth... (gssapi-keyex)\")\n                self.auth_gssapi_keyex(username)\n            elif pkey is not None:\n                self._log(DEBUG, \"Attempting public-key auth...\")\n                self.auth_publickey(username, pkey)\n            else:\n                self._log(DEBUG, \"Attempting password auth...\")\n                self.auth_password(username, password)\n\n        return",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 72,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}