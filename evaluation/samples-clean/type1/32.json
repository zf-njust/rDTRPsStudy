{
  "code": "    def run(self, terms, variables=None, **kwargs):\n\n        '''\n        terms contains a string with things to `dig' for. We support the\n        following formats:\n            example.com                                     # A record\n            example.com  qtype=A                            # same\n            example.com/TXT                                 # specific qtype\n            example.com  qtype=txt                          # same\n            192.0.2.23/PTR                                 # reverse PTR\n              ^^ shortcut for 23.2.0.192.in-addr.arpa/PTR\n            example.net/AAAA  @nameserver                   # query specified server\n                               ^^^ can be comma-sep list of names/addresses\n\n            ... flat=0                                      # returns a dict; default is 1 == string\n        '''\n\n        if HAVE_DNS == False:\n            raise AnsibleError(\"Can't LOOKUP(dig): module dns.resolver is not installed\")\n\n        # Create Resolver object so that we can set NS if necessary\n        myres = dns.resolver.Resolver()\n        edns_size = 4096\n        myres.use_edns(0, ednsflags=dns.flags.DO, payload=edns_size)\n\n        domain = None\n        qtype  = 'A'\n        flat   = True\n\n        for t in terms:\n            if t.startswith('@'):       # e.g. \"@10.0.1.2,192.0.2.1\" is ok.\n                nsset = t[1:].split(',')\n                nameservers = []\n                for ns in nsset:\n                    # Check if we have a valid IP address. If so, use that, otherwise\n                    # try to resolve name to address using system's resolver. If that\n                    # fails we bail out.\n                    try:\n                        socket.inet_aton(ns)\n                        nameservers.append(ns)\n                    except:\n                        try:\n                            nsaddr = dns.resolver.query(ns)[0].address\n                            nameservers.append(nsaddr)\n                        except Exception as e:\n                            raise AnsibleError(\"dns lookup NS: \", str(e))\n                    myres.nameservers = nameservers\n                continue\n            if '=' in t:\n                try:\n                    opt, arg = t.split('=')\n                except:\n                    pass\n\n                if opt == 'qtype':\n                    qtype = arg.upper()\n                elif opt == 'flat':\n                    flat = int(arg)\n\n                continue\n\n            if '/' in t:\n                try:\n                    domain, qtype = t.split('/')\n                except:\n                    domain = t\n            else:\n                domain = t\n\n        # print \"--- domain = {0} qtype={1}\".format(domain, qtype)\n\n        ret = []\n\n        if qtype.upper() == 'PTR':\n            try:\n                n = dns.reversename.from_address(domain)\n                domain = n.to_text()\n            except dns.exception.SyntaxError:\n                pass\n            except Exception as e:\n                raise AnsibleError(\"dns.reversename unhandled exception\", str(e))\n\n        try:\n            answers = myres.query(domain, qtype)\n            for rdata in answers:\n                s = rdata.to_text()\n                if qtype.upper() == 'TXT':\n                    s = s[1:-1]  # Strip outside quotes on TXT rdata\n\n                if flat:\n                    ret.append(s)\n                else:\n                    try:\n                        rd = make_rdata_dict(rdata)\n                        rd['owner']     = answers.canonical_name.to_text()\n                        rd['type']      = dns.rdatatype.to_text(rdata.rdtype)\n                        rd['ttl']       = answers.rrset.ttl\n\n                        ret.append(rd)\n                    except Exception as e:\n                        ret.append(str(e))\n\n        except dns.resolver.NXDOMAIN:\n            ret.append('NXDOMAIN')\n        except dns.resolver.NoAnswer:\n            ret.append(\"\")\n        except dns.resolver.Timeout:\n            ret.append('')\n        except dns.exception.DNSException as e:\n            raise AnsibleError(\"dns.resolver unhandled exception\", e)\n\n        return ret",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 58,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}