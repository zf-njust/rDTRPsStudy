{
  "code": "def _join_lists_or_dicts(self, outputs, unit):\n    \"\"\"Joins many lists or dicts of outputs into a single list or dict.\n\n    This function also validates that the outputs are correct for the given\n    Pipeline.\n\n    If `outputs` is a list of lists, the lists are concated and the type of\n    each object must match `unit.output_type`.\n\n    If `output` is a list of dicts (mapping string names to lists), each\n    key has its lists concated across all the dicts. The keys and types\n    are validated against `unit.output_type`.\n\n    Args:\n      outputs: A list of lists, or list of dicts which map string names to\n          lists.\n      unit: A Pipeline which every output in `outputs` will be validated\n          against. `unit` must produce the outputs it says it will produce.\n\n    Returns:\n      If `outputs` is a list of lists, a single list of outputs.\n      If `outputs` is a list of dicts, a single dictionary mapping string names\n      to lists of outputs.\n\n    Raises:\n      InvalidTransformOutputError: If anything in `outputs` does not match\n      the type signature given by `unit.output_type`.\n    \"\"\"\n    if not outputs:\n      return []\n    if isinstance(unit.output_type, dict):\n      concated = dict((key, list()) for key in unit.output_type.keys())\n      for d in outputs:\n        if not isinstance(d, dict):\n          raise InvalidTransformOutputError(\n              'Expected dictionary output for %s with output type %s but '\n              'instead got type %s' % (unit, unit.output_type, type(d)))\n        if set(d.keys()) != set(unit.output_type.keys()):\n          raise InvalidTransformOutputError(\n              'Got dictionary output with incorrect keys for %s. Got %s. '\n              'Expected %s' % (unit, d.keys(), unit.output_type.keys()))\n        for k, val in d.items():\n          if not isinstance(val, list):\n            raise InvalidTransformOutputError(\n                'DagOutput from %s for key %s is not a list.' % (unit, k))\n          if not _all_are_type(val, unit.output_type[k]):\n            raise InvalidTransformOutputError(\n                'Some outputs from %s for key %s are not of expected type %s. '\n                'Got types %s' % (unit, k, unit.output_type[k],\n                                  [type(inst) for inst in val]))\n          concated[k] += val\n    else:\n      concated = []\n      for l in outputs:\n        if not isinstance(l, list):\n          raise InvalidTransformOutputError(\n              'Expected list output for %s with outpu type %s but instead got '\n              'type %s' % (unit, unit.output_type, type(l)))\n        if not _all_are_type(l, unit.output_type):\n          raise InvalidTransformOutputError(\n              'Some outputs from %s are not of expected type %s. Got types %s'\n              % (unit, unit.output_type, [type(inst) for inst in l]))\n        concated += l\n    return concated",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 53,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}