{
  "code": "def _read_header(self):\n        self.filepath_or_buffer.seek(0)\n\n        # read file header\n        line1 = self._get_row()\n        if line1 != _correct_line1:\n            raise ValueError(\"Header record is not an XPORT file.\")\n\n        line2 = self._get_row()\n        file_info = _split_line(line2, [ ['prefix',24], ['version',8], ['OS',8], ['_',24], ['created',16]])\n        if file_info['prefix'] != \"SAS     SAS     SASLIB\":\n            raise ValueError(\"Header record has invalid prefix.\")\n        file_info['created'] = _parse_date(file_info['created'])\n        self.file_info = file_info\n\n        line3 = self._get_row()\n        file_info['modified'] = _parse_date(line3[:16])\n\n        # read member header\n        header1 = self._get_row()\n        header2 = self._get_row()\n        if not header1.startswith(_correct_header1) or not header2 == _correct_header2:\n            raise ValueError(\"Member header not found.\")\n        fieldnamelength = int(header1[-5:-2]) # usually 140, could be 135\n\n        # member info\n        member_info = _split_line(self._get_row(), [['prefix',8], ['set_name',8],\n                                                    ['sasdata',8],['version',8],\n                                                    ['OS',8],['_',24],['created',16]])\n        member_info.update( _split_line(self._get_row(), [['modified',16], ['_',16],\n                                                          ['label',40],['type',8]]))\n        member_info['modified'] = _parse_date(member_info['modified'])\n        member_info['created'] = _parse_date(member_info['created'])\n        self.member_info = member_info\n\n        # read field names\n        types = {1: 'numeric', 2: 'char'}\n        fieldcount = int(self._get_row()[54:58])\n        datalength = fieldnamelength*fieldcount\n        if datalength % 80: # round up to nearest 80\n            datalength += 80 - datalength%80\n        fielddata = self.filepath_or_buffer.read(datalength)\n        fields = []\n        obs_length = 0\n        while len(fielddata) >= fieldnamelength:\n            # pull data for one field\n            field, fielddata = (fielddata[:fieldnamelength], fielddata[fieldnamelength:])\n\n            # rest at end gets ignored, so if field is short, pad out\n            # to match struct pattern below\n            field = field.ljust(140)\n\n            fieldstruct = struct.unpack('>hhhh8s40s8shhh2s8shhl52s', field)\n            field = dict(zip(_fieldkeys, fieldstruct))\n            del field['_']\n            field['ntype'] = types[field['ntype']]\n            if field['ntype'] == 'numeric' and field['field_length'] != 8:\n                raise TypeError(\"Only 8-byte floats are currently implemented. Can't read field %s.\" % field)\n\n            for k, v in field.items():\n                try:\n                    field[k] = v.strip()\n                except AttributeError:\n                    pass\n\n            obs_length += field['field_length']\n            fields += [field]\n\n        header = self._get_row()\n        if not header == _correct_obs_header:\n            raise ValueError(\"Observation header not found.\")\n\n        self.fields = fields\n        self.record_length = obs_length\n        self.record_start = self.filepath_or_buffer.tell()\n\n        self.nobs = self._record_count()\n        self.columns = [x['name'].decode() for x in self.fields]\n\n        # Setup the dtype.\n        dtypel = []\n        for i,field in enumerate(self.fields):\n            ntype = field['ntype']\n            if ntype == \"numeric\":\n                dtypel.append(('s' + str(i), \">u8\"))\n            elif ntype == \"char\":\n                dtypel.append(('s' + str(i), \"S\" + str(field['field_length'])))\n        dtype = np.dtype(dtypel)\n        self._dtype = dtype",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 54,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}