{
  "code": "def _outside_call_run_callback(\n    arrays, device, *,\n    send_infeed=True,\n    # The same parameters as outside_call_p\n    callback, arg_treedef,\n    identity, result_treedef=None, flat_results_aval=None,\n    transforms=(), has_token=False):\n  \"\"\"Performs the callback:\n       callback(arg, device, transforms)\n\n  Called during the device computation once we have the argument, either from\n  an inlined callback or from an XLA computation outfeed.\n\n  Returns the flat list of result arrays. If `send_infeed` then it will also send\n  the flat list of results to the device.\n  \"\"\"\n\n  def _unpack_transforms(transforms) -> tuple[tuple[str, dict[str, Any]], ...]:\n    def _unpack_transform(name, *params):\n      if name == \"batch\":\n        return name, dict(batch_dims=params[0])\n      elif name == \"mask\":\n        return name, dict(logical_shapes=5)\n      else:\n        assert not params, f\"{name}, {params}\"\n        return name, dict()\n\n    return tuple(_unpack_transform(*t) for t in transforms)\n\n  try:\n    arg = api.tree_unflatten(arg_treedef, arrays)\n    unpacked_transforms = _unpack_transforms(transforms)\n    logger.debug(\n      \"Outside call invoking call_func %s, device=%s, transforms=%s\",\n      callback, device, unpacked_transforms\n    )\n    res = callback(arg, device, unpacked_transforms)\n    if identity:\n      return tuple(arrays)\n\n    else:  # Check the type of the callback results\n      assert result_treedef is not None\n      assert flat_results_aval is not None\n      actual_flat_results, actual_result_treedef = pytree.flatten(res)\n      if actual_result_treedef != result_treedef:\n        msg = (f\"Callback func {callback} should have returned a result \"\n               f\"with pytree {result_treedef} but returned \"\n               f\"{actual_result_treedef}\")\n        raise TypeError(msg)\n\n      canonical_flat_results = tuple(util.safe_map(xla.canonicalize_dtype, actual_flat_results))\n      actual_flat_results_aval = _values_to_avals(canonical_flat_results)\n      logger.debug(\n        \"Outside call %s result %s. Sending to infeed for device %s.\",\n        callback, flat_results_aval, device,\n        )\n\n      if not all(ea.strip_weak_type() == ra.strip_weak_type()\n                 for ea, ra in util.safe_zip(flat_results_aval,\n                                             actual_flat_results_aval)):\n        msg = (f\"Callback func {callback} should have returned a result \"\n               \"with abstract values \"\n               f\"{result_treedef.unflatten(flat_results_aval)} \"\n               f\"but returned {actual_result_treedef.unflatten(actual_flat_results_aval)}\")\n        raise TypeError(msg)\n\n      if send_infeed:\n        # Do not send the 0-sized arrays\n        non_empty_canonical_flat_results = tuple(filter(lambda r: not _aval_is_empty(r),\n                                                        canonical_flat_results))\n        device.transfer_to_infeed(non_empty_canonical_flat_results)\n      return canonical_flat_results\n\n  except Exception as e:\n    logger.error(\"Outside call %s threw exception %s.\", callback, e)\n    if send_infeed:\n      # Prepare some results to send in case of error. We are sending something\n      # with a distinctive shape (int8[12345]), one that is unlikely to be what the device\n      # expects. This should have the effect to abort the device computation,\n      # with an error message that we recognize. On TPU there seem to be no\n      # such check, and if we send anything at all the device computation will\n      # use some garbage data. So, on TPU we prefer to not send anything and let\n      # the computation hang.\n      # TODO: implement a proper error handling for TPU\n      if device.platform != \"tpu\":\n        canonical_flat_results = [xla.canonicalize_dtype(np.arange(12345, dtype=np.int8))]\n        logger.debug(\"Outside call consumer %s exception %s. Sending to infeed the error result.\",\n                     callback, e)\n        device.transfer_to_infeed(tuple(canonical_flat_results))\n      else:\n        logger.debug(\"Outside call consumer %s exception %s. On TPU we do not send infeed.\",\n                     callback, e)\n    raise e",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 86,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}