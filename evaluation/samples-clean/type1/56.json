{
  "code": "def nested_csv_str_to_json_str(csv_str):\n  \"\"\"Converts a nested (using '.') comma-separated k=v string to a JSON string.\n\n  Converts a comma-separated string of key/value pairs that supports\n  nesting of keys to a JSON string. Nesting is implemented using\n  '.' between levels for a given key.\n\n  Spacing between commas and = is supported (e.g. there is no difference between\n  \"a=1,b=2\", \"a = 1, b = 2\", or \"a=1, b=2\") but there should be no spaces before\n  keys or after values (e.g. \" a=1,b=2\" and \"a=1,b=2 \" are not supported).\n\n  Note that this will only support values supported by CSV, meaning\n  values such as nested lists (e.g. \"a=[[1,2,3],[4,5,6]]\") are not\n  supported. Strings are supported as well, e.g. \"a='hello'\".\n\n  An example conversion would be:\n\n  \"a=1, b=2, c.a=2, c.b=3, d.a.a=5\"\n\n  to\n\n  \"{ a: 1, b : 2, c: {a : 2, b : 3}, d: {a: {a : 5}}}\"\n\n  Args:\n    csv_str: the comma separated string.\n\n  Returns:\n    the converted JSON string.\n\n  Raises:\n    ValueError: If csv_str is not in a comma separated string or\n      if the string is formatted incorrectly.\n  \"\"\"\n  if not csv_str:\n    return ''\n\n  array_param_map = collections.defaultdict(str)\n  max_index_map = collections.defaultdict(str)\n  formatted_entries = []\n  nested_map = collections.defaultdict(list)\n  pos = 0\n  while pos < len(csv_str):\n    m = _PARAM_RE.match(csv_str, pos)\n    if not m:\n      raise ValueError('Malformed hyperparameter value while parsing '\n                       'CSV string: %s' % csv_str[pos:])\n    pos = m.end()\n    # Parse the values.\n    m_dict = m.groupdict()\n    name = m_dict['name']\n    v = m_dict['val']\n    bracketed_index = m_dict['bracketed_index']\n    # If we reach the name of the array.\n    if bracketed_index and '.' not in name:\n      # Extract the array's index by removing '[' and ']'\n      index = int(bracketed_index[1:-1])\n      if '.' in v:\n        numeric_val = float(v)\n      else:\n        numeric_val = int(v)\n      # Add the value to the array.\n      if name not in array_param_map:\n        max_index_map[name] = index\n        array_param_map[name] = [None] * (index + 1)\n        array_param_map[name][index] = numeric_val\n      elif index < max_index_map[name]:\n        array_param_map[name][index] = numeric_val\n      else:\n        array_param_map[name] += [None] * (index - max_index_map[name])\n        array_param_map[name][index] = numeric_val\n        max_index_map[name] = index\n      continue\n\n    # If a GCS path (e.g. gs://...) is provided, wrap this in quotes\n    # as yaml.load would otherwise throw an exception\n    if re.match(r'(?=[^\\\"\\'])(?=[gs://])', v):\n      v = '\\'{}\\''.format(v)\n\n    name_nested = name.split('.')\n    if len(name_nested) > 1:\n      grouping = name_nested[0]\n      if bracketed_index:\n        value = '.'.join(name_nested[1:]) + bracketed_index + '=' + v\n      else:\n        value = '.'.join(name_nested[1:]) + '=' + v\n      nested_map[grouping].append(value)\n    else:\n      formatted_entries.append('%s : %s' % (name, v))\n\n  for grouping, value in nested_map.items():\n    value = ','.join(value)\n    value = nested_csv_str_to_json_str(value)\n    formatted_entries.append('%s : %s' % (grouping, value))\n\n  # Add array parameters and check that the array is fully initialized.\n  for name in array_param_map:\n    if any(v is None for v in array_param_map[name]):\n      raise ValueError('Did not pass all values of array: %s' % name)\n    formatted_entries.append('%s : %s' % (name, array_param_map[name]))\n\n  return '{' + ', '.join(formatted_entries) + '}'",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 90,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}