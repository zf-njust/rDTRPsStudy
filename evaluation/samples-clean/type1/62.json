{
  "code": "def _scan_partial_eval(trace, *tracers, reverse, length, num_consts, num_carry,\n                       jaxpr, linear, unroll):\n  num_ys = len(jaxpr.out_avals) - num_carry\n  unknowns = [not t.pval.is_known() for t in tracers]\n  const_uk, init_uk, xs_uk = split_list(unknowns, [num_consts, num_carry])\n\n  # Fixpoint computation of which carry elements are unknown. Each iteration\n  # promotes at least one carry to unknown. We need at most len(carry)\n  # iterations, but we need one last iteration to prepare the jaxpr based on the\n  # final carry_uk.\n  carry_uk = init_uk\n  for _ in range(1 + len(carry_uk)):\n    unknowns = const_uk + carry_uk + xs_uk\n    jaxpr_known, jaxpr_unknown, out_uk, res_avals = pe.partial_eval_jaxpr_nounits(\n        jaxpr, unknowns, instantiate=carry_uk + [False] * num_ys)\n    carry_uk_out, ys_uk = split_list(out_uk, [num_carry])\n    if carry_uk_out == carry_uk:\n      break\n    else:\n      carry_uk = _map(operator.or_, carry_uk, carry_uk_out)\n  else:\n    assert False, \"Fixpoint not reached\"\n  num_res = len(res_avals)\n  del res_avals, carry_uk_out\n\n  # Instantiate those inputs which must be treated as unknown from the fixpoint.\n  tracers = [trace.instantiate_const(t) if uk else t\n             for t, uk in zip(tracers, unknowns)]\n\n  # The residual inputs and outputs of the jaxprs produced haven't yet been\n  # adapted to the scan calling convention; in particular, jaxpr_known has its\n  # residual outputs all at the end, meaning they're extensive outputs (which is\n  # fully general but may be wasteful for residuals which are loop-invariant)\n  # while jaxpr_unknown has its corresponding residual inputs at the front (just\n  # as a convention with partial_eval_jaxpr_nounits), making them constant\n  # inputs. To make them consistent, we move the residual inputs on\n  # jaxpr_unknown to the end, even though we may move some back in the sequel.\n  jaxpr_unknown = pe.move_binders_to_back(\n      jaxpr_unknown, [True] * num_res + [False] * sum(unknowns))\n\n  # At this point, all residuals are treated as extensive outputs of jaxpr_known\n  # (and extensive inputs to jaxpr_unknown). But residuals that are loop-\n  # invariant can be hoisted out of the scan, rather than letting them get\n  # broadcast (as in e.g. scanning multiplication by a constant matrix; we don't\n  # want to broadcast the matrix!). So, outside the loop we perform a partial\n  # evaluation with known 'const' inputs (but all other inputs unknown).\n  const_pvals = [pe.PartialVal.known(t.pval.get_known())\n                 for t in tracers[:num_consts] if t.pval.is_known()]\n  other_pvals = [pe.PartialVal.unknown(aval)\n                 for aval in jaxpr_known.in_avals[len(const_pvals):]]\n  with source_info_util.reset_name_stack():\n    jaxpr_known_, invar_pvals_out, jaxpr_known_consts = pe.trace_to_jaxpr_nounits(\n        lu.wrap_init(core.jaxpr_as_fun(jaxpr_known)), const_pvals + other_pvals,\n        instantiate=[True] * (len(out_uk) - sum(out_uk)) + [False] * num_res)\n  jaxpr_known = pe.ClosedJaxpr(pe.convert_constvars_jaxpr(jaxpr_known_), ())\n  # The above trace_to_jaxpr_nounits call computed loop-invariant residuals\n  # (known values in invar_pvals_out) and also computed loop-invariant values\n  # needed by the new jaxpr_known (in jaxpr_known_consts, which replace the\n  # previous consts). We need to collect the computed inteisive residuals, and\n  # move corresponding intensive residual binders in jaxpr_unknown to the front.\n  res_pvals = invar_pvals_out[len(invar_pvals_out) - num_res:]\n  intensive_res = [pval.get_known() for pval in res_pvals if pval.is_known()]\n  jaxpr_unknown = pe.move_binders_to_front(\n      jaxpr_unknown,\n      [False] * sum(unknowns) + [pval.is_known() for pval in res_pvals])\n  del const_pvals, other_pvals, invar_pvals_out, jaxpr_known_, res_pvals\n  # We use `jaxpr_known_consts` when we call scan_p.bind with jaxpr_known, and\n  # we use `intensive_res` when we build the jaxpr eqn with jaxpr_unknown.\n\n  # As another optimization, for any extensive inputs that are just forwarded to\n  # extensive outputs, to avoid a copy (which would be looping over\n  # dynamic-update-slice) we'd rather forward the input tracer/value. That means\n  # pruning some outputs from jaxpr_known here, and updating `out_flat` below.\n  fwds_known = pe._jaxpr_forwarding(jaxpr_known.jaxpr)\n  # Prune fwds_known to include only extensive input to extensive output.\n  fwds_known = [in_idx if out_idx >= num_carry - sum(carry_uk) and\n                in_idx is not None and\n                in_idx >= len(jaxpr_known_consts) + num_carry - sum(carry_uk)\n                else None for out_idx, in_idx in enumerate(fwds_known)]\n  # Drop any extensive output we can instead get by forwarding an input.\n  # TODO(mattjj): use pe.dce_jaxpr here, though need a fixpoint\n  jaxpr_known_, () = jaxpr_known.jaxpr, jaxpr_known.consts\n  jaxpr_known_ = jaxpr_known_.replace(\n    outvars=[x for x, i in zip(jaxpr_known_.outvars, fwds_known) if i is None])\n  jaxpr_known = core.ClosedJaxpr(jaxpr_known_, ())\n  del jaxpr_known_\n  # We use `fwds_known` below when forming the output of scanning jaxpr_known.\n\n  # Run the known part of the scan (if it has any outputs or effects).\n  known_inputs = (list(jaxpr_known_consts) +\n                  [t.pval.get_known() for t in tracers[num_consts:]\n                   if t.pval.is_known()])\n  if not jaxpr_known.out_avals and not jaxpr_known.effects:\n    out_known = []\n  else:\n    linear_known = [False] * len(known_inputs)  # conservative!\n    out_known = scan_p.bind(\n        *known_inputs, reverse=reverse, length=length, jaxpr=jaxpr_known,\n        num_consts=len(jaxpr_known_consts), num_carry=num_carry - sum(carry_uk),\n        linear=tuple(linear_known), unroll=unroll)\n    del linear_known\n  # Complete the known output by filling in forwarded values using fwds_known.\n  out_known_iter = iter(out_known)\n  out_known = [next(out_known_iter) if f is None\n               else _maybe_put(known_inputs[f]) for f in fwds_known]\n  assert next(out_known_iter, None) is None\n  del known_inputs, out_known_iter\n\n  # Split known outputs from residuals.\n  out_known, extensive_res = split_list(out_known, [len(out_uk) - sum(out_uk)])\n  assert len(intensive_res) + len(extensive_res) == num_res\n\n  # Create input tracers for jaxpr_unknown bind.\n  unknown_inputs = [t for t in tracers if not t.pval.is_known()]\n  intensive_res = _map(trace.new_instantiated_const, intensive_res)\n  extensive_res = _map(trace.new_instantiated_const, extensive_res)\n  # Create output tracers for jaxpr_unknown bind, adapting extensive shapes.\n  carry_avals, y_avals = split_list(jaxpr_unknown.out_avals, [sum(carry_uk)])\n  ys_avals = [core.unmapped_aval(length, core.no_axis_name, 0, y_aval)\n              for y_aval in y_avals]\n  out_tracers = [pe.JaxprTracer(trace, pe.PartialVal.unknown(a), None)\n                 for a in itertools.chain(carry_avals, ys_avals)]\n  del carry_avals, y_avals\n  # Create equation.\n  linear_unknown = tuple([False] * len(intensive_res) +\n                         [l for l, uk in zip(linear, unknowns) if uk] +\n                         [False] * len(extensive_res))\n  name_stack = source_info_util.current_name_stack()[len(trace.name_stack):]\n  source = source_info_util.current().replace(name_stack=name_stack)\n  assert len(out_tracers) == len(jaxpr_unknown.out_avals)\n  eqn = pe.new_eqn_recipe([*intensive_res, *unknown_inputs, *extensive_res],\n                          out_tracers, scan_p,\n                          dict(reverse=reverse, length=length, unroll=unroll,\n                               jaxpr=jaxpr_unknown, linear=linear_unknown,\n                               num_consts=len(intensive_res) + sum(const_uk),\n                               num_carry=sum(carry_uk)),\n                          jaxpr_unknown.effects, source)\n  for t in out_tracers: t.recipe = eqn\n\n  # Merge known and unknown outputs into final result.\n  return util.merge_lists(out_uk, out_known, out_tracers)",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 27,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}