{
  "code": "def _update_tabs(self, *l):\n        self_content = self.content\n        if not self_content:\n            return\n        # cache variables for faster access\n        tab_pos = self.tab_pos\n        tab_layout = self._tab_layout\n        tab_layout.clear_widgets()\n        scrl_v = ScrollView(size_hint=(None, 1))\n        tabs = self._tab_strip\n        parent = tabs.parent\n        if parent:\n            parent.remove_widget(tabs)\n        scrl_v.add_widget(tabs)\n        scrl_v.pos = (0, 0)\n        self_update_scrollview = self._update_scrollview\n\n        # update scrlv width when tab width changes depends on tab_pos\n        if self._partial_update_scrollview is not None:\n            tabs.unbind(width=self._partial_update_scrollview)\n        self._partial_update_scrollview = partial(\n            self_update_scrollview, scrl_v)\n        tabs.bind(width=self._partial_update_scrollview)\n\n        # remove all widgets from the tab_strip\n        self.clear_widgets(do_super=True)\n        tab_height = self.tab_height\n\n        widget_list = []\n        tab_list = []\n        pos_letter = tab_pos[0]\n        if pos_letter == 'b' or pos_letter == 't':\n            # bottom or top positions\n            # one col containing the tab_strip and the content\n            self.cols = 1\n            self.rows = 2\n            # tab_layout contains the scrollview containing tabs and two blank\n            # dummy widgets for spacing\n            tab_layout.rows = 1\n            tab_layout.cols = 3\n            tab_layout.size_hint = (1, None)\n            tab_layout.height = (tab_height + tab_layout.padding[1] +\n                                 tab_layout.padding[3] + dp(2))\n            self_update_scrollview(scrl_v)\n\n            if pos_letter == 'b':\n                # bottom\n                if tab_pos == 'bottom_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                    widget_list = (self_content, tab_layout)\n                else:\n                    if tab_pos == 'bottom_left':\n                        tab_list = (scrl_v, Widget(), Widget())\n                    elif tab_pos == 'bottom_right':\n                        # add two dummy widgets\n                        tab_list = (Widget(), Widget(), scrl_v)\n                    widget_list = (self_content, tab_layout)\n            else:\n                # top\n                if tab_pos == 'top_mid':\n                    tab_list = (Widget(), scrl_v, Widget())\n                elif tab_pos == 'top_left':\n                    tab_list = (scrl_v, Widget(), Widget())\n                elif tab_pos == 'top_right':\n                    tab_list = (Widget(), Widget(), scrl_v)\n                widget_list = (tab_layout, self_content)\n        elif pos_letter == 'l' or pos_letter == 'r':\n            # left ot right positions\n            # one row containing the tab_strip and the content\n            self.cols = 2\n            self.rows = 1\n            # tab_layout contains two blank dummy widgets for spacing\n            # \"vertically\" and the scatter containing scrollview\n            # containing tabs\n            tab_layout.rows = 3\n            tab_layout.cols = 1\n            tab_layout.size_hint = (None, 1)\n            tab_layout.width = tab_height\n            scrl_v.height = tab_height\n            self_update_scrollview(scrl_v)\n\n            # rotate the scatter for vertical positions\n            rotation = 90 if tab_pos[0] == 'l' else -90\n            sctr = Scatter(do_translation=False,\n                           rotation=rotation,\n                           do_rotation=False,\n                           do_scale=False,\n                           size_hint=(None, None),\n                           auto_bring_to_front=False,\n                           size=scrl_v.size)\n            sctr.add_widget(scrl_v)\n\n            lentab_pos = len(tab_pos)\n\n            # Update scatter's top when its pos changes.\n            # Needed for repositioning scatter to the correct place after its\n            # added to the parent. Use clock_schedule_once to ensure top is\n            # calculated after the parent's pos on canvas has been calculated.\n            # This is needed for when tab_pos changes to correctly position\n            # scatter. Without clock.schedule_once the positions would look\n            # fine but touch won't translate to the correct position\n\n            if tab_pos[lentab_pos - 4:] == '_top':\n                # on positions 'left_top' and 'right_top'\n                sctr.bind(pos=partial(self._update_top, sctr, 'top', None))\n                tab_list = (sctr, )\n            elif tab_pos[lentab_pos - 4:] == '_mid':\n                # calculate top of scatter\n                sctr.bind(pos=partial(self._update_top, sctr, 'mid',\n                                      scrl_v.width))\n                tab_list = (Widget(), sctr, Widget())\n            elif tab_pos[lentab_pos - 7:] == '_bottom':\n                tab_list = (Widget(), Widget(), sctr)\n\n            if pos_letter == 'l':\n                widget_list = (tab_layout, self_content)\n            else:\n                widget_list = (self_content, tab_layout)\n\n        # add widgets to tab_layout\n        add = tab_layout.add_widget\n        for widg in tab_list:\n            add(widg)\n\n        # add widgets to self\n        add = self.add_widget\n        for widg in widget_list:\n            add(widg)",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 66,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}