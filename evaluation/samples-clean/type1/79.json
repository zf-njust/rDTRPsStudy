{
  "code": "def _fix_and_make_graph(self, nodes):\n\n        nodes_ = []\n        for n in nodes:\n            if isinstance(n, str):\n                if n.startswith('<') and n.endswith('>') and (not n.startswith('<pointer:')):\n                    pass\n                else:\n                    nodes_.append(n)\n            else:\n                nodes_.append(n)\n        nodes = nodes_\n\n        if True:\n            i = 0\n            nodes_ = []\n            while i < len(nodes):\n                nxt = nodes[i]\n                pst = None\n                if isinstance(nxt, str) and nxt.startswith('<pointer:'):\n                    e = nxt.find('>')\n                    if e != len(nxt) -1:\n                        pst = nxt[e+1:]\n                        nxt = nxt[:e+1]\n                    nodes_.append(nxt)\n                    if pst is not None:\n                        nodes_.append(pst)\n                else:\n                    nodes_.append(nxt)\n                i += 1\n            nodes = nodes_\n\n            i = 1\n            nodes_ = [nodes[0]]\n            while i < len(nodes):\n                nxt = nodes[i]\n                if isinstance(nxt, str) and nxt.startswith('<pointer:'):\n                    nxt = 'z' + nxt[9:-1]\n                    fol = nodes[i+1]\n                    # is not expansion\n                    if isinstance(fol, str) and (fol.startswith(':') or (fol == ')')):\n                        nodes_.append(nxt)\n                    else:\n                        if self.remove_pars:\n                            nodes_.append('(')\n                        else:\n                            if nodes_[-1] != '(':\n                                nodes_.append('(')\n                                #pass\n                        nodes_.append(nxt)\n                        nodes_.append('/')\n                else:\n                    nodes_.append(nxt)\n                i += 1\n            nodes = nodes_\n\n        i = 0\n        nodes_ = []\n        while i < (len(nodes) - 1):\n            if nodes[i] == ':':\n                nodes_.append(nodes[i] + nodes[i+1])\n                i += 2\n                last = False\n            else:\n                nodes_.append(nodes[i])\n                i += 1\n                last = True\n        if last:\n            nodes_.append(nodes[-1])\n        nodes = nodes_\n\n        i = 0\n        nodes_ = []\n        while i < (len(nodes)):\n            if i < 2:\n                nodes_.append(nodes[i])\n                i += 1\n            elif nodes_[-2] == '/' and nodes[i] == '/':\n                i += 2\n            else:\n                nodes_.append(nodes[i])\n                i += 1\n        nodes = nodes_\n\n        i = 0\n        newvars = 0\n        variables = set()\n        remap = {}\n        nodes_ = []\n        while i < (len(nodes)):\n\n            next = nodes[i]\n\n            if next == '/':\n                last = nodes_[-1]\n                if last in variables:\n                    last_remap = f\"z{newvars+1000}\"\n                    newvars += 1\n                    nodes_[-1] = last_remap\n                    remap[last] = last_remap\n                variables.add(last)\n                nodes_.append(next)\n\n            elif self._classify(next) == 'VAR' and next in remap and (i < len(nodes) - 1) and nodes[i+1] != '/':\n                next = remap[next]\n                nodes_.append(next)\n\n            else:\n                nodes_.append(next)\n\n            i += 1\n\n        nodes = nodes_\n        pieces_ = []\n        open_cnt = 0\n        closed_cnt = 0\n        if nodes[0] != '(':\n            pieces_.append('(')\n            open_cnt += 1\n        for p in nodes:\n            if p == '(':\n                open_cnt += 1\n            elif p == ')':\n                closed_cnt += 1\n            pieces_.append(p)\n            if open_cnt == closed_cnt:\n                break\n        nodes = pieces_ + [')'] * (open_cnt - closed_cnt)\n\n        pieces = []\n        for piece in nodes:\n            if not pieces:\n                pieces.append('(')\n            else:\n                piece = str(piece)\n                if piece.startswith('\"') or piece.startswith('\"') or '\"' in piece.strip('\"'):\n                    piece = '\"' + piece.replace('\"', '') + '\"'\n\n                prev = self._classify(pieces[-1])\n                next = self._classify(piece)\n\n                if next == 'CONST':\n                    quote = False\n                    for char in (',', ':', '/', '(', ')', '.', '!', '?', '\\\\', '_', '='):\n                        if char in piece:\n                            quote = True\n                            break\n                    if quote:\n                        piece = '\"' + piece.strip('\"') + '\"'\n\n                if  prev == '(':\n                    if next in ('VAR', 'I'):\n                        pieces.append(piece)\n                elif prev == ')':\n                    if next in (')', 'EDGE', 'MODE'):\n                        pieces.append(piece)\n                elif prev == 'VAR':\n                    if next in ('/', 'EDGE', 'MODE', ')'):\n                        pieces.append(piece)\n                elif prev == '/':\n                    if next in ('INST', 'I'):\n                        pieces.append(piece)\n                elif prev == 'INST':\n                    if next in (')', 'EDGE', 'MODE'):\n                        pieces.append(piece)\n                elif prev == 'I':\n                    if next in ('/', ')', 'EDGE', 'MODE'):\n                        pieces.append(piece)\n                elif prev == 'EDGE':\n                    if next in ('(', 'VAR', 'CONST', 'I'):\n                        pieces.append(piece)\n                    elif next == ')':\n                        pieces[-1] = piece\n                    elif next in ('EDGE', 'MODE'):\n                        pieces[-1] = piece\n                elif prev == 'MODE':\n                    if next == 'INST':\n                        pieces.append(piece)\n                elif prev == 'CONST':\n                    if next in (')', 'EDGE', 'MODE'):\n                        pieces.append(piece)\n\n        pieces_ = []\n        open_cnt = 0\n        closed_cnt = 0\n        if pieces[0] != '(':\n            pieces_.append('(')\n            open_cnt += 1\n        for p in pieces:\n            if p == '(':\n                open_cnt += 1\n            elif p == ')':\n                closed_cnt += 1\n            pieces_.append(p)\n            if open_cnt == closed_cnt:\n                break\n        pieces = pieces_ + [')'] * (open_cnt - closed_cnt)\n\n        linearized = re.sub(r'\\s+', ' ', ' '.join(pieces)).strip()\n\n        \"\"\"\n        line = linearized\n        # make sure parentheses match\n        # copied from https://github.com/RikVN/AMR/blob/master/restoreAMR/restore_amr.py\n        open_count = 0\n        close_count = 0\n        for i, c in enumerate(line):\n            if c == '(':\n                open_count += 1\n            elif c == ')':\n                close_count += 1\n            if open_count == close_count and open_count > 0:\n                line = line[:i].strip()\n                break\n        old_line = line\n        while True:\n            open_count = len(re.findall(r'\\(', line))\n            close_count = len(re.findall(r'\\)', line))\n            if open_count > close_count:\n                line += ')' * (open_count - close_count)\n            elif close_count > open_count:\n                for i in range(close_count - open_count):\n                    line = line.rstrip(')')\n                    line = line.rstrip(' ')\n            if old_line == line:\n                break\n            old_line = line\n        \"\"\"\n\n        graph = penman.decode(linearized + ' ')\n        triples = []\n        newvars = 2000\n        for triple in graph.triples:\n            x, rel, y = triple\n            if x is None:\n                pass\n            elif rel == ':instance' and y is None:\n                triples.append(penman.Triple(x, rel, 'thing'))\n            elif y is None:\n                var = f'z{newvars}'\n                newvars += 1\n                triples.append(penman.Triple(x, rel, var))\n                triples.append(penman.Triple(var, ':instance', 'thing'))\n            else:\n                triples.append(triple)\n        graph = penman.Graph(triples)\n        linearized = encode(graph)\n\n        def fix_text(linearized=linearized):\n            n = 0\n            def _repl1(match):\n                nonlocal n\n                out = match.group(1) + match.group(2) + str(3000 + n) + ' / ' + match.group(2) + match.group(3)\n                n += 1\n                return out\n            linearized = re.sub(r'(\\(\\s?)([a-z])([^\\/:\\)]+[:\\)])', _repl1, linearized,\n                                flags=re.IGNORECASE | re.MULTILINE)\n\n            def _repl2(match):\n                return match.group(1)\n            linearized = re.sub(r'(\\(\\s*[a-z][\\d+]\\s*\\/\\s*[^\\s\\)\\(:\\/]+\\s*)((?:/\\s*[^\\s\\)\\(:\\/]+\\s*)+)', _repl2,\n                                linearized,\n                                flags=re.IGNORECASE | re.MULTILINE)\n\n            # adds a ':' to args w/o it\n            linearized = re.sub(r'([^:])(ARG)', r'\\1 :\\2', linearized)\n\n            # removes edges with no node\n            # linearized = re.sub(r':[^\\s\\)\\(:\\/]+?\\s*\\)', ')', linearized, flags=re.MULTILINE)\n\n            return linearized\n\n        linearized = fix_text(linearized)\n        g = penman.decode(linearized)\n        return g",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 95,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}