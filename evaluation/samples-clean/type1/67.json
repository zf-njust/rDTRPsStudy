{
  "code": "def _preprocess_speaker(speaker_dir: Path, datasets_root: Path, out_dir: Path, skip_existing: bool):\n    # Give a name to the speaker that includes its dataset\n    speaker_name = \"_\".join(speaker_dir.relative_to(datasets_root).parts)\n\n    # Create an output directory with that name, as well as a txt file containing a\n    # reference to each source file.\n    speaker_out_dir = out_dir.joinpath(speaker_name)\n    speaker_out_dir.mkdir(exist_ok=True)\n    sources_fpath = speaker_out_dir.joinpath(\"_sources.txt\")\n\n    # There's a possibility that the preprocessing was interrupted earlier, check if\n    # there already is a sources file.\n    if sources_fpath.exists():\n        try:\n            with sources_fpath.open(\"r\") as sources_file:\n                existing_fnames = {line.split(\",\")[0] for line in sources_file}\n        except:\n            existing_fnames = {}\n    else:\n        existing_fnames = {}\n\n    # Gather all audio files for that speaker recursively\n    sources_file = sources_fpath.open(\"a\" if skip_existing else \"w\")\n    audio_durs = []\n    for extension in _AUDIO_EXTENSIONS:\n        for in_fpath in speaker_dir.glob(\"**/*.%s\" % extension):\n            # Check if the target output file already exists\n            out_fname = \"_\".join(in_fpath.relative_to(speaker_dir).parts)\n            out_fname = out_fname.replace(\".%s\" % extension, \".npy\")\n            if skip_existing and out_fname in existing_fnames:\n                continue\n\n            # Load and preprocess the waveform\n            wav = audio.preprocess_wav(in_fpath)\n            if len(wav) == 0:\n                continue\n\n            # Create the mel spectrogram, discard those that are too short\n            frames = audio.wav_to_mel_spectrogram(wav)\n            if len(frames) < partials_n_frames:\n                continue\n\n            out_fpath = speaker_out_dir.joinpath(out_fname)\n            np.save(out_fpath, frames)\n            sources_file.write(\"%s,%s\\n\" % (out_fname, in_fpath))\n            audio_durs.append(len(wav) / sampling_rate)\n\n    sources_file.close()\n\n    return audio_durs",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 20,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}