{
  "code": "def _check_scan_carry_type(body_fun, in_carry, out_carry_tree, out_avals):\n  try:\n    sig = inspect.signature(body_fun)\n  except (ValueError, TypeError):\n    sig = None\n  carry_name = sig and list(sig.parameters)[0]\n  if carry_name:\n    component = lambda p: (f'the input carry component {carry_name}{keystr(p)}'\n                           if p else f'the input carry {carry_name}')\n  else:\n    component = lambda p: (f'the input carry at path {keystr(p)}'\n                           if p else 'the input carry')\n  leaves_and_paths, in_carry_tree = tree_flatten_with_path(in_carry)\n  paths, in_carry_flat = unzip2(leaves_and_paths)\n  in_avals = _map(_abstractify, in_carry_flat)\n  if in_carry_tree != out_carry_tree:\n    try:\n      out_carry = tree_unflatten(out_carry_tree, out_avals)\n    except:\n      out_carry = None\n\n    if out_carry is None:\n      differences = [f'the input tree structure is:\\n{in_carry_tree}\\n',\n                     f'the output tree structure is:\\n{out_carry_tree}\\n']\n    else:\n      differences = '\\n'.join(\n          f'  * {component(path)} is a {thing1} but the corresponding component '\n          f'of the carry output is a {thing2}, so {explanation}\\n'\n          for path, thing1, thing2, explanation\n          in equality_errors(in_carry, out_carry))\n    raise TypeError(\n        \"Scanned function carry input and carry output must have the same \"\n        \"pytree structure, but they differ:\\n\"\n        f\"{differences}\\n\"\n        \"Revise the scanned function so that its output is a pair where the \"\n        \"first element has the same pytree structure as the first argument.\"\n    )\n  if not all(_map(core.typematch, in_avals, out_avals)):\n    differences = '\\n'.join(\n        f'  * {component(path)} has type {in_aval.str_short()}'\n        ' but the corresponding output carry component has type '\n        f'{out_aval.str_short()}{_aval_mismatch_extra(in_aval, out_aval)}\\n'\n        for path, in_aval, out_aval in zip(paths, in_avals, out_avals)\n        if not core.typematch(in_aval, out_aval))\n    raise TypeError(\n        \"Scanned function carry input and carry output must have equal types \"\n        \"(e.g. shapes and dtypes of arrays), \"\n        \"but they differ:\\n\"\n        f\"{differences}\\n\"\n        \"Revise the scanned function so that all output types (e.g. shapes \"\n        \"and dtypes) match the corresponding input types.\"\n    )",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 26,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}