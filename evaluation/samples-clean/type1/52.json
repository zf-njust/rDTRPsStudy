{
  "code": "def make(\n    id: Union[str, EnvSpec],\n    max_episode_steps: Optional[int] = None,\n    autoreset: bool = False,\n    apply_api_compatibility: Optional[bool] = None,\n    disable_env_checker: Optional[bool] = None,\n    **kwargs,\n) -> Env:\n    \"\"\"Create an environment according to the given ID.\n\n    To find all available environments use `gym.envs.registry.keys()` for all valid ids.\n\n    Args:\n        id: Name of the environment. Optionally, a module to import can be included, eg. 'module:Env-v0'\n        max_episode_steps: Maximum length of an episode (TimeLimit wrapper).\n        autoreset: Whether to automatically reset the environment after each episode (AutoResetWrapper).\n        apply_api_compatibility: Whether to wrap the environment with the `StepAPICompatibility` wrapper that\n            converts the environment step from a done bool to return termination and truncation bools.\n            By default, the argument is None to which the environment specification `apply_api_compatibility` is used\n            which defaults to False. Otherwise, the value of `apply_api_compatibility` is used.\n            If `True`, the wrapper is applied otherwise, the wrapper is not applied.\n        disable_env_checker: If to run the env checker, None will default to the environment specification `disable_env_checker`\n            (which is by default False, running the environment checker),\n            otherwise will run according to this parameter (`True` = not run, `False` = run)\n        kwargs: Additional arguments to pass to the environment constructor.\n\n    Returns:\n        An instance of the environment.\n\n    Raises:\n        Error: If the ``id`` doesn't exist then an error is raised\n    \"\"\"\n    if isinstance(id, EnvSpec):\n        spec_ = id\n    else:\n        module, id = (None, id) if \":\" not in id else id.split(\":\")\n        if module is not None:\n            try:\n                importlib.import_module(module)\n            except ModuleNotFoundError as e:\n                raise ModuleNotFoundError(\n                    f\"{e}. Environment registration via importing a module failed. \"\n                    f\"Check whether '{module}' contains env registration and can be imported.\"\n                )\n        spec_ = registry.get(id)\n\n        ns, name, version = parse_env_id(id)\n        latest_version = find_highest_version(ns, name)\n        if (\n            version is not None\n            and latest_version is not None\n            and latest_version > version\n        ):\n            logger.warn(\n                f\"The environment {id} is out of date. You should consider \"\n                f\"upgrading to version `v{latest_version}`.\"\n            )\n        if version is None and latest_version is not None:\n            version = latest_version\n            new_env_id = get_env_id(ns, name, version)\n            spec_ = registry.get(new_env_id)\n            logger.warn(\n                f\"Using the latest versioned environment `{new_env_id}` \"\n                f\"instead of the unversioned environment `{id}`.\"\n            )\n\n        if spec_ is None:\n            _check_version_exists(ns, name, version)\n            raise error.Error(f\"No registered env with id: {id}\")\n\n    _kwargs = spec_.kwargs.copy()\n    _kwargs.update(kwargs)\n\n    if spec_.entry_point is None:\n        raise error.Error(f\"{spec_.id} registered but entry_point is not specified\")\n    elif callable(spec_.entry_point):\n        env_creator = spec_.entry_point\n    else:\n        # Assume it's a string\n        env_creator = load(spec_.entry_point)\n\n    mode = _kwargs.get(\"render_mode\")\n    apply_human_rendering = False\n    apply_render_collection = False\n\n    # If we have access to metadata we check that \"render_mode\" is valid and see if the HumanRendering wrapper needs to be applied\n    if mode is not None and hasattr(env_creator, \"metadata\"):\n        assert isinstance(\n            env_creator.metadata, dict\n        ), f\"Expect the environment creator ({env_creator}) metadata to be dict, actual type: {type(env_creator.metadata)}\"\n\n        if \"render_modes\" in env_creator.metadata:\n            render_modes = env_creator.metadata[\"render_modes\"]\n            if not isinstance(render_modes, Sequence):\n                logger.warn(\n                    f\"Expects the environment metadata render_modes to be a Sequence (tuple or list), actual type: {type(render_modes)}\"\n                )\n\n            # Apply the `HumanRendering` wrapper, if the mode==\"human\" but \"human\" not in render_modes\n            if (\n                mode == \"human\"\n                and \"human\" not in render_modes\n                and (\"rgb_array\" in render_modes or \"rgb_array_list\" in render_modes)\n            ):\n                logger.warn(\n                    \"You are trying to use 'human' rendering for an environment that doesn't natively support it. \"\n                    \"The HumanRendering wrapper is being applied to your environment.\"\n                )\n                apply_human_rendering = True\n                if \"rgb_array\" in render_modes:\n                    _kwargs[\"render_mode\"] = \"rgb_array\"\n                else:\n                    _kwargs[\"render_mode\"] = \"rgb_array_list\"\n            elif (\n                mode not in render_modes\n                and mode.endswith(\"_list\")\n                and mode[: -len(\"_list\")] in render_modes\n            ):\n                _kwargs[\"render_mode\"] = mode[: -len(\"_list\")]\n                apply_render_collection = True\n            elif mode not in render_modes:\n                logger.warn(\n                    f\"The environment is being initialised with mode ({mode}) that is not in the possible render_modes ({render_modes}).\"\n                )\n        else:\n            logger.warn(\n                f\"The environment creator metadata doesn't include `render_modes`, contains: {list(env_creator.metadata.keys())}\"\n            )\n\n    if apply_api_compatibility is True or (\n        apply_api_compatibility is None and spec_.apply_api_compatibility is True\n    ):\n        # If we use the compatibility layer, we treat the render mode explicitly and don't pass it to the env creator\n        render_mode = _kwargs.pop(\"render_mode\", None)\n    else:\n        render_mode = None\n\n    try:\n        env = env_creator(**_kwargs)\n    except TypeError as e:\n        if (\n            str(e).find(\"got an unexpected keyword argument 'render_mode'\") >= 0\n            and apply_human_rendering\n        ):\n            raise error.Error(\n                f\"You passed render_mode='human' although {id} doesn't implement human-rendering natively. \"\n                \"Gym tried to apply the HumanRendering wrapper but it looks like your environment is using the old \"\n                \"rendering API, which is not supported by the HumanRendering wrapper.\"\n            )\n        else:\n            raise e\n\n    # Copies the environment creation specification and kwargs to add to the environment specification details\n    spec_ = copy.deepcopy(spec_)\n    spec_.kwargs = _kwargs\n    env.unwrapped.spec = spec_\n\n    # Add step API wrapper\n    if apply_api_compatibility is True or (\n        apply_api_compatibility is None and spec_.apply_api_compatibility is True\n    ):\n        env = EnvCompatibility(env, render_mode)\n\n    # Run the environment checker as the lowest level wrapper\n    if disable_env_checker is False or (\n        disable_env_checker is None and spec_.disable_env_checker is False\n    ):\n        env = PassiveEnvChecker(env)\n\n    # Add the order enforcing wrapper\n    if spec_.order_enforce:\n        env = OrderEnforcing(env)\n\n    # Add the time limit wrapper\n    if max_episode_steps is not None:\n        env = TimeLimit(env, max_episode_steps)\n    elif spec_.max_episode_steps is not None:\n        env = TimeLimit(env, spec_.max_episode_steps)\n\n    # Add the autoreset wrapper\n    if autoreset:\n        env = AutoResetWrapper(env)\n\n    # Add human rendering wrapper\n    if apply_human_rendering:\n        env = HumanRendering(env)\n    elif apply_render_collection:\n        env = RenderCollection(env)\n\n    return env",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 36,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}