{
  "code": "    def _read_to_buffer(self):\n        \"\"\"Reads from the socket and appends the result to the read buffer.\n\n        Returns the number of bytes read.  Returns 0 if there is nothing\n        to read (i.e. the read returns EWOULDBLOCK or equivalent).  On\n        error closes the socket and raises an exception.\n        \"\"\"\n        try:\n            while True:\n                try:\n                    if self._user_read_buffer:\n                        buf = memoryview(self._read_buffer)[self._read_buffer_size:]\n                    else:\n                        buf = bytearray(self.read_chunk_size)\n                    bytes_read = self.read_from_fd(buf)\n                except (socket.error, IOError, OSError) as e:\n                    if errno_from_exception(e) == errno.EINTR:\n                        continue\n                    # ssl.SSLError is a subclass of socket.error\n                    if self._is_connreset(e):\n                        # Treat ECONNRESET as a connection close rather than\n                        # an error to minimize log spam  (the exception will\n                        # be available on self.error for apps that care).\n                        self.close(exc_info=e)\n                        return\n                    self.close(exc_info=e)\n                    raise\n                break\n            if bytes_read is None:\n                return 0\n            elif bytes_read == 0:\n                self.close()\n                return 0\n            if not self._user_read_buffer:\n                self._read_buffer += memoryview(buf)[:bytes_read]\n            self._read_buffer_size += bytes_read\n        finally:\n            # Break the reference to buf so we don't waste a chunk's worth of\n            # memory in case an exception hangs on to our stack frame.\n            buf = None\n        if self._read_buffer_size > self.max_buffer_size:\n            gen_log.error(\"Reached maximum read buffer size\")\n            self.close()\n            raise StreamBufferFullError(\"Reached maximum read buffer size\")\n        return bytes_read",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 14,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}