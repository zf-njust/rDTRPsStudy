{
  "code": "def format_records(self, records):\n        Colors = self.Colors  # just a shorthand + quicker name lookup\n        ColorsNormal = Colors.Normal  # used a lot\n        col_scheme = self.color_scheme_table.active_scheme_name\n        indent = ' ' * INDENT_SIZE\n        em_normal = '%s\\n%s%s' % (Colors.valEm, indent, ColorsNormal)\n        undefined = '%sundefined%s' % (Colors.em, ColorsNormal)\n        frames = []\n        # build some color string templates outside these nested loops\n        tpl_link = '%s%%s%s' % (Colors.filenameEm, ColorsNormal)\n        tpl_call = 'in %s%%s%s%%s%s' % (Colors.vName, Colors.valEm,\n                                        ColorsNormal)\n        tpl_call_fail = 'in %s%%s%s(***failed resolving arguments***)%s' % \\\n                        (Colors.vName, Colors.valEm, ColorsNormal)\n        tpl_local_var = '%s%%s%s' % (Colors.vName, ColorsNormal)\n        tpl_global_var = '%sglobal%s %s%%s%s' % (Colors.em, ColorsNormal,\n                                                 Colors.vName, ColorsNormal)\n        tpl_name_val = '%%s %s= %%s%s' % (Colors.valEm, ColorsNormal)\n\n        tpl_line = '%s%%s%s %%s' % (Colors.lineno, ColorsNormal)\n        tpl_line_em = '%s%%s%s %%s%s' % (Colors.linenoEm, Colors.line,\n                                         ColorsNormal)\n\n        abspath = os.path.abspath\n        for frame, file, lnum, func, lines, index in records:\n            #print '*** record:',file,lnum,func,lines,index  # dbg\n            if not file:\n                file = '?'\n            elif file.startswith(str(\"<\")) and file.endswith(str(\">\")):\n                # Not a real filename, no problem...\n                pass\n            elif not os.path.isabs(file):\n                # Try to make the filename absolute by trying all\n                # sys.path entries (which is also what linecache does)\n                for dirname in sys.path:\n                    try:\n                        fullname = os.path.join(dirname, file)\n                        if os.path.isfile(fullname):\n                            file = os.path.abspath(fullname)\n                            break\n                    except Exception:\n                        # Just in case that sys.path contains very\n                        # strange entries...\n                        pass\n\n            file = py3compat.cast_unicode(file, util_path.fs_encoding)\n            link = tpl_link % file\n            args, varargs, varkw, locals = fixed_getargvalues(frame)\n\n            if func == '?':\n                call = ''\n            else:\n                # Decide whether to include variable details or not\n                var_repr = self.include_vars and eqrepr or nullrepr\n                try:\n                    call = tpl_call % (func, inspect.formatargvalues(args,\n                                                                     varargs, varkw,\n                                                                     locals, formatvalue=var_repr))\n                except KeyError:\n                    # This happens in situations like errors inside generator\n                    # expressions, where local variables are listed in the\n                    # line, but can't be extracted from the frame.  I'm not\n                    # 100% sure this isn't actually a bug in inspect itself,\n                    # but since there's no info for us to compute with, the\n                    # best we can do is report the failure and move on.  Here\n                    # we must *not* call any traceback construction again,\n                    # because that would mess up use of %debug later on.  So we\n                    # simply report the failure and move on.  The only\n                    # limitation will be that this frame won't have locals\n                    # listed in the call signature.  Quite subtle problem...\n                    # I can't think of a good way to validate this in a unit\n                    # test, but running a script consisting of:\n                    #  dict( (k,v.strip()) for (k,v) in range(10) )\n                    # will illustrate the error, if this exception catch is\n                    # disabled.\n                    call = tpl_call_fail % func\n\n            # Don't attempt to tokenize binary files.\n            if file.endswith(('.so', '.pyd', '.dll')):\n                frames.append('%s %s\\n' % (link, call))\n                continue\n            elif file.endswith(('.pyc', '.pyo')):\n                # Look up the corresponding source file.\n                file = openpy.source_from_cache(file)\n\n            def linereader(file=file, lnum=[lnum], getline=ulinecache.getline):\n                line = getline(file, lnum[0])\n                lnum[0] += 1\n                return line\n\n            # Build the list of names on this line of code where the exception\n            # occurred.\n            try:\n                names = []\n                name_cont = False\n\n                for token_type, token, start, end, line in generate_tokens(linereader):\n                    # build composite names\n                    if token_type == tokenize.NAME and token not in keyword.kwlist:\n                        if name_cont:\n                            # Continuation of a dotted name\n                            try:\n                                names[-1].append(token)\n                            except IndexError:\n                                names.append([token])\n                            name_cont = False\n                        else:\n                            # Regular new names.  We append everything, the caller\n                            # will be responsible for pruning the list later.  It's\n                            # very tricky to try to prune as we go, b/c composite\n                            # names can fool us.  The pruning at the end is easy\n                            # to do (or the caller can print a list with repeated\n                            # names if so desired.\n                            names.append([token])\n                    elif token == '.':\n                        name_cont = True\n                    elif token_type == tokenize.NEWLINE:\n                        break\n\n            except (IndexError, UnicodeDecodeError, SyntaxError):\n                # signals exit of tokenizer\n                # SyntaxError can occur if the file is not actually Python\n                #  - see gh-6300\n                pass\n            except tokenize.TokenError as msg:\n                _m = (\"An unexpected error occurred while tokenizing input\\n\"\n                      \"The following traceback may be corrupted or invalid\\n\"\n                      \"The error message is: %s\\n\" % msg)\n                error(_m)\n\n            # Join composite names (e.g. \"dict.fromkeys\")\n            names = ['.'.join(n) for n in names]\n            # prune names list of duplicates, but keep the right order\n            unique_names = uniq_stable(names)\n\n            # Start loop over vars\n            lvals = []\n            if self.include_vars:\n                for name_full in unique_names:\n                    name_base = name_full.split('.', 1)[0]\n                    if name_base in frame.f_code.co_varnames:\n                        if name_base in locals:\n                            try:\n                                value = repr(eval(name_full, locals))\n                            except:\n                                value = undefined\n                        else:\n                            value = undefined\n                        name = tpl_local_var % name_full\n                    else:\n                        if name_base in frame.f_globals:\n                            try:\n                                value = repr(eval(name_full, frame.f_globals))\n                            except:\n                                value = undefined\n                        else:\n                            value = undefined\n                        name = tpl_global_var % name_full\n                    lvals.append(tpl_name_val % (name, value))\n            if lvals:\n                lvals = '%s%s' % (indent, em_normal.join(lvals))\n            else:\n                lvals = ''\n\n            level = '%s %s\\n' % (link, call)\n\n            if index is None:\n                frames.append(level)\n            else:\n                frames.append('%s%s' % (level, ''.join(\n                    _format_traceback_lines(lnum, index, lines, Colors, lvals,\n                                            col_scheme))))\n\n        return frames",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 163,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}