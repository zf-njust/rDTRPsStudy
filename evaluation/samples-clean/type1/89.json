{
  "code": "def sdp_eval(gold_files, sys_files, labeled=False):\n    \"\"\"Modified from https://github.com/tdozat/Parser-v3/blob/2ff4061373e8aac8c962537a6220e1d5b196abf6/scripts/semdep_eval.py\n    Dozat claimed \"I tested it against the official eval script and it reported identical LF1\".\n\n    Args:\n      gold_files: \n      sys_files: \n      labeled:  (Default value = False)\n\n    Returns:\n\n    \n    \"\"\"\n\n    correct = 0\n    predicted = 0\n    actual = 0\n    n_tokens = 0\n    n_sequences = 0\n    current_seq_correct = False\n    n_correct_sequences = 0\n    current_sent = 0\n    if isinstance(gold_files, str):\n        gold_files = [gold_files]\n    if isinstance(sys_files, str):\n        sys_files = [sys_files]\n\n    for gold_file, sys_file in zip(gold_files, sys_files):\n        with codecs.open(gold_file, encoding='utf-8') as gf, \\\n                codecs.open(sys_file, encoding='utf-8') as sf:\n            gold_line = gf.readline()\n            gold_i = 1\n            sys_i = 0\n            while gold_line:\n                while gold_line.startswith('#'):\n                    current_sent += 1\n                    gold_i += 1\n                    n_sequences += 1\n                    n_correct_sequences += current_seq_correct\n                    current_seq_correct = True\n                    gold_line = gf.readline()\n                if gold_line.rstrip() != '':\n                    sys_line = sf.readline()\n                    sys_i += 1\n                    while sys_line.startswith('#') or sys_line.rstrip() == '' or sys_line.split('\\t')[0] == '0':\n                        sys_line = sf.readline()\n                        sys_i += 1\n\n                    gold_line = gold_line.rstrip().split('\\t')\n                    sys_line = sys_line.rstrip().split('\\t')\n                    # assert sys_line[1] == gold_line[1], 'Files are misaligned at lines {}, {}'.format(gold_i, sys_i)\n\n                    # Compute the gold edges\n                    gold_node = gold_line[8]\n                    if gold_node != '_':\n                        gold_node = gold_node.split('|')\n                        if labeled:\n                            gold_edges = set(tuple(gold_edge.split(':', 1)) for gold_edge in gold_node)\n                        else:\n                            gold_edges = set(gold_edge.split(':', 1)[0] for gold_edge in gold_node)\n                    else:\n                        gold_edges = set()\n\n                    # Compute the sys edges\n                    sys_node = sys_line[8]\n                    if sys_node != '_':\n                        sys_node = sys_node.split('|')\n                        if labeled:\n                            sys_edges = set(tuple(sys_edge.split(':', 1)) for sys_edge in sys_node)\n                        else:\n                            sys_edges = set(sys_edge.split(':', 1)[0] for sys_edge in sys_node)\n                    else:\n                        sys_edges = set()\n\n                    correct_edges = gold_edges & sys_edges\n                    if len(correct_edges) != len(gold_edges):\n                        current_seq_correct = False\n                    correct += len(correct_edges)\n                    predicted += len(sys_edges)\n                    actual += len(gold_edges)\n                    n_tokens += 1\n                    # current_fp += len(sys_edges) - len(gold_edges & sys_edges)\n                gold_line = gf.readline()\n                gold_i += 1\n    # print(correct, predicted - correct, actual - correct)\n    Accuracy = namedtuple('Accuracy', ['precision', 'recall', 'F1', 'seq_acc'])\n    precision = correct / (predicted + 1e-12)\n    recall = correct / (actual + 1e-12)\n    F1 = 2 * precision * recall / (precision + recall + 1e-12)\n    seq_acc = n_correct_sequences / n_sequences\n    return Accuracy(precision, recall, F1, seq_acc)",
  "smell": [
    {
      "smell_id": 1,
      "line_no": 49,
      "description": "The variable is redefined with an inconsistent type object."
    }
  ]
}